-----------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------GGGGGGG----------EEEEEEEEE-------EEEEEEEEE-----------------------SSSSSSS-------KK------KK-------III-------DDDDDDD--------------------
-------------------GGG-------GGG-------EE--------------EE---------------------------ssss-------------KK-----KK--------III-------DD----DD-------------------
------------------GG-------------------EE--------------EE--------------------------sss---------------KK----KK---------III-------DD-----DD------------------
-----------------GG--------------------EE--------------EE--------------------------ss----------------KK---KK----------III-------DD------DD-----------------
-----------------GG--------------------EE--------------EE---------------------------ss---------------KK--KK-----------III-------DD------DD-----------------
-----------------GG-------GGGG---------EEEEEEEE--------EEEEEEEE-------=======--------sssssss---------KKKKK------------III-------DD------DD-----------------
-----------------GG----------GG--------EE--------------EE----------------------------------ss--------KK--KK-----------III-------DD------DD-----------------
-----------------GG-----------GG-------EE--------------EE-----------------------------------ss-------KK---KK----------III-------DD------DD-----------------
------------------GG----------GG-------EE--------------EE----------------------------------sss-------KK----KK---------III-------DD-----DD------------------
-------------------GG-------GG---------EE--------------EE--------------------------------ssss--------KK-----KK--------III-------DD----DD-------------------
--------------------GGGGGGGGG----------EEEEEEEEE-------EEEEEEEEE--------------------SSSSSSS----------KK------KK-------III-------DDDDDDD--------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------


menu.create_thread(function()
local __GV__ = "Gee-Skid v2.07"
local TIME_MS = utils.time_ms
local YIELD = system.yield
local TIME = TIME_MS() + 2000
local V2 = v2(0,-0.85)
while TIME > TIME_MS() do
	scriptdraw.draw_text(__GV__.." preparing to load",V2,V2,0.69,-1,1<<0,nil)
	YIELD(0)
end


local g = {}
g.prnt = {}
g.feat = {}
g.var = {}
g.var.GS_has_loaded=false
g.tbl = {}
g.tbl.threads = {}
g.tbl.entities = {}
g.o = {}
g.o.prnt = {}
g.o.feat = {}
g.o.var = {}
g.o.tbl = {}
g.paths  = {}
g.paths._popstar=utils.get_appdata_path("PopstarDevs", "")
g.paths._2t1=g.paths._popstar.."\\2Take1Menu\\"
g.paths._vehs=g.paths._2t1.."moddedVehicles\\"
g.paths._scripts=g.paths._2t1.."scripts\\"
g.paths._v2=g.paths._scripts.."GeeSkid_v2\\"
g.paths._lua_lib=g.paths._v2.."Lua Library\\"
g.paths._lang=g.paths._lua_lib.."Translation\\"
g.paths._cfg=g.paths._2t1.."cfg\\"
g.paths._radar = g.paths._v2.."Images\\2T1 Radar\\"
g.paths._reticle = g.paths._v2.."Images\\Custom Reticle\\"
g.paths._user=g.paths._cfg.."Gee-Skid - "..(os.getenv("USERNAME") or "Weird Username").."\\"
local API,ped_models,glbls,veh_stuff,inputs,ntv,intrr,funcs,mddrs,weap_info,tp_pos,PID_INFO,paints
local lang = {}
local mth={}
mth.flr = math.floor
mth.ceil = math.ceil
mth.rad = math.rad
mth.sin = math.sin
mth.cos = math.cos
mth.rndm = math.random
mth.abs = math.abs
mth.pi = math.pi
mth.atan = math.atan
mth.acos = math.acos
mth.asin = math.asin
mth.fmod = math.fmod
mth.deg = math.deg
g.script_load_time = TIME_MS()
g.script_load_time_temp = g.script_load_time
g.tbl.pid_kicked_mem = {}
g.og_notif = menu.notify

g.N_P_colors = {
["Red"] = 0x0040FF,
["Yellow"] = 0x42F5F5,
["Green"] = 0x42F551,
["Blue"] = 0xF5424B}

local table_concat = table.concat
local function get_all_parents_and_name(feat,only_parents) -- only_parents isnt used. Features with unique names (saved cars license plates etc) or a giant list like weapons/peds/cars wont be translated
	local FEAT = feat.feats and feat.feats[0] or feat
	local str = {}
	str[#str+1] = only_parents and "ONLY_TBL" or FEAT.name -- so this always returns FEAT.name
	local p1,n1 = FEAT.parent
	repeat
		n1 = p1.name
		str[#str+1] = n1
		p1 = p1.parent
	until n1 == "Gee-Skid"
	str[#str+1] = feat.feats and feat.feats[0] and "Online" or "Local"
	local str2 = {}
	for i=#str,1,-1 do
		str2[#str2+1]=str[i]
	end
	return table_concat(str2,"|")
end

local selected_lang = "English"
local dynamic_translation = {}
local debug_translation_list = {}
local debug_translation_record =true
local total_feat_count = 0

local basic_menu_add_feature = menu.add_feature

local function og_menu_add_feature(_name,_type,_parent,_function,_hint)
	local feat = basic_menu_add_feature(_name,_type,_parent,_function)
	if _hint then
		feat.hint=_hint
	end
	total_feat_count = total_feat_count + 1
	return feat
end

local function menu_add_feature(_name,_type,_parent,_function,_hint)
	local feat = og_menu_add_feature(_name,_type,_parent,_function,_hint)
	local str = get_all_parents_and_name(feat,false)
	dynamic_translation[str]=dynamic_translation[str] or {}
	dynamic_translation[str].FEAT=feat
	dynamic_translation[str].NAME=_name
	if _hint then
		dynamic_translation[str].HINT=_hint
	end
	return feat
end

local basic_menu_add_player_feature = menu.add_player_feature

local function og_menu_add_player_feature(_name,_type,_parent,_function,_hint)
	local feat = basic_menu_add_player_feature(_name,_type,_parent,_function)
	if _hint then
		feat.hint=_hint
	end
	total_feat_count = total_feat_count + 1
	return feat
end

local function menu_add_player_feature(_name,_type,_parent,_function,_hint)
	local feat = og_menu_add_player_feature(_name,_type,_parent,_function,_hint)
	local str = get_all_parents_and_name(feat,false)
	dynamic_translation[str]=dynamic_translation[str] or {}
	dynamic_translation[str].FEAT=feat
	dynamic_translation[str].NAME=_name

	if _hint then
		dynamic_translation[str].HINT=_hint
	end
	return feat
end

local function new_set_str_data(feat,tbl,only_parents)
	local str = get_all_parents_and_name(feat,only_parents)
	dynamic_translation[str]=dynamic_translation[str] or {}
	dynamic_translation[str].FEAT=dynamic_translation[str].FEAT or feat
	dynamic_translation[str].ONLY_PARENTS=only_parents
	local new_tbl = {}
	for k,v in ipairs(tbl) do
		new_tbl[#new_tbl+1]= v
	end
	dynamic_translation[str].TBL=new_tbl
	feat:set_str_data(new_tbl)
end

function g.N_P(_print_notif,_text,_title,_time,_color)
	-- 1 to print, 2 to notify, 3 to both
	if _print_notif ~= 2 then
		print(_text)
	end
	if _print_notif ~= 1 then
		g.og_notif(tostring(_text),_title,_time,g.N_P_colors[_color])
	end
end

g.var.load_count = 0
g.var.feat_loading_str = ""
g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	while not g.var.GS_has_loaded do
		scriptdraw.draw_text(__GV__.."\nLoading "..g.var.load_count.." | "..g.var.feat_loading_str.."\nLoading feature: ".. total_feat_count, V2,V2,0.69,-1,1<<0,nil)
		YIELD(0)
	end
	local TIME = TIME_MS() + 2000
	while TIME > TIME_MS() do
		scriptdraw.draw_text(__GV__.."\nLoading complete",V2,V2,0.69,-1,1<<0,nil)
		YIELD(0)
	end
end)

if _GS_has_started_loading then
	g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\n(Already loaded)",__GV__,10,"Red")
	menu.exit() return
elseif not menu.is_trusted_mode_enabled(1 << 1) then
	g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nTrusted mode for globals required.",__GV__,10,"Red")
	menu.exit() return
elseif not menu.is_trusted_mode_enabled(1 << 2) then
	g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nTrusted mode for natives required.",__GV__,10,"Red")
	menu.exit() return
else
	for k,v in ipairs({
	"GeeSkid_v2",
	"GeeSkid_v2\\Images",
	"GeeSkid_v2\\Images\\Custom Reticle",
	"GeeSkid_v2\\Images\\Vehicle ESP",
	"GeeSkid_v2\\Images\\2T1 Radar",
	"GeeSkid_v2\\Images\\Voidkot",
	"GeeSkid_v2\\Images\\Map",
	"GeeSkid_v2\\Lua Library"
	}) do
		if not utils.dir_exists(g.paths._scripts..v.."\\") then
			g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nYou must re-install Gee-Skid. You are missing a folder:\n\\2Take1Menu\\scripts\\"..v,__GV__,10,"Red")
			menu.exit() return
		end
	end
end

_GS_has_started_loading = true


local load_break_time = TIME_MS()
function g.load_break(val)
	if TIME_MS() > load_break_time then
		YIELD(0)
		load_break_time=TIME_MS()+(val or 25)
	end
end

function g.print_load_info(_text,_time,_line,_skip,no_yield)
	local text = __GV__.." loaded | ".._time

	for i=1,(4-string.len(_time)) do
		text=text.." "
	end

	text = text.." ms | Line ".._line

	for i=1,(5-string.len(_line)) do
		text=text.." "
	end

	text = text.." | ".._text

	print(text)
	if not _skip then
		g.script_load_time_temp = TIME_MS()
	end
	g.var.load_count= g.var.load_count+1
	if not no_yield then
		g.load_break()
	end
end

function g.script_file_check(_file)
	if not utils.file_exists(g.paths._lua_lib.._file..".lua") then
		g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nYou must re-install Gee-Skid. You are missing:\n\\2Take1Menu\\scripts\\GeeSkid_v2\\Lua Library\\".._file..".lua",__GV__,10,"Red")
		return false
	end
	return true
end

function g.script_load_check(_var,_file)
	if _var == nil then
		g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nYou must re-install Gee-Skid. ".._file..".lua is corrupt.",__GV__,10,"Red")
		return false
	elseif _var.ver_text ~= __GV__ then
		g.N_P(3,"Oh noes!\nGee-Skid loading cancelled.\nYou must re-install Gee-Skid. ".._file..".lua version doesn't match.",__GV__,10,"Red")
		return false
	end
	return true
end


print("--- "..__GV__..os.date("   %Y-%m-%d %H:%M:%S ---"))

if not g.script_file_check("API List") then	menu.exit() return else
	g.var.feat_loading_str = "API List.lua"
	API = require("GeeSkid_v2/Lua Library/API List")
	if not g.script_load_check(API,"API List") then menu.exit() return	end
	g.print_load_info("API List.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Ped Data") then	menu.exit() return else
	g.var.feat_loading_str = "Ped Data.lua"
	ped_models = require("GeeSkid_v2/Lua Library/Ped Data")
	if not g.script_load_check(ped_models,"Ped Data") then	menu.exit() return end
	g.print_load_info("Ped Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Oh No GTA Updated") then menu.exit() return else
	g.var.feat_loading_str = "Oh No GTA Updated.lua"
	glbls = require("GeeSkid_v2/Lua Library/Oh No GTA Updated")
	if not g.script_load_check(glbls,"Oh No GTA Updated") then menu.exit() return end
	g.print_load_info("Oh No GTA Updated.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Vehicle Data") then	menu.exit() return else
	g.var.feat_loading_str = "Vehicle Data.lua"
	veh_stuff = require("GeeSkid_v2/Lua Library/Vehicle Data")
	if not g.script_load_check(veh_stuff,"Vehicle Data") then menu.exit() return end
	g.print_load_info("Vehicle Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Inputs Data") then menu.exit() return else
	g.var.feat_loading_str = "API List.lua"
	inputs = require("GeeSkid_v2/Lua Library/Inputs Data")
	if not g.script_load_check(inputs,"Inputs Data") then menu.exit() return end
	g.print_load_info("Inputs Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Natives") then menu.exit() return else
	g.var.feat_loading_str = "Natives.lua"
	ntv = require("GeeSkid_v2/Lua Library/Natives")
	if not g.script_load_check(ntv,"Natives") then menu.exit() return end
	g.print_load_info("Natives.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
if not g.script_file_check("Interior Data") then menu.exit() return else
	g.var.feat_loading_str = "Interior Data.lua"
	intrr = require("GeeSkid_v2/Lua Library/Interior Data")
	if not g.script_load_check(intrr,"Interior Data") then menu.exit() return end
	g.print_load_info("Interior Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
if not g.script_file_check("Modder Data") then menu.exit() return else
	g.var.feat_loading_str = "Modder Data.lua"
	mddrs = require("GeeSkid_v2/Lua Library/Modder Data")
	if not g.script_load_check(mddrs,"Modder Data") then menu.exit() return end
	g.print_load_info("Modder Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
if not g.script_file_check("Weapon Data") then menu.exit() return else
	g.var.feat_loading_str = "Weapon Data.lua"
	weap_info = require("GeeSkid_v2/Lua Library/Weapon Data")
	if not g.script_load_check(weap_info,"Weapon Data") then menu.exit() return end
	g.print_load_info("Weapon Data.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
if not g.script_file_check("GTA v3 List") then menu.exit() return else
	g.var.feat_loading_str = "GTA v3 List.lua"
	tp_pos = require("GeeSkid_v2/Lua Library/GTA v3 List")
	if not g.script_load_check(weap_info,"GTA v3 List") then menu.exit() return end
	g.print_load_info("GTA v3 List.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
if not g.script_file_check("Functions") then menu.exit() return else
	g.var.feat_loading_str = "Functions.lua"
	funcs = require("GeeSkid_v2/Lua Library/Functions")
	if not g.script_load_check(funcs,"Functions") then menu.exit() return end
	g.print_load_info("Functions.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

if not g.script_file_check("Player Info") then menu.exit() return else
	g.var.feat_loading_str = "Player Info.lua"
	PID_INFO = require("GeeSkid_v2/Lua Library/Player Info")
	if not g.script_load_check(PID_INFO,"Player Info") then menu.exit() return end
	g.print_load_info("Player Info.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
g.tbl.PID_INFO = PID_INFO.run(g,API,glbls,ntv,intrr,funcs,mddrs,mth)

if not g.script_file_check("Paintjobs") then menu.exit() return else
	g.var.feat_loading_str = "Paintjobs.lua"
	paints = require("GeeSkid_v2/Lua Library/Paintjobs")
	if not g.script_load_check(paints,"Paintjobs") then menu.exit() return end
	g.print_load_info("Paintjobs.lua",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end

g.var.feat_loading_str = "Translations"
funcs.doo.check_create_dir(g.paths._lang)
local lang_str_tbl = {"English"} -- the translation file for english isnt actually used
lang["English"]={}
if g.paths._lang then
	local all_langs = utils.get_all_files_in_directory(g.paths._lang, "lua")
	for k,v in pairs(all_langs) do
		local temp =  require("GeeSkid_v2/Lua Library/Translation/"..string.sub(v,1,#v-4))
		if temp and temp.NAME and temp.LIST then
			if temp.NAME ~= "English" then
				if lang[temp.NAME] then
					g.N_P(3,"Duplicate translation language found.\n"..temp.NAME,__GV__,4,"Yellow")
				else
					g.print_load_info(temp.NAME,(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
					lang[temp.NAME]=temp.LIST
					lang_str_tbl[#lang_str_tbl+1]=temp.NAME
				end
			end
		else
			g.N_P(3,"Bad translation file.\n"..v,__GV__,4,"Yellow")
		end
	end
end


funcs.doo.check_create_dir(g.paths._user)
funcs.doo.check_create_file(g.paths._user.."Selected Translation.txt","English")
local file = io.open(g.paths._user.."Selected Translation.txt", "r")
if file then
	for line in file:lines() do
		if lang[line] then
			selected_lang = line
			break
		end
	end
	file:close()
end
g.print_load_info(selected_lang.." selected",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Main Parents"
g.tbl.paints2 = {}
for k,v in pairs (paints) do
	if type(v) == "table" then
		g.tbl.paints2[#g.tbl.paints2+1]=k
	end
end
table.sort(g.tbl.paints2, function(a, b) return a:lower() < b:lower()  end)

g.tbl.S_L_FEAT = {}
g.tbl.S_L_NAME = {}

function funcs.add_to_S_L(_feat,_str)
	g.tbl.S_L_FEAT[_str]=_feat
	g.tbl.S_L_NAME[#g.tbl.S_L_NAME+1]=_str
end

function funcs.set_feat_i_f(_feat,_min,_max,_mod,_val,_str)
	_feat.min = _min
	_feat.max = _max
	_feat.mod = _mod
	_feat.value = _val
	if _str then
		funcs.add_to_S_L(_feat,_str)
	end
end




function funcs.is.GS_loaded()
	return g.var.GS_has_loaded
end

function funcs.get.text_input(_title,_default,_max,_type)
	local status,str=1
	g.var.GS_feature_type_input=true
	while status == 1 do
		status, str = input.get(_title, _default, _max, _type)
		YIELD(0)
	end
	g.var.GS_feature_type_input=false
	funcs.is.vk_key_down_with_delay("RETURN")
	if str == "" or str == " " then
		return 2,str
	end
	return status,str
end

function funcs.is.feature_keys_down(_key_sett,_val1,_val2,_val3)
	if not g.var.GS_feature_type_input and funcs.is.GW_mouse_right(g.feat.gw_main.on) and not ntv.is.chat_active() then
		if _key_sett.value == 0 then
			if funcs.is.vk_key_down(inputs.vk_list[_val1.value+1]) then
				return true
			end
		elseif _key_sett.value == 1 then
			if funcs.is.vk_key_down(inputs.vk_list[_val1.value+1]) and funcs.is.vk_key_down(inputs.vk_list[_val2.value+1]) then
				return true
			end
		elseif funcs.is.vk_key_down(inputs.vk_list[_val1.value+1]) and funcs.is.vk_key_down(inputs.vk_list[_val2.value+1]) and funcs.is.vk_key_down(inputs.vk_list[_val3.value+1]) then
			return true
		end
	end
	return false
end


function funcs.doo.capture_key_pressed(_num,_str)
	local time = TIME_MS() + 10000
	local key1,key2,key3 = -1,-1,-1
	local stop=false
	local timer
	g.var.GS_feature_type_input=true
	while time > TIME_MS() and not stop do
		YIELD(0)
		timer = funcs.get.round_num((time - TIME_MS())/1000)
		timer=tostring(timer)
		ui.draw_rect(0.5, 0.5, 1.0,1.0, 0, 0, 0, 155)
		funcs.doo.overlay(timer,255,255,255,255,.75,0,.5,.3)
		if funcs.is.vk_key_down("ESCAPE") then stop = true end
		if key1 == -1 then
			funcs.doo.overlay("".._str.." ",255,255,255,255,.75,0,.5,.5)
			for i=1,#inputs.vk_list-1 do
				if funcs.is.vk_key_down(inputs.vk_list[i]) then
					key1=i
					while funcs.is.vk_key_down(inputs.vk_list[i]) and time > TIME_MS() do
						ui.draw_rect(0.5, 0.5, 1.0,1.0, 0, 0, 0, 155)
						timer = funcs.get.round_num((time - TIME_MS())/1000)
						funcs.doo.overlay(timer,255,255,255,255,.75,0,.5,.3)
						funcs.doo.overlay("".._str.." "..inputs.vk_list[key1],255,255,255,255,.75,0,.5,.5)
						YIELD(0)
					end
					break
				end
			end
		end
		if _num > 1 and key1 ~= -1 and key2 == -1 and key3 == -1 then
			funcs.doo.overlay("".._str.." "..inputs.vk_list[key1].." ",255,255,255,255,.75,0,.5,.5)
			for i=1,#inputs.vk_list-1 do
				if funcs.is.vk_key_down(inputs.vk_list[i]) and i ~= key1 then
					key2=i
					while funcs.is.vk_key_down(inputs.vk_list[i]) and time > TIME_MS() do
						ui.draw_rect(0.5, 0.5, 1.0,1.0, 0, 0, 0, 155)
						timer = funcs.get.round_num((time - TIME_MS())/1000)
						funcs.doo.overlay(timer,255,255,255,255,.75,0,.5,.3)
						funcs.doo.overlay("".._str.." "..inputs.vk_list[key1].." "..inputs.vk_list[key2],255,255,255,255,.75,0,.5,.5)
						YIELD(0)
					end
					break
				end
			end
		end
		if _num == 3 and key1 ~= -1 and key2 ~= -1 and key3 == -1 then
			funcs.doo.overlay("".._str.." "..inputs.vk_list[key1].." "..inputs.vk_list[key2],255,255,255,255,.75,0,.5,.5)
			for i=1,#inputs.vk_list-1 do
				if funcs.is.vk_key_down(inputs.vk_list[i]) and i ~= key1 and i ~= key2 then
					key3=i
					while funcs.is.vk_key_down(inputs.vk_list[i]) and time > TIME_MS() do
						ui.draw_rect(0.5, 0.5, 1.0,1.0, 0, 0, 0, 155)
						timer = funcs.get.round_num((time - TIME_MS())/1000)
						funcs.doo.overlay(timer,255,255,255,255,.75,0,.5,.3)
						funcs.doo.overlay("".._str.." "..inputs.vk_list[key1].." "..inputs.vk_list[key2].." "..inputs.vk_list[key3],255,255,255,255,.75,0,.5,.5)
						YIELD(0)
					end
					break
				end
			end
		end
		if _num == 1 and key1 ~= -1 then
			stop=true
		elseif _num == 2 and key2 ~= -1 then
			stop=true
		elseif _num == 3 and key3 ~= -1 then
			stop=true
		end
	end
	g.var.GS_feature_type_input=false
	return key1,key2,key3
end

function funcs.doo.set_keybinds(_num,_str,_val1,_val2,_val3)
	funcs.is.vk_key_down_any(true)
	YIELD(200)
	local key1,key2,key3 = funcs.doo.capture_key_pressed(_num,_str)
	if _num == 1 then
		if key1 == -1 then
			funcs.N_P(2,"No input recorded.",funcs.ver_text,4,"Yellow")
		else
			_val1.value=key1-1
			funcs.N_P(2,_str.." set to: "..inputs.vk_list[_val1.value+1],funcs.ver_text,4,"Green")
			return true
		end
	elseif _num == 2 then
		if key1 == -1 or key2 == -1 then
			funcs.N_P(2,"No input recorded.",funcs.ver_text,4,"Yellow")
		else
			_val1.value=key1-1
			_val2.value=key2-1
			funcs.N_P(2,_str.." set to: "..inputs.vk_list[_val1.value+1].." "..inputs.vk_list[_val2.value+1],funcs.ver_text,4,"Green")
			return true
		end
	elseif _num == 3 then
		if key1 == -1 or key2 == -1 or key3 == -1 then
			funcs.N_P(2,"No input recorded.",funcs.ver_text,4,"Yellow")
		else
			_val1.value=key1-1
			_val2.value=key2-1
			_val3.value=key3-1
			funcs.N_P(2,_str.." set to: "..inputs.vk_list[_val1.value+1].." "..inputs.vk_list[_val2.value+1].." "..inputs.vk_list[_val3.value+1],funcs.ver_text,4,"Green")
			return true
		end
	end
	return false
end


g.var.GS_feature_type_input=false

g.prnt.gs_main = og_menu_add_feature("Gee-Skid", "parent", 0)
g.prnt.self = menu_add_feature("Self", "parent", g.prnt.gs_main.id)
	g.prnt.self_teleport = menu_add_feature("Teleports", "parent", g.prnt.self.id)
		g.prnt.self_teleport_plyrs = menu_add_feature("TP Players", "parent", g.prnt.self_teleport.id)
		g.prnt.self_teleport_seat = menu_add_feature("Auto-TP to seat in my veh", "parent", g.prnt.self_teleport.id)
		g.prnt.self_teleport_veh_out = menu_add_feature("TP out of vehicle", "parent", g.prnt.self_teleport.id)
		g.prnt.self_teleport_veh_in = menu_add_feature("TP into vehicle", "parent", g.prnt.self_teleport.id)
		g.prnt.self_teleport_veh_auto = menu_add_feature("Instant-enter vehicles", "parent", g.prnt.self_teleport.id)
		g.prnt.self_teleport_pickups = menu_add_feature("TP Pickups", "parent", g.prnt.self_teleport.id)
	g.prnt.self_weapons = menu_add_feature("Weapons", "parent", g.prnt.self.id)
		g.prnt.self_weapons_ge = menu_add_feature("Gee-Eye", "parent", g.prnt.self_weapons.id, function()
			g.tbl.ge.aim.frwd_foot_offst.hidden=g.tbl.ge.aim.fire_pos.value==1
			g.tbl.ge.aim.frwd_cam_offst.hidden=g.tbl.ge.aim.fire_pos.value==0
		end)
			g.prnt.self_weapons_ge_gf = menu_add_feature("Gee-Flare", "parent", g.prnt.self_weapons_ge.id)
		g.prnt.self_weapons_s_a_b = menu_add_feature("Special Aim-Bot", "parent", g.prnt.self_weapons.id)
		g.prnt.self_weapons_r_f = menu_add_feature("Rapid-Fire", "parent", g.prnt.self_weapons.id)
	g.prnt.self_veh = menu_add_feature("Vehicle", "parent", g.prnt.self.id)
		g.prnt.self_veh_pers = menu_add_feature("Personal Vehicle", "parent", g.prnt.self_veh.id)
		g.prnt.self_veh_last = menu_add_feature("Last Vehicle", "parent", g.prnt.self_veh.id)
		g.prnt.self_veh_crrnt = menu_add_feature("Current Vehicle", "parent", g.prnt.self_veh.id)
			g.prnt.self_veh_crrnt_auto = menu_add_feature("Automatic", "parent", g.prnt.self_veh_crrnt.id)
			g.prnt.self_veh_crrnt_upgr = menu_add_feature("Upgrades", "parent", g.prnt.self_veh_crrnt.id)
				g.prnt.self_veh_crrnt_upgr_pnt = menu_add_feature("Paintjob", "parent", g.prnt.self_veh_crrnt_upgr.id)
					g.prnt.self_veh_crrnt_upgr_pnt_rgb = menu_add_feature("Custom RGB", "parent", g.prnt.self_veh_crrnt_upgr_pnt.id)
				g.prnt.self_veh_crrnt_upgr_lights = menu_add_feature("Headlights", "parent", g.prnt.self_veh_crrnt_upgr.id)
				g.prnt.self_veh_crrnt_upgr_neons = menu_add_feature("Neon Lights", "parent", g.prnt.self_veh_crrnt_upgr.id)
			g.prnt.self_veh_crrnt_drive = menu_add_feature("Gee-Drive", "parent", g.prnt.self_veh_crrnt.id)
				g.prnt.self_veh_crrnt_boost_stop = menu_add_feature("Boost/Stop", "parent", g.prnt.self_veh_crrnt_drive.id)
					g.prnt.self_veh_crrnt_boost_stop_dsply = menu_add_feature("Display Options", "parent", g.prnt.self_veh_crrnt_boost_stop.id)
			g.prnt.self_veh_crrnt_drift = menu_add_feature("Driftmod v1.1", "parent", g.prnt.self_veh_crrnt.id)
				g.prnt.self_veh_crrnt_drift_optns = menu_add_feature("DriftMod v1.1 Options", "parent", g.prnt.self_veh_crrnt_drift.id)
			g.prnt.self_veh_crrnt_info = menu_add_feature("Display vehicle info", "parent", g.prnt.self_veh_crrnt.id)
			g.prnt.self_veh_crrnt_plate = menu_add_feature("Custom plate", "parent", g.prnt.self_veh_crrnt.id)
			g.prnt.self_veh_crrnt_mk2=menu_add_feature("Mk2 inverted flight","parent",g.prnt.self_veh_crrnt.id)
	g.prnt.self_ped = menu_add_feature("Ped", "parent", g.prnt.self.id)
	g.prnt.gee_watch = menu_add_feature("Gee-Watch", "parent", g.prnt.self.id)
		g.prnt.optns_gw_b = menu_add_feature("Options", "parent", g.prnt.gee_watch.id)
			g.prnt.optns_gw_b_dsply = menu_add_feature("Display", "parent", g.prnt.optns_gw_b.id,function()
				g._W_B_settings_hide()
			end)
			g.prnt.optns_gw_b_dsply_legacy = menu_add_feature("Legacy Display", "parent", g.prnt.optns_gw_b_dsply.id,function()
				g._W_B_settings_hide()
			end)
			g.prnt.optns_gw_b_dsply_on_ent = menu_add_feature("On-Entity Display", "parent", g.prnt.optns_gw_b_dsply.id,function()
				g._W_B_settings_hide()
			end)
			g.prnt.optns_gw_b_htky = menu_add_feature("Hotkeys", "parent", g.prnt.optns_gw_b.id)
			g.prnt.optns_gw_black_hole_prnt = menu_add_feature("Black Hole", "parent", g.prnt.optns_gw_b.id)
	g.prnt.thermal_vision = menu_add_feature("Thermal Vision", "parent", g.prnt.self.id)
g.prnt.sssn = menu_add_feature("Session", "parent", g.prnt.gs_main.id)
	g.prnt.sssn_peds = menu_add_feature("Peds", "parent", g.prnt.sssn.id)
	g.prnt.sssn_plyrs = menu_add_feature("Players", "parent", g.prnt.sssn.id)
	g.prnt.sssn_vehs = menu_add_feature("Vehicles", "parent", g.prnt.sssn.id)
	g.prnt.sssn_kicks = menu_add_feature("Kicks", "parent", g.prnt.sssn.id)
g.prnt.spawn = menu_add_feature("Spawn Vehicle", "parent", g.prnt.gs_main.id)
g.prnt.spawn2t1 = menu_add_feature("Saved 2T1 Vehicle", "parent", g.prnt.gs_main.id)
g.prnt.utils = menu_add_feature("Utilities", "parent", g.prnt.gs_main.id)
	g.prnt.utils_info = menu_add_feature("Information", "parent", g.prnt.utils.id)
		g.prnt.utils_info_overlay = menu_add_feature("Player Overlay", "parent", g.prnt.utils_info.id)
		g.prnt.utils_info_esp_p = menu_add_feature("ESP", "parent", g.prnt.utils_info.id)
			g.prnt.utils_info_esp = menu_add_feature("Vehicle ESP","parent",g.prnt.utils_info_esp_p.id)
			g.prnt.utils_info_wp = menu_add_feature("Waypoint ESP","parent",g.prnt.utils_info_esp_p.id)
			g.prnt.utils_info_obj = menu_add_feature("Objective ESP","parent",g.prnt.utils_info_esp_p.id)
			g.prnt.utils_info_pckp = menu_add_feature("Pickup ESP","parent",g.prnt.utils_info_esp_p.id)
		g.prnt.utils_info_aim = menu_add_feature("Aim Display", "parent", g.prnt.utils_info.id)
		g.prnt.utils_info_ldrbrd = menu_add_feature("Leaderboard", "parent", g.prnt.utils_info.id)
		g.prnt.utils_info_los = menu_add_feature("Players facing me", "parent", g.prnt.utils_info.id)

		g.prnt.utils_info_radar = menu_add_feature("2T1 Radar v2.0","parent",g.prnt.utils_info.id)
		g.prnt.altitude = menu_add_feature("Altitude/Elevation", "parent", g.prnt.utils_info.id)
	g.prnt.utils_trffc = menu_add_feature("Traffic", "parent", g.prnt.utils.id)
	g.prnt.utils_prtx = menu_add_feature("Protex", "parent", g.prnt.utils.id)
		g.prnt.utils_prtx_veh_grf = menu_add_feature("Vehicle Grief", "parent", g.prnt.utils_prtx.id)
		g.prnt.utils_prtx_aim = menu_add_feature("Aim Protex", "parent", g.prnt.utils_prtx.id)
		g.prnt.utils_mod_dtx = menu_add_feature("Modder Detection", "parent", g.prnt.utils_prtx.id)
	g.prnt.utils_rtcle=menu_add_feature("Custom reticle", "parent",g.prnt.utils.id)
	g.prnt.utils_clear = menu_add_feature("Clear area", "parent", g.prnt.utils.id)
	g.prnt.utils_map_tp = menu_add_feature("Map Teleport","parent",g.prnt.utils.id, function()
		g.N_P(2,"Left-click to teleport. Right-click or Escape to exit. Shift or scroll to zoom.",__GV__,7,"Yellow")
	end)
	g.prnt.utils_time=menu_add_feature("Stopwatch/Race Timer","parent",g.prnt.utils.id)
g.prnt.optns = menu_add_feature("Options", "parent", g.prnt.gs_main.id)
	g.prnt.optns_plate = menu_add_feature("Repair/Upgrade plate","parent",g.prnt.optns.id, function()
		g.N_P(2,"When repairing or upgrading a vehicle the plate will change to what you select here.",__GV__,7,"Yellow")
	end)

g.o.prnt.gs_main = og_menu_add_player_feature("Gee-Skid", "parent", 0)
	g.o.prnt.tp = menu_add_player_feature("Teleports", "parent", g.o.prnt.gs_main.id)
	g.o.prnt.plyr = menu_add_player_feature("Player", "parent", g.o.prnt.gs_main.id, function()
		while not g.o._mod_toggle  do
			YIELD(0)
		end
		mddrs.str = {}
		mddrs.str_is_int = {}
		mddrs.list={}
		--thank you toph
		local flag = 1
		while flag < player.get_modder_flag_ends() do
			mddrs.list[flag]=player.get_modder_flag_text(flag)
			mddrs.str[#mddrs.str+1]=player.get_modder_flag_text(flag)
			mddrs.str_is_int[player.get_modder_flag_text(flag)]=flag
			flag = flag * 2
		end
		new_set_str_data(g.o._mod_toggle,mddrs.str)
	end)
		g.o.prnt.plyr_attacks = menu_add_player_feature("Attacks", "parent", g.o.prnt.plyr.id)
		g.o.prnt.plyr_trolls = menu_add_player_feature("Trolls", "parent", g.o.prnt.plyr.id)
	g.o.prnt.veh = menu_add_player_feature("Vehicle", "parent", g.o.prnt.gs_main.id)
		g.o.prnt.veh_attach=menu_add_player_feature("Attach To Me","parent",g.o.prnt.veh.id)
	g.o.prnt.spwn = menu_add_player_feature("Spawn Vehicle", "parent", g.o.prnt.gs_main.id)
		g.o.prnt.spwn_history = menu_add_player_feature("History", "parent", g.o.prnt.spwn.id)
	g.o.prnt.spawn2t1 = menu_add_player_feature("Saved 2T1 Vehicle", "parent", g.o.prnt.gs_main.id)
	g.o._veh_tp_check=menu_add_player_feature("Force check for position/vehicle if needed", "toggle", g.o.prnt.gs_main.id, function(f,pid)
		g.tbl.PID_INFO.tp_sett[pid+1] = f.on
	end)




g.print_load_info("Main parents",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Special Aim-Bot"
g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	while true do
		g.RES_W = (API.gfx.get_w()/3840) --for me this is 1
		g.RES_H = (API.gfx.get_h()/2160) --this also
		g.RES = (g.RES_W+g.RES_H)*0.5
		g.RES_TOTAL = API.gfx.get_w()*API.gfx.get_h()
		g.RES_RATIO = API.gfx.get_w()/API.gfx.get_h()/(16/9) --this is 1 also
		YIELD(5000)
	end
end)

-----------------------------------------------------------------------------------------GEE-SKID
---------------------------------------------------------------------------------------------SELF
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g.tbl.reticle_files = utils.get_all_files_in_directory(g.paths._reticle,"png")
g.tbl.reticle_sprites = {}
for i=1,#g.tbl.reticle_files do
	g.tbl.reticle_sprites[i] = scriptdraw.register_sprite(g.paths._reticle..i..".png")
end

g.tbl.a_b ={}

function g.tbl.a_b.kosatka_show(prjctl)
	local ent,coords
	if funcs.is.ent(prjctl) then
		ent = prjctl
		coords = API.ent.get.coords(prjctl)
	elseif funcs.ME._in_veh() then
		ent=funcs.ME._veh()
		coords=funcs.ME._veh_crds()
	else
		ent=funcs.ME._ped()
		coords=funcs.ME._crds()
	end
	local all_peds=API.Ped.get.all()
	for i=1,#all_peds do
		if g.tbl.a_b.peds[all_peds[i]] ~= nil and g.tbl.a_b.peds[all_peds[i]].GOOD and not API.ent.is.dead(all_peds[i]) and funcs.is.in_grid(API.ent.get.coords(all_peds[i]),coords,1000) then
			if (API.Ped.is.in_veh(all_peds[i]) and ntv.is.ents_in_los(ent,API.Ped.is.in_veh(all_peds[i]),3,true)) or ntv.is.ents_in_los(ent,all_peds[i],3,true) then
				g.tbl.a_b.show_ped(all_peds[i])
			end
		end
	end
end

function g.tbl.a_b.kosatka_do(obj)
	local prjctl = g.tbl.a_b.get_prjctl2(true,obj)
	if funcs.is.ent(prjctl) then
		local trgt_crds_do=nil
		g.tbl.a_b.kosatka_cam=nil
		local aircrft_help = (funcs.ME._in_veh() and (API.strm.is.valid_helo(API.ent.get.model_hash(funcs.ME._veh())) or API.strm.is.valid_plane(API.ent.get.model_hash(funcs.ME._veh()))))
		local my_pos = funcs.ME._veh_crds()
		while funcs.is.ent(prjctl) and not funcs.is.vk_key_down(inputs.vk_list[g.tbl.a_b.speed_stop_key_k.value+1]) do
			g.tbl.a_b.kosatka_show(prjctl)
			if not ntv.cam.is.exist(g.tbl.a_b.kosatka_cam) then
				ntv.cam.doo.destroy_all()
				g.tbl.a_b.kosatka_cam = ntv.cam.doo.create_w_params("DEFAULT_SCRIPTED_CAMERA", funcs.vec(0,0,0),funcs.vec(0,0,0), 90.0, 1, 2)
				ntv.cam.doo.attach_to_ent(g.tbl.a_b.kosatka_cam, prjctl,funcs.vec(0,0,0),1)
				ntv.cam.set.active(g.tbl.a_b.kosatka_cam,1)
				ntv.cam.set.render_script(1, 0, 0, 0, 0)
			end
			if aircrft_help and g.tbl.a_b.aircrft_k.value == 2 then
				API.veh.set.forward_speed(funcs.ME._veh(),0)
			elseif aircrft_help and g.tbl.a_b.aircrft_k.value == 1 then
				if funcs.ME._veh_crds().z < my_pos.z then
					API.ent.force(funcs.ME._veh(), 3, 0,0,(my_pos.z-funcs.ME._veh_crds().z)*0.5, 0,0,0, true, true)
				end
			end
			API.ent.set.rotation(prjctl,API.cam.get.rot())
			trgt_crds_do = g.tbl.a_b.rot_to_dir(API.ent.get.coords(prjctl),API.cam.get.rot(),g.tbl.a_b.speed_k.value*50)
			trgt_crds_do = g.tbl.a_b.dir_to_pos(API.ent.get.coords(prjctl),trgt_crds_do)
			ntv.cam.set.rot(g.tbl.a_b.kosatka_cam,API.cam.get.rot(),2)
			if funcs.is.vk_key_down(inputs.vk_list[g.tbl.a_b.speed_up_key_k.value+1]) then
				API.ent.set.velocity(prjctl,trgt_crds_do*g.tbl.a_b.speed_up_k.value)
			elseif funcs.is.vk_key_down(inputs.vk_list[g.tbl.a_b.speed_dwn_key_k.value+1]) then
				API.ent.set.velocity(prjctl,trgt_crds_do*g.tbl.a_b.speed_dwn_k.value)
			else
				API.ent.set.velocity(prjctl,trgt_crds_do)
			end
			g.tbl.a_b.auto_sticky_do(false,prjctl,nil)
			ntv.map.lock_mini_pos(API.ent.get.coords(prjctl))
			ntv.cam.set.focus_pos(API.ent.get.coords(prjctl))
			YIELD(5)
		end
		if aircrft_help and funcs.ME._in_veh() then
			API.ent.force(funcs.ME._veh(), 3, 0,0,2, 0,0,0, true, true)
		end
		ntv.cam.set.render_script(0, 0, 0, 0, 0)
		ntv.cam.set.active(g.tbl.a_b.kosatka_cam,0)
		ntv.cam.doo.destroy_all()
	end
	ntv.cam.set.no_focus_pos()
	ntv.map.unlock_mini_pos()
end

function g.tbl.a_b.show_fov_box(veh_weap,alpha)
	if (veh_weap and g.tbl.a_b.fov_show_v.on) or (not veh_weap and g.tbl.a_b.fov_show.on) then
		local x_size,y_size,color
		if not veh_weap and g.tbl.a_b.fov_show.on then
			alpha = alpha or g.tbl.a_b.box_a.value
			x_size,y_size = g.tbl.a_b.fov_x.value, g.tbl.a_b.fov_y.value
			color = funcs.get.rgba_to_int(g.tbl.a_b.box_r.value,g.tbl.a_b.box_g.value,g.tbl.a_b.box_b.value,alpha)
		else
			alpha = alpha or g.tbl.a_b.box_a_v.value
			x_size,y_size = g.tbl.a_b.fov_x_v.value, g.tbl.a_b.fov_y_v.value
			color = funcs.get.rgba_to_int(g.tbl.a_b.box_r_v.value,g.tbl.a_b.box_g_v.value,g.tbl.a_b.box_b_v.value,alpha)
		end
		API.SD.draw_line(funcs.vec(-(x_size*.01),(y_size*.01)),funcs.vec((x_size*.01),(y_size*.01)), 1, color)
		API.SD.draw_line(funcs.vec((x_size*.01),(y_size*.01)),funcs.vec((x_size*.01),-(y_size*.01)), 1, color)
		API.SD.draw_line(funcs.vec((x_size*.01),-(y_size*.01)),funcs.vec(-(x_size*.01),-(y_size*.01)), 1, color)
		API.SD.draw_line(funcs.vec(-(x_size*.01),-(y_size*.01)),funcs.vec(-(x_size*.01),(y_size*.01)), 1,color)
	end
end

function g.tbl.a_b.show_fov_box2(veh_weap,alpha)
	local x_size,y_size,color
	if veh_weap then
		alpha = alpha or g.tbl.a_b.box_a_v.value
		x_size,y_size = g.tbl.a_b.fov_x_v.value, g.tbl.a_b.fov_y_v.value
		color = funcs.get.rgba_to_int(g.tbl.a_b.box_r_v.value,g.tbl.a_b.box_g_v.value,g.tbl.a_b.box_b_v.value,alpha)
	else
		alpha = alpha or g.tbl.a_b.box_a.value
		x_size,y_size = g.tbl.a_b.fov_x.value, g.tbl.a_b.fov_y.value
		color = funcs.get.rgba_to_int(g.tbl.a_b.box_r.value,g.tbl.a_b.box_g.value,g.tbl.a_b.box_b.value,alpha)
	end
	API.SD.draw_line(funcs.vec(-(x_size*.01),(y_size*.01)),funcs.vec((x_size*.01),(y_size*.01)), 1, color)
	API.SD.draw_line(funcs.vec((x_size*.01),(y_size*.01)),funcs.vec((x_size*.01),-(y_size*.01)), 1, color)
	API.SD.draw_line(funcs.vec((x_size*.01),-(y_size*.01)),funcs.vec(-(x_size*.01),-(y_size*.01)), 1, color)
	API.SD.draw_line(funcs.vec(-(x_size*.01),-(y_size*.01)),funcs.vec(-(x_size*.01),(y_size*.01)), 1,color)
end

function g.tbl.a_b.get_movement(trgt_crds_do,prjctl_crds_do,_val)
	local vec_to_trgt = funcs.get.vctr_to_pos3(trgt_crds_do,prjctl_crds_do)
	local new_pos = g.tbl.a_b.rot_to_dir(prjctl_crds_do,vec_to_trgt,69*_val)
	return g.tbl.a_b.dir_to_pos(prjctl_crds_do,new_pos),vec_to_trgt
end

function g.tbl.a_b.rot_to_dir(prjctl_crds_do,vec_to_trgt,dist)
	local new_pos = prjctl_crds_do
	local rot = vec_to_trgt
	rot:transformRotToDir()
	rot=rot	* dist
	new_pos = new_pos + rot
	return new_pos
end

function g.tbl.a_b.dir_to_pos(prjctl_crds_do,new_pos)
	return v3((prjctl_crds_do.x-new_pos.x)*-1,(prjctl_crds_do.y-new_pos.y)*-1,(prjctl_crds_do.z-new_pos.z)*-1)
end



g.tbl.a_b.bombs_table={
[0]=3298955569,
[1]=890925600,
[2]=602296248,
[3]=3604002190,
}

function g.tbl.a_b.get_veh_dmnsns2()
	local _min,_max = API.ent.get.dimensions(funcs.ME._veh())
	if _min ~= nil and _max ~= nil then
		return 2 + (_max.y+mth.abs(_min.y))/2
	end
	return 4
end

function g.tbl.a_b.get_pos_front2()
	if g.tbl.a_b.veh_weap then
		if g.tbl.a_b.weap_dir == "Turret" then
			return funcs.get.front_of_dir(funcs.ME._veh_crds(),API.cam.get.rot(),g.tbl.a_b.get_veh_dmnsns2())--g.tbl.a_b.weap_ofst)
		elseif g.tbl.a_b.weap_dir == "Down" then
			return funcs.ME._veh_crds()+funcs.vec(0,0,-2)
		end
		return funcs.get.front_of_dir(funcs.ME._veh_crds(),API.ent.get.rotation(funcs.ME._veh()),g.tbl.a_b.weap_ofst)
	end
	return funcs.get.front_of_dir(funcs.ME._crds(),API.cam.get.rot(),1.5)
end

function g.tbl.a_b.get_my_weap2()
	local weap_obj,weap_type,seek_type,weap_dir,weap_ofst,veh_weap=nil,nil,0,nil,0,false
	local my_ped_weap = funcs.ME._weap()
	if weap_info.hand.obj[my_ped_weap] ~= nil and g.tbl.a_b.wpn_trgt[my_ped_weap] ~= 0 then
		weap_obj = weap_info.hand.obj[my_ped_weap]
		weap_type = weap_info.hand.type[my_ped_weap]
		seek_type = g.tbl.a_b.wpn_trgt[my_ped_weap]
	elseif funcs.ME._in_veh() then
		local my_ped = funcs.ME._ped()
		local my_veh_weap = ntv.get.ped_veh_weap(my_ped)
		local my_veh = funcs.ME._veh()
		if g.tbl.a_b.veh_wpn.bomb.value ~=0 and veh_stuff.has_bombs[API.ent.get.model_hash(my_veh)] and g.tbl.a_b.bombs_table[API.veh.get.mod(my_veh, 9)] ~= nil and ntv.is.veh_bomb_open(my_veh) then
			veh_weap = true
			weap_obj = g.tbl.a_b.bombs_table[API.veh.get.mod(my_veh, 9)]
			weap_type = "Bomb"
			seek_type = g.tbl.a_b.veh_wpn.bomb.value
			weap_dir = "Down"
			weap_ofst = 0
		elseif weap_info.veh.obj[my_veh_weap] ~= nil and g.tbl.a_b.wpn_trgt[my_veh_weap] ~= 0 then
			veh_weap = true
			weap_obj = weap_info.veh.obj[my_veh_weap]
			weap_type = weap_info.veh.type[my_veh_weap]
			seek_type = g.tbl.a_b.wpn_trgt[my_veh_weap]
			weap_dir = weap_info.veh.dir[my_veh_weap]
			weap_ofst = weap_info.veh.ofst[my_veh_weap]
		elseif weap_info.veh.type[my_veh_weap] == "MG" and g.tbl.a_b.wpn_trgt[my_veh_weap] ~= 0 then
			veh_weap = true
			weap_type = "MG"
			seek_type = g.tbl.a_b.wpn_trgt[my_veh_weap]
		end
	end
	g.tbl.a_b.good = (weap_type ~= nil and seek_type ~= 0)
	g.tbl.a_b.weap_obj = weap_obj
	g.tbl.a_b.weap_type = weap_type
	g.tbl.a_b.seek_type = seek_type
	g.tbl.a_b.veh_weap = veh_weap
	g.tbl.a_b.weap_dir = weap_dir
	g.tbl.a_b.weap_ofst = weap_ofst
end

function g.tbl.a_b.auto_sticky_do(_bool,_ent,_target_coords)
	if (_bool or g.tbl.a_b.auto_sticky.on) and API.ent.get.model_hash(_ent)==3184763647 and not funcs.is.in_grid(API.ent.get.coords(_ent),funcs.ME._crds(),1.5) then
		if (API.ent.is.attached(_ent) or funcs.get.total_velocity(_ent) < 1) then
			controls.set_control_normal(0,47,1.0)
			YIELD(50)
		elseif _target_coords ~= nil and funcs.is.in_grid(API.ent.get.coords(_ent),_target_coords,1.5) then
			controls.set_control_normal(0,47,1.0)
			YIELD(50)
		end
	end
end

function g.tbl.a_b.homing_do(trgt_ent,trgt_ped,_val,obj)
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		if g.tbl.a_b.good_ents2(trgt_ent,trgt_ped) and g.tbl.a_b.peds[trgt_ped].SHOTS < g.tbl.a_b.max_shots.value then
			local trgt_ent_do = trgt_ent
			local trgt_ped_do = trgt_ped
			g.tbl.a_b.peds[trgt_ped_do].SHOTS = g.tbl.a_b.peds[trgt_ped_do].SHOTS + 1
			local prjctl_do=g.tbl.a_b.get_prjctl2(false,obj)
			if funcs.is.ent(prjctl_do) then
				g.tbl.a_b.prev_obj[prjctl_do]=true
				g.tbl.a_b.homing_guts_do(trgt_ent_do,trgt_ped_do,prjctl_do,API.ent.get.coords(prjctl_do))
				g.tbl.a_b.prev_obj[prjctl_do]=false
			end
			if not funcs.is.ent(trgt_ped_do) or API.ent.is.dead(trgt_ped_do) then
				g.tbl.a_b.peds[trgt_ped_do].SHOTS = 0
			else
				g.tbl.a_b.peds[trgt_ped_do].SHOTS = g.tbl.a_b.peds[trgt_ped_do].SHOTS - 1
			end
		end
	end, nil)
end

function g.tbl.a_b.hopeful_do(obj)
	g.tbl.a_b.hopeful_total=g.tbl.a_b.hopeful_total+1
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local prjctl_do=g.tbl.a_b.get_prjctl2(false,obj)
		local delay = g.tbl.a_b.hopeful_total
		if funcs.is.ent(prjctl_do) then
			g.tbl.a_b.prev_obj[prjctl_do]=true
			local trgt_ped_do,trgt_ent_do,trgt_crds_do,vec_to_trgt,all_peds = nil,nil,nil,nil,nil
			local time,_table = TIME_MS() + 10000
			local my_rot,start_pos = API.cam.get.rot(),API.ent.get.coords(prjctl_do)
			local stop,fake_pos=false
			local function get_target()
				if g.tbl.a_b.hopeful_flight.value == 0 then
					return true
				elseif g.tbl.a_b.hopeful_flight.value == 1 and funcs.get.dist_pospos_v3(start_pos,API.ent.get.coords(prjctl_do)) > g.tbl.a_b.hopeful_straight.value then
					return true
				elseif g.tbl.a_b.hopeful_flight.value == 2 and API.ent.get.coords(prjctl_do).z-start_pos.z > g.tbl.a_b.hopeful_javelin.value then
					return true
				end
				return false
			end
			if g.tbl.a_b.hopeful_flight.value ~= 0 then
				if g.tbl.a_b.veh_weap and g.tbl.a_b.weap_dir ~= "Turret" then
					fake_pos = funcs.get.front_of_dir(funcs.ME._veh_crds(),API.ent.get.rotation(funcs.ME._veh()),1000)
				else
					fake_pos = funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),1000)
				end
				API.ent.set.coords(prjctl_do,API.ent.get.coords(prjctl_do)+funcs.vec(0,0,0.5))
			end
			while funcs.is.ent(prjctl_do) and not g.tbl.a_b.good_ents2(trgt_ent_do,trgt_ped_do) and time > TIME_MS() do
				if g.tbl.a_b.hopeful_flight.value ~= 0 then
					if funcs.ntwrk.ask_quick(prjctl_do) then
						trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(fake_pos,API.ent.get.coords(prjctl_do),g.tbl.a_b.hopeful_speed.value)
						if g.tbl.a_b.hopeful_flight.value == 2 then
							trgt_crds_do=v3(trgt_crds_do.x*0.5,trgt_crds_do.y*0.5,50*g.tbl.a_b.hopeful_speed.value)
						end
						API.ent.set.rotation(prjctl_do,funcs.get.vctr_to_pos3(fake_pos,API.ent.get.coords(prjctl_do)))
						API.ent.set.velocity(prjctl_do,trgt_crds_do)
					end
				end
				if get_target() then
					all_peds,_table=API.Ped.get.all(),{}
					for i=1,#all_peds do
						if g.tbl.a_b.peds[all_peds[i]] ~= nil and g.tbl.a_b.peds[all_peds[i]].GOOD and g.tbl.a_b.peds[all_peds[i]].SHOTS < g.tbl.a_b.max_shots.value then
							funcs.doo.delay(delay)
							if g.tbl.a_b.peds[all_peds[i]] ~= nil and g.tbl.a_b.peds[all_peds[i]].GOOD and g.tbl.a_b.peds[all_peds[i]].SHOTS < g.tbl.a_b.max_shots.value then
								if not API.ent.is.dead(all_peds[i]) and funcs.is.in_grid(API.ent.get.coords(all_peds[i]),API.ent.get.coords(prjctl_do),1000) then
									if API.Ped.is.in_veh(all_peds[i]) and ntv.is.ents_in_los(prjctl_do,API.Ped.get.veh(all_peds[i]),3,true) then
										_table[#_table+1]={TRGT = API.Ped.get.veh(all_peds[i]),PED = all_peds[i]}
									elseif ntv.is.ents_in_los(prjctl_do,all_peds[i],3,true) then
										_table[#_table+1]={TRGT = all_peds[i],PED = all_peds[i]}
									end
								end
							end
						end
					end
					if #_table > 0 then
						table.sort(_table, function(a, b) return funcs.get.dist_pospos_v3(API.ent.get.coords(a.TRGT),API.ent.get.coords(prjctl_do)) <funcs.get.dist_pospos_v3(API.ent.get.coords(b.TRGT),API.ent.get.coords(prjctl_do))  end)
						if _table[1] ~= nil and  funcs.is.ent(prjctl_do) and funcs.is.ent(_table[1].TRGT) and funcs.is.ent(_table[1].PED) and ntv.is.ents_in_los(prjctl_do,_table[1].TRGT,3,true) then
							funcs.doo.delay(delay)
							if g.tbl.a_b.peds[_table[1].PED] ~= nil and g.tbl.a_b.peds[_table[1].PED].GOOD and g.tbl.a_b.peds[_table[1].PED].SHOTS < g.tbl.a_b.max_shots.value then
								trgt_ent_do=_table[1].TRGT
								trgt_ped_do=_table[1].PED
							end
						end
					end
				end
				YIELD(5)
			end
			YIELD(5)
			if funcs.is.ent(prjctl_do) then
				g.tbl.a_b.homing_guts_do(trgt_ent_do,trgt_ped_do,prjctl_do,API.ent.get.coords(prjctl_do))
			end
			g.tbl.a_b.prev_obj[prjctl_do]=false
		end
		g.tbl.a_b.hopeful_total=g.tbl.a_b.hopeful_total-1
	end, nil)
end

function g.tbl.a_b.homing_guts_do(trgt,trgt_ped,prjctl,start_crds)
	if funcs.is.ent(prjctl) and funcs.is.ent(trgt) and funcs.is.ent(trgt_ped)then
		local trgt_ent_do,trgt_ped_do,prjctl_do = trgt,trgt_ped,prjctl
		local prjctl_coords,ent_vel_pos
		local stop,current_trgt,speed_do,trgt_crds_do,vec_to_trgt = false,trgt_ped,g.tbl.a_b.speed.value
		local time,init_count = TIME_MS() + (g.tbl.a_b.max_guide.value*1000),0
		if g.tbl.a_b.home_type.value == 1 then
			speed_do=speed_do*1.5
			API.ent.set.coords(prjctl_do,API.ent.get.coords(trgt_ped)+funcs.vec(mth.rndm(-1,1),mth.rndm(-1,1),g.tbl.a_b.orb_height.value+1))
		end
		while funcs.is.ent(prjctl_do) and not stop and time > TIME_MS() do
			prjctl_coords = API.ent.get.coords(prjctl_do)
			ent_vel_pos = funcs.get.ent_vel_pos(prjctl_do,0.1)
			trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(API.ent.get.coords(current_trgt),prjctl_coords,speed_do)
			g.tbl.a_b.rmv_god(current_trgt,false)
			if funcs.ntwrk.ask_quick(prjctl_do) then
				if g.tbl.a_b.home_type.value == 0 and not funcs.is.in_grid_xy(prjctl_coords,API.ent.get.coords(current_trgt),7) then
					trgt_crds_do=trgt_crds_do+funcs.vec(0,0,1.5*g.tbl.a_b.hght_crv.value*speed_do)
					if g.tbl.a_b.hght_init.value > 0 and init_count < 10  and funcs.is.in_grid(prjctl_coords,start_crds,3) then
						trgt_crds_do=v3(trgt_crds_do.x*0.5,trgt_crds_do.y*0.5,10*g.tbl.a_b.hght_init.value*0.666*speed_do)
						init_count=init_count+1
					end
				end
				API.ent.set.rotation(prjctl_do,funcs.get.vctr_to_pos(API.ent.get.coords(current_trgt),prjctl_do))
				API.ent.set.velocity(prjctl_do,trgt_crds_do)
			end
			g.tbl.a_b.auto_sticky_do(false,prjctl_do,API.ent.get.coords(current_trgt))
			if g.tbl.a_b.mrkr_show_line.on then
				ui.draw_line(API.ent.get.coords(prjctl_do), API.ent.get.coords(current_trgt),mth.rndm(0,255),mth.rndm(0,255),mth.rndm(0,255),255)
			end
			if g.tbl.a_b.mrkr_show_stay.on and funcs.is.ent(trgt_ped_do) then
				g.tbl.a_b.show_ped(trgt_ped_do,mth.flr((255*0.333)))
			end
			YIELD(5)
			if g.tbl.a_b.type_only_veh.on then
				if funcs.is.veh(trgt_ent_do) then
					current_trgt=trgt_ent_do
				else
					stop=true
				end
			else
				if funcs.is.ent(trgt_ped_do) then	current_trgt=trgt_ped_do
				elseif funcs.is.ent(trgt_ent_do) then current_trgt=trgt_ent_do
				else stop=true
				end
			end
		end
		if ent_vel_pos and g.tbl.a_b.add_orbital.on then
			funcs.doo.orb_explo_ptfx_n_audio(ent_vel_pos,funcs.ME._ped())
		end
		if ent_vel_pos and g.tbl.a_b.add_blackhole.on then
			local time = TIME_MS()+7000
			local all_veh,temp_pos,all_peds,all_obj,pos,switch
			local range = 50
			local speed = 0.25
			local exclude = {}
			local movement_type = g.tbl.a_b.add_blackhole.value
			while time > TIME_MS() do
				all_veh = API.veh.get.all()
				exclude[funcs.ME._veh()]=true
				exclude[API.plyr.pers_veh()]=true
				switch = not switch
				pos = switch and ent_vel_pos or funcs.is.ent(trgt_ped_do) and API.ent.get.coords(trgt_ped_do) or	funcs.is.ent(trgt_ent_do) and API.ent.get.coords(trgt_ent_do) or pos or ent_vel_pos
				speed = switch and 0.3 or 0.2
				speed = movement_type == 0 and speed * 3 or speed
				for k,v in pairs(all_veh) do
					if not exclude[v] then
						temp_pos = API.ent.get.coords(v)
						if funcs.is.in_grid_xy(pos,temp_pos,range) then
							dist = temp_pos:magnitude(pos)
							if dist <= range and funcs.ntwrk.ask_quick(v) then
								funcs.doo.id_migrate(v,0)
								trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(pos,temp_pos,(range-dist)/range*0.25*speed)
								if movement_type == 0 then
									API.ent.set.velocity(v,trgt_crds_do)
								else
									entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
								end
							end
						end
					end
				end
				YIELD(0)
				all_peds = API.Ped.get.all()
				for k,v in pairs(all_peds) do
					if not exclude[v] and not API.Ped.is.plyr(v) then
						temp_pos = API.ent.get.coords(v)
						if funcs.is.in_grid_xy(pos,temp_pos,range) then
							dist = temp_pos:magnitude(pos)
							if dist <= range and funcs.ntwrk.ask_quick(v) then
								funcs.doo.id_migrate(v,0)
								trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(pos,temp_pos,(range-dist)/range*0.25*speed)
								if movement_type == 0 then
									API.ent.set.velocity(v,trgt_crds_do)
								else
									entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
								end
							end
						end
					end
				end
				YIELD(0)
				all_obj = object.get_all_objects()
				for k,v in pairs(all_obj) do
					temp_pos = API.ent.get.coords(v)
					if funcs.is.in_grid_xy(pos,temp_pos,range) then
						dist = temp_pos:magnitude(pos)
						if dist <= range and funcs.ntwrk.ask_quick(v) then
							funcs.doo.id_migrate(v,0)
							trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(pos,temp_pos,(range-dist)/range*0.25*speed)
							if movement_type == 0 then
								API.ent.set.velocity(v,trgt_crds_do)
							else
								entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
							end
						end
					end
				end
				YIELD(0)
			end
		end
	end
end

function g.tbl.a_b.get_mg_ofst()
	local mg_ofst=v3(0,0,0)
	if weap_info.veh.mg_pitch_ofst[API.ent.get.model_hash(funcs.ME._veh())] ~= nil then
		mg_ofst.x=weap_info.veh.mg_pitch_ofst[API.ent.get.model_hash(funcs.ME._veh())]
	end
	if g.tbl.a_b.mg_trgt_type.value ~= 0 then
		local heading = mth.rad((g.tbl.a_b.mg_rot - 180) * -1)
		if g.tbl.a_b.mg_trgt_type.value == 1 then
			mg_ofst.x = mg_ofst.x + (mth.sin(heading) * -g.tbl.a_b.mg_trgt_height.value)
			mg_ofst.z = mg_ofst.z + (mth.cos(heading) * -g.tbl.a_b.mg_trgt_width.value)
		else
			mg_ofst.x = mg_ofst.x + (mth.sin(heading) * -g.tbl.a_b.mg_height)
			mg_ofst.z = mg_ofst.z + (mth.cos(heading) * -g.tbl.a_b.mg_width)
		end
		if g.tbl.a_b.mg_rot >= 360 then
			g.tbl.a_b.mg_rot = g.tbl.a_b.mg_rot - 360
		else
			g.tbl.a_b.mg_rot=g.tbl.a_b.mg_rot+g.tbl.a_b.mg_trgt_speed.value
		end
		if g.tbl.a_b.mg_trgt_type.value == 2 then
			if g.tbl.a_b.mg_spiral >= 360 then
				g.tbl.a_b.mg_spiral = g.tbl.a_b.mg_spiral - 360
			else
				g.tbl.a_b.mg_spiral=g.tbl.a_b.mg_spiral+(g.tbl.a_b.mg_trgt_speed.value+mth.rndm(1,2))
			end
			g.tbl.a_b.mg_height=g.tbl.a_b.mg_spiral/360*g.tbl.a_b.mg_trgt_height.value
			g.tbl.a_b.mg_width=g.tbl.a_b.mg_spiral/360*g.tbl.a_b.mg_trgt_width.value
		end
	end
	return mg_ofst
end

function g.tbl.a_b.rmv_god(_ent,_bool)
	local function chk_rmv(ent)
		if API.ent.get.god(ent) and funcs.ntwrk.ask_quick(ent) then
			API.ent.set.god(ent,false)
		end
	end
	if (g.tbl.a_b.god.on or _bool) and funcs.is.ent(_ent) then
		if (API.ent.is.ped(_ent) and API.Ped.is.in_veh(_ent)) or API.ent.is.veh(_ent) then
			local veh
			if API.ent.is.veh(_ent) then veh = _ent else veh = API.Ped.get.veh(_ent) end
			chk_rmv(veh)
			for i=1,funcs.get.veh_seats(veh) do
				if funcs.is.ent(API.veh.get.ped_in_seat(veh, i-2)) and not API.Ped.is.plyr(API.veh.get.ped_in_seat(veh, i-2)) then
					chk_rmv(API.veh.get.ped_in_seat(veh, i-2))
				end
			end
		elseif API.ent.is.ped(_ent) and not API.Ped.is.plyr(_ent) then
			chk_rmv(_ent)
		end
	end
end

function g.tbl.a_b.show_ped(_ped,alpha)
	local screen_pos = funcs.get.screen_pos_3d(API.ent.get.coords(_ped))
	if screen_pos then
		g.tbl.a_b.show_that_marker2(screen_pos,alpha)
		if g.tbl.a_b.peds[_ped] ~= nil then
			g.tbl.a_b.show_that_name2(g.tbl.a_b.peds[_ped].PED,screen_pos,g.tbl.a_b.peds[_ped].NAME,alpha)
		end
	end
end

function g.tbl.a_b.show_that_name2(ent,pos,name,alpha)
	if g.tbl.a_b.show_name.on then
		alpha = alpha or 255
		pos.x=pos.x*g.tbl.a_b.name_x_flag
		pos.x=pos.x+g.tbl.a_b.name_x.value
		pos.y=pos.y+g.tbl.a_b.name_y.value
		local _r,_g,_b = g.tbl.a_b.name_r.value,g.tbl.a_b.name_g.value,g.tbl.a_b.name_b.value
		if funcs.is.ent(ent) and API.ent.is.ped(ent) and API.Ped.is.plyr(ent) and glbls.team_rgb_int(API.plyr.get.plyr_from_ped(ent)) > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.get.plyr_from_ped(ent)+1,nil)
		end
		API.SD.draw_text(name,pos,pos,g.tbl.a_b.name_s.value*g.RES,funcs.get.rgba_to_int(_r,_g,_b,mth.flr(alpha/255*g.tbl.a_b.name_a.value)),g.tbl.a_b.name_flags,nil)
	end
end

function g.tbl.a_b.show_that_marker2(pos,alpha)
	if g.tbl.a_b.mrkr_show.on then
		if g.tbl.a_b.seek_type == 2 then
			alpha = alpha or g.tbl.a_b.mrkr_a_k.value
			if g.tbl.a_b.mrkr_rot_k.on then
				API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct_k.value],pos,1*g.tbl.a_b.mrkr_s_k.value*g.RES,g.tbl.a_b.mrkr_val_k, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r_k.value,g.tbl.a_b.mrkr_g_k.value,g.tbl.a_b.mrkr_b_k.value,alpha))
			else
				API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct_k.value],pos,1*g.tbl.a_b.mrkr_s_k.value*g.RES,0, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r_k.value,g.tbl.a_b.mrkr_g_k.value,g.tbl.a_b.mrkr_b_k.value,alpha))
			end
		else
			alpha = alpha or g.tbl.a_b.mrkr_a.value
			if g.tbl.a_b.mrkr_rot.on then
				API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct.value],pos,1*g.tbl.a_b.mrkr_s.value*g.RES,g.tbl.a_b.mrkr_val, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r.value,g.tbl.a_b.mrkr_g.value,g.tbl.a_b.mrkr_b.value,alpha))
			else
				API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct.value],pos,1*g.tbl.a_b.mrkr_s.value*g.RES,0, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r.value,g.tbl.a_b.mrkr_g.value,g.tbl.a_b.mrkr_b.value,alpha))
			end
		end
	end
end

function g.tbl.a_b.in_fov2(_ent)
	g.tbl.a_b.scrn_bool,g.tbl.a_b.scrn_pos = graphics.project_3d_coord(API.ent.get.coords(_ent))
	if g.tbl.a_b.scrn_bool then
		g.tbl.a_b.scrn_pos = funcs.get.screen_pos_math(g.tbl.a_b.scrn_pos)
	end
	if g.tbl.a_b.fov_limits.value == 0 then
		if g.tbl.a_b.veh_weap then
			return (g.tbl.a_b.scrn_bool and mth.abs(g.tbl.a_b.scrn_pos.x)<=(g.tbl.a_b.fov_x_v.value*0.01) and mth.abs(g.tbl.a_b.scrn_pos.y)<= (g.tbl.a_b.fov_y_v.value*0.01))
		end
		return (g.tbl.a_b.scrn_bool and mth.abs(g.tbl.a_b.scrn_pos.x)<=(g.tbl.a_b.fov_x.value*0.01) and mth.abs(g.tbl.a_b.scrn_pos.y)<= (g.tbl.a_b.fov_y.value*0.01))
	elseif g.tbl.a_b.fov_limits.value== 1 then
		return g.tbl.a_b.scrn_bool
	end
	return true
end

function g.tbl.a_b.in_los2(_ent)
	if g.tbl.a_b.use_los.value == 0 then
		if funcs.ME._in_veh() then
			return ntv.is.ents_in_los(funcs.ME._veh(),_ent,3,true)
		end
		return ntv.is.ents_in_los(funcs.ME._ped(),_ent,3,true)
	end
	return true
end

function g.tbl.a_b.invis2(_ent)
	if g.tbl.a_b.use_los.value == 0 then
		return API.ent.is.visible(_ent)
	end
	return true
end

function g.tbl.a_b.check_visibility(_ent)
	return (g.tbl.a_b.invis2(_ent) and g.tbl.a_b.in_fov2(_ent) and g.tbl.a_b.in_los2(_ent,nil))
end


function g.tbl.a_b.defaults()
	g.tbl.a_b.trgt_ent=nil
	g.tbl.a_b.trgt_name=""
	g.tbl.a_b.trgt_los=false
	g.tbl.a_b.trgt_vis=false
	g.tbl.a_b.good = false
	g.tbl.a_b.weap_obj = nil
	g.tbl.a_b.weap_type = nil
	g.tbl.a_b.seek_type = 0
	g.tbl.a_b.veh_weap = false
	g.tbl.a_b.weap_dir = nil
	g.tbl.a_b.weap_ofst = 0
	g.tbl.a_b.peds={}
	g.tbl.a_b.prev_obj = {}
	g.tbl.a_b.scrn_bool = false
	g.tbl.a_b.scrn_pos = funcs.vec(0,0)
	g.tbl.a_b.ped_name = ""
	g.tbl.a_b.mg_rot=0
	g.tbl.a_b.mg_spiral=0
	g.tbl.a_b.mg_width=g.tbl.a_b.mg_trgt_width.value
	g.tbl.a_b.mg_height=g.tbl.a_b.mg_trgt_height.value
	g.tbl.a_b.gta_lock=false
	g.tbl.a_b.prjctl=nil
	g.tbl.a_b.hopeful_total=0
end

function g.tbl.a_b.record_ped_info()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local all_peds,this_ped
		local function name_dead(_ped,_name)
			g.tbl.a_b.peds[_ped].NAME = _name
			if API.ent.is.dead(_ped) then
				g.tbl.a_b.peds[_ped].NAME = g.tbl.a_b.peds[_ped].NAME.." (DEAD)"
				g.tbl.a_b.peds[_ped].SHOTS = 0
			end
		end
		while g.tbl.a_b.feat.on do
			all_peds=API.Ped.get.all()
			for i=1,#all_peds do
				this_ped=all_peds[i]
				if g.tbl.a_b.peds[this_ped]== nil or this_ped == funcs.ME._ped() or API.ent.get.coords(this_ped).z < -49 then
					g.tbl.a_b.peds[this_ped]={PED=this_ped,NAME="",GOOD=false,SHOTS = 0}
				elseif API.Ped.is.plyr(this_ped) then
					local pid = API.plyr.get.plyr_from_ped(this_ped)
					name_dead(this_ped,funcs.get.pid_name(pid))
					if not g.tbl.a_b.type_plyr.on then
						g.tbl.a_b.peds[this_ped].GOOD=false
					else
						local frnd = API.plyr.is.friend(pid)
						local orgmc = funcs.is.same_orgmc(funcs.ME._id(),pid)
						local other  = (not frnd and not orgmc)
						local in_veh  = API.plyr.is.in_veh(pid)
						if (not in_veh and g.tbl.a_b.type_only_veh.on) or
							(frnd and g.tbl.a_b.type_frnd.value == 0) or
							(orgmc and g.tbl.a_b.type_org.value == 0) or
							(other and g.tbl.a_b.type_othr_plyr.value == 0) then
							g.tbl.a_b.peds[this_ped].GOOD = false
						else
							g.tbl.a_b.peds[this_ped].GOOD = true
						end
					end
				elseif not g.tbl.a_b.type_npc.on then
					g.tbl.a_b.peds[this_ped].GOOD=false
					g.tbl.a_b.peds[this_ped].NAME = ""
				elseif ped_models.rltshp_csa[API.Ped.get.rel_group_hash(this_ped)] then
					name_dead(this_ped,"COP")
					if g.tbl.a_b.type_mssn.value == 0 and (ped_models.rltshp_mssn[API.Ped.get.rel_group_hash(this_ped)] or ntv.is.ped_dislikes(this_ped,API.plyr.get.ped(API.plyr.my_id())) or ntv.is.ped_attack_ped(this_ped,API.plyr.get.ped(API.plyr.my_id()))) then
						g.tbl.a_b.peds[this_ped].GOOD=true
					else
						g.tbl.a_b.peds[this_ped].GOOD=(g.tbl.a_b.type_csa.value == 0)
					end
				elseif (ped_models.rltshp_mssn[API.Ped.get.rel_group_hash(this_ped)] or ntv.is.ped_dislikes(this_ped,API.plyr.get.ped(API.plyr.my_id())) or ntv.is.ped_attack_ped(this_ped,API.plyr.get.ped(API.plyr.my_id()))) then
					name_dead(this_ped,"ANGRY")
					if g.tbl.a_b.type_csa.value == 0  and ped_models.rltshp_csa[API.Ped.get.rel_group_hash(this_ped)] then
						g.tbl.a_b.peds[this_ped].GOOD=true
					else
						g.tbl.a_b.peds[this_ped].GOOD=(g.tbl.a_b.type_mssn.value == 0)
					end
				else
					name_dead(this_ped,"PED")
					g.tbl.a_b.peds[this_ped].GOOD=(g.tbl.a_b.type_othr_npc.value == 0)
				end
			end
			YIELD(100)
			for _,Ped in pairs(g.tbl.a_b.peds) do
				if Ped ~= nil and not funcs.is.ent(Ped.PED) then
					Ped=nil
				end
			end
		end
	end, nil)
end

function g.tbl.a_b.get_prjctl2(_bool,obj)
	local pos_front = g.tbl.a_b.get_pos_front2()
	local time,all_obj = TIME_MS() + 250
	while time > TIME_MS() do
		YIELD(0)
		if _bool then
			g.tbl.a_b.kosatka_show(nil)
		end
		all_obj=object.get_all_objects()
		for i=1,#all_obj do
			if not API.ent.is.attached(all_obj[i]) and API.ent.get.model_hash(all_obj[i])==obj and not g.tbl.a_b.prev_obj[all_obj[i]] and funcs.is.in_grid(API.ent.get.coords(all_obj[i]),pos_front,g.tbl.a_b.get_veh_dmnsns2()) then
				API.ent.set.max_speed(all_obj[i],45000)
				local blip = ui.add_blip_for_entity(all_obj[i])
				ntv.set.blip_sprite(blip,368)
				ntv.set.blip_scale(blip,0.75)
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local ent,blip,time,head,speed  = all_obj[i],blip, TIME_MS() + 10000
					while time > TIME_MS() and funcs.is.ent(ent) and ntv.is.blip_exist(blip) do
						speed = entity.get_entity_velocity(ent)
						head = mth.atan(speed.x, speed.y)* -180 / mth.pi
						ntv.set.blip_rot(blip,mth.ceil(head))
						YIELD(0)
					end
					if ntv.is.blip_exist(blip) then --every so often one object wont disappear after explosion
						ui.remove_blip(blip)
					end
				end)
				return all_obj[i]
			end
		end
	end
	return nil
end

function g.tbl.a_b.get_current_target()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local _table,_table2,this_ped,all_peds,time,_bool,screen_pos,this_ent,my_vec
		local function get_target()
			return (g.tbl.a_b.good and (funcs.ME._aim() or g.tbl.a_b.veh_weap))
		end
		local function get_gta_lock()
			this_ent = ntv.get.my_veh_lock_trgt()
			if funcs.is.ent(this_ent) then
				if API.ent.is.ped(this_ent) then
					if g.tbl.a_b.peds[this_ent] ~= nil and g.tbl.a_b.peds[this_ent].GOOD then
						g.tbl.a_b.trgt_ent = this_ent
						g.tbl.a_b.trgt_ped = this_ent
						g.tbl.a_b.gta_lock=true
						return true
					end
				elseif API.ent.is.veh(this_ent) then
					for i=1,funcs.get.veh_seats(this_ent) do
						this_ped = API.veh.get.ped_in_seat(this_ent, i-2)
						if funcs.is.ent(this_ped) and g.tbl.a_b.peds[this_ped] ~= nil and g.tbl.a_b.peds[this_ped].GOOD then
							g.tbl.a_b.trgt_ent = this_ent
							g.tbl.a_b.trgt_ped = this_ped
							g.tbl.a_b.gta_lock=true
							return true
						end
					end
				end
			end
			return false
		end
		local function get_gta_or_target()
			if g.tbl.a_b.seek_type == 1 and g.tbl.a_b.veh_trgt_lock.value == 1 and g.tbl.a_b.veh_weap and g.tbl.a_b.weap_type=="Missile" and get_gta_lock() then
				return false
			end
			g.tbl.a_b.gta_lock=false
			return get_target()
		end
		local function max_dist(_ent)
			if g.tbl.a_b.seek_type == 1 and g.tbl.a_b.weap_type == "MG" then
				return funcs.get.dist_pospos_v3(funcs.ME._veh_crds(),API.ent.get.coords(_ent)) <= (weap_info.veh.list_mg_dist[ntv.get.ped_veh_weap(funcs.ME._ped())] or 100)
			end
			return funcs.is.in_grid(API.ent.get.coords(_ent),funcs.ME._crds(),2000)
		end
		while g.tbl.a_b.feat.on do
			YIELD(0)
			if g.tbl.a_b.seek_type == 1 and g.tbl.a_b.veh_trgt_lock.value == 2 and g.tbl.a_b.veh_weap and g.tbl.a_b.weap_type=="Missile" then
				if not get_gta_lock() then
					g.tbl.a_b.trgt_ent = nil
					g.tbl.a_b.trgt_ped = nil
					g.tbl.a_b.gta_lock=false
				end
			elseif get_gta_or_target() then
				_table,_table2 = {},{}
				all_peds=API.Ped.get.all()
				for i=1,#all_peds do
					this_ped = all_peds[i]
					if g.tbl.a_b.peds[this_ped] ~= nil and g.tbl.a_b.peds[this_ped].GOOD and g.tbl.a_b.peds[all_peds[i]].SHOTS < g.tbl.a_b.max_shots.value and not API.ent.is.dead(this_ped) and  max_dist(this_ped) then
						if API.Ped.is.in_veh(this_ped) and g.tbl.a_b.check_visibility(API.Ped.get.veh(this_ped)) then
							if g.tbl.a_b.fov_limits.value== 2 then
								_table[#_table+1]={API.Ped.get.veh(this_ped),this_ped,g.tbl.a_b.scrn_pos,funcs.get.vctr_to_pos(API.ent.get.coords(API.Ped.get.veh(this_ped)),funcs.ME._ped())}
							else
								_table[#_table+1]={API.Ped.get.veh(this_ped),this_ped,g.tbl.a_b.scrn_pos}
							end
						elseif g.tbl.a_b.check_visibility(this_ped) then
							if g.tbl.a_b.fov_limits.value== 2 then
								_table[#_table+1]={this_ped,this_ped,g.tbl.a_b.scrn_pos,funcs.get.vctr_to_pos(API.ent.get.coords(this_ped),funcs.ME._ped())}
							else
								_table[#_table+1]={this_ped,this_ped,g.tbl.a_b.scrn_pos}
							end
						end
					end
				end
				if #_table == 0 then
					g.tbl.a_b.trgt_ent = nil
					g.tbl.a_b.trgt_ped = nil
				else
					if g.tbl.a_b.close_or_aim.value == 1  then
						table.sort(_table, function(a, b) return funcs.get.dist_me_ent_3d(a[1])<funcs.get.dist_me_ent_3d(b[1])  end)
					elseif g.tbl.a_b.fov_limits.value== 2 then
						for i=1,#_table do
							if _table[i][3]~= nil then
								_table2[#_table2+1]=_table[i]
							end
						end
						if #_table2 > 0 then
							table.sort(_table2, function(a, b) return mth.abs(a[3].x)+mth.abs(a[3].y) <  mth.abs(b[3].x)+mth.abs(b[3].y) end)
							_table={}
							for i=1,#_table2 do
								_table[i]=_table2[i]
							end
						else
							table.sort(_table, function(a, b) return funcs.get.v3_total_compare(API.cam.get.rot(),a[4])<funcs.get.v3_total_compare(API.cam.get.rot(),b[4])  end)
						end
					elseif g.tbl.a_b.close_or_aim.value == 0  then
						table.sort(_table, function(a, b) return mth.abs(a[3].x)+mth.abs(a[3].y) <  mth.abs(b[3].x)+mth.abs(b[3].y) end)
					end
					g.tbl.a_b.trgt_ent = _table[1][1]
					g.tbl.a_b.trgt_ped = _table[1][2]
				end
			end
			time = TIME_MS() + g.tbl.a_b.max_trgt_swtch.value
			while time > TIME_MS() and get_target() and g.tbl.a_b.good_ents(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped) and g.tbl.a_b.peds[g.tbl.a_b.trgt_ped] ~= nil and g.tbl.a_b.peds[g.tbl.a_b.trgt_ped].SHOTS < g.tbl.a_b.max_shots.value and g.tbl.a_b.check_visibility(g.tbl.a_b.trgt_ent) do
				YIELD(0)
			end
		end
	end, nil)
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		while g.tbl.a_b.feat.on do
			if g.tbl.a_b.seek_type == 1 and (g.tbl.a_b.good and (funcs.ME._aim() or g.tbl.a_b.veh_weap)) then
				if g.tbl.a_b.good_ents(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped) and g.tbl.a_b.peds[g.tbl.a_b.trgt_ped] ~= nil and g.tbl.a_b.peds[g.tbl.a_b.trgt_ped].SHOTS < g.tbl.a_b.max_shots.value then
					if (g.tbl.a_b.gta_lock or g.tbl.a_b.check_visibility(g.tbl.a_b.trgt_ent)) then
						g.tbl.a_b.show_ped(g.tbl.a_b.trgt_ped)
					end
				end
				if g.tbl.a_b.fov_limits.value == 0 then
					if (g.tbl.a_b.veh_weap and g.tbl.a_b.fov_show_v.on) or (not g.tbl.a_b.veh_weap and g.tbl.a_b.fov_show.on) then
						g.tbl.a_b.show_fov_box2(g.tbl.a_b.veh_weap)
					end
				end
			end
			YIELD(0)
		end
	end, nil)
end

function g.tbl.a_b.good_ents(_trgt,_t_ped)
	return (funcs.is.ent(_trgt) and funcs.is.ent(_t_ped) and not API.ent.is.dead(_t_ped))
end

function g.tbl.a_b.good_ents2(_trgt,_t_ped)
	return ((funcs.is.ent(_trgt) and not API.ent.is.dead(_trgt)) or (funcs.is.ent(_t_ped) and not API.ent.is.dead(_t_ped)))
end

g.tbl.a_b.feat=menu_add_feature("Enable Special Aim-Bot 2.0","toggle",g.prnt.self_weapons_s_a_b.id,function(f)
	local prjctl,trgt_ent,trgt_crds,all_peds,my_weap,time,cam_,veh_weap,front,name,pos_front,new_front,all_obj,_bool,screen_pos,trgt_ped
	local bad_obj,my_pos,aircrft_help,mg_dist,current_trgt
	g.tbl.a_b.defaults()
	if f.on then
		funcs.doo.yield_while_true(not g.var.GS_has_loaded,500)
		g.tbl.a_b.veh_wpn_set(nil)
		g.tbl.a_b.throw_wpn_set(nil)
		g.tbl.a_b.hand_wpn_set(nil)
		g.tbl.a_b.name_flags_do()
		g.tbl.a_b.get_current_target()
		g.tbl.a_b.record_ped_info()
	end
	while f.on do
		g.tbl.a_b.get_my_weap2()
		YIELD(0)
		if g.tbl.a_b.good then
			if g.tbl.a_b.seek_type == 2 then
				if funcs.ME._aim() or g.tbl.a_b.veh_weap then
					g.tbl.a_b.kosatka_show(nil)
				end
				if (funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) then
					g.tbl.a_b.kosatka_do(g.tbl.a_b.weap_obj)
				end
			elseif g.tbl.a_b.seek_type == 1 then
				if g.tbl.a_b.weap_type == "MG" then
					if (funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) then
						if funcs.is.ent(g.tbl.a_b.trgt_ped) and not API.ent.is.dead(g.tbl.a_b.trgt_ped) then
							trgt_ped = g.tbl.a_b.trgt_ped
							my_pos = funcs.ME._veh_crds()
							aircrft_help = (API.strm.is.valid_helo(API.ent.get.model_hash(funcs.ME._veh())) or API.strm.is.valid_plane(API.ent.get.model_hash(funcs.ME._veh())))
							while (funcs.ME._shoot() or (g.tbl.a_b.veh_weap and (funcs.is.key_active(330,1.0) or funcs.ME._aircrft_shoot()))) and funcs.is.ent(trgt_ped) and not API.ent.is.dead(trgt_ped) and funcs.ME._in_veh() do
								API.ent.set.rotation(funcs.ME._veh(),funcs.get.vctr_to_pos(API.ent.get.coords(trgt_ped),funcs.ME._veh())+g.tbl.a_b.get_mg_ofst())
								if aircrft_help and g.tbl.a_b.aircrft_mg.value == 2 then
									API.veh.set.forward_speed(funcs.ME._veh(),0)
								elseif aircrft_help and g.tbl.a_b.aircrft_mg.value == 1 then
									if funcs.ME._veh_crds().z < my_pos.z then
										API.ent.force(funcs.ME._veh(), 3, 0,0,(my_pos.z-funcs.ME._veh_crds().z)*0.5, 0,0,0, true, true)
									end
								end
								if g.tbl.a_b.keep.on and funcs.is.ent(trgt_ped) then
									g.tbl.a_b.show_ped(trgt_ped)
								else
									trgt_ped = g.tbl.a_b.trgt_ped
								end
								YIELD(5)
							end
							if aircrft_help then
								API.ent.force(funcs.ME._veh(), 3, 0,0,2, 0,0,0, true, true)
							end
						end
					end
				elseif (funcs.ME._aim() or funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) and g.tbl.a_b.good_ents(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped) then
					while (funcs.ME._aim() or funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) and g.tbl.a_b.good_ents(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped) do
						if funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot()) then
							if g.tbl.a_b.keep.on then
								trgt_ent =g.tbl.a_b.trgt_ent
								trgt_ped = g.tbl.a_b.trgt_ped
								while (funcs.ME._aim() or funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) and g.tbl.a_b.good_ents(trgt_ent,trgt_ped) do
									if funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot()) then
										g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
											if g.tbl.a_b.good_ents2(trgt_ent,trgt_ped) then
												local trgt_ent_do = trgt_ent
												local trgt_ped_do = trgt_ped
												g.tbl.a_b.peds[trgt_ped_do].SHOTS = 0
												local prjctl_do=g.tbl.a_b.get_prjctl2(false,obj)
												if funcs.is.ent(prjctl_do) then
													g.tbl.a_b.prev_obj[prjctl_do]=true
													g.tbl.a_b.homing_guts_do(trgt_ent_do,trgt_ped_do,prjctl_do,API.ent.get.coords(prjctl_do))
													g.tbl.a_b.prev_obj[prjctl_do]=false
												end
											end
										end, nil)

										g.tbl.a_b.homing_do(trgt_ent,trgt_ped,g.tbl.a_b.speed.value,g.tbl.a_b.weap_obj)
									end
									YIELD(0)
								end
							else
								g.tbl.a_b.homing_do(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped,g.tbl.a_b.speed.value,g.tbl.a_b.weap_obj)
							end
						end
						YIELD(0)
					end
				elseif not g.tbl.a_b.good_ents(g.tbl.a_b.trgt_ent,g.tbl.a_b.trgt_ped) and g.tbl.a_b.hopeful_feat.on and (funcs.ME._shoot() or (g.tbl.a_b.veh_weap and funcs.ME._aircrft_shoot())) then
					g.tbl.a_b.hopeful_do(g.tbl.a_b.weap_obj)
				end
			end
		end
	end
end)
funcs.add_to_S_L(g.tbl.a_b.feat,"g.tbl.a_b.feat")


g.tbl.a_b.weapons_prnt=menu_add_feature("Weapon Options","parent",g.prnt.self_weapons_s_a_b.id)

g.tbl.a_b.weapons_set_all=menu_add_feature("Change all to:","autoaction_value_str",g.tbl.a_b.weapons_prnt.id,function(f)
	g.tbl.a_b.set_all_weap_seek(f.value)
end)
new_set_str_data(g.tbl.a_b.weapons_set_all,{"None","Gee-Seek","Kosatka"})
g.tbl.a_b.weapons_set_all.value=1
funcs.add_to_S_L(g.tbl.a_b.weapons_set_all,"g.tbl.a_b.weapons_set_all")

g.tbl.a_b.wpn_trgt={}

g.tbl.a_b.hand_wpn_prnt=menu_add_feature("Handheld weapons","parent",g.tbl.a_b.weapons_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)

g.tbl.a_b.hand_wpn={}

function g.tbl.a_b.hand_wpn_set(_val)
	if _val ~= nil then
		for _,feat in pairs(g.tbl.a_b.hand_wpn) do
			feat.value=_val
		end
	end
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_rpg")] = g.tbl.a_b.hand_wpn.rpg.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_stinger")] = g.tbl.a_b.hand_wpn.rpg.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_compactlauncher")] = g.tbl.a_b.hand_wpn.cgl.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_grenadelauncher")] = g.tbl.a_b.hand_wpn.gl.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_hominglauncher")] = g.tbl.a_b.hand_wpn.hl.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_firework")] = g.tbl.a_b.hand_wpn.fl.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_emplauncher")] = g.tbl.a_b.hand_wpn.emp.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_flaregun")] = g.tbl.a_b.hand_wpn.fg.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_raypistol")] = g.tbl.a_b.hand_wpn.atom.value
end

g.tbl.a_b.hand_wpn_all=menu_add_feature("Change all to:","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(f.value)
end)
new_set_str_data(g.tbl.a_b.hand_wpn_all,{"None","Gee-Seek","Kosatka"})

g.tbl.a_b.hand_wpn.rpg=menu_add_feature("RPG","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.rpg,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.rpg,"g.tbl.a_b.hand_wpn.rpg")

g.tbl.a_b.hand_wpn.cgl=menu_add_feature("Compact Grenade Launcher","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.cgl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.cgl,"g.tbl.a_b.hand_wpn.cgl")

g.tbl.a_b.hand_wpn.gl=menu_add_feature("Grenade Launcher","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.gl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.gl,"g.tbl.a_b.hand_wpn.gl")

g.tbl.a_b.hand_wpn.hl=menu_add_feature("Homing Launcher","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.hl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.hl,"g.tbl.a_b.hand_wpn.hl")

g.tbl.a_b.hand_wpn.fl=menu_add_feature("Firework Launcher","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.fl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.fl,"g.tbl.a_b.hand_wpn.fl")

g.tbl.a_b.hand_wpn.emp=menu_add_feature("EMP Launcher","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.emp,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.emp,"g.tbl.a_b.hand_wpn.emp")

g.tbl.a_b.hand_wpn.fg=menu_add_feature("Flare gun","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.fg,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.fg,"g.tbl.a_b.hand_wpn.fg")

g.tbl.a_b.hand_wpn.atom=menu_add_feature("Up-N-Atomizer","autoaction_value_str",g.tbl.a_b.hand_wpn_prnt.id,function(f)
	g.tbl.a_b.hand_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.hand_wpn.atom,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.hand_wpn.atom,"g.tbl.a_b.hand_wpn.atom")


g.tbl.a_b.throw_wpn_prnt=menu_add_feature("Throwable weapons","parent",g.tbl.a_b.weapons_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)

g.tbl.a_b.throw_wpn={}

function g.tbl.a_b.throw_wpn_set(_val)
	if _val ~= nil then
		for _,feat in pairs(g.tbl.a_b.throw_wpn) do
			feat.value=_val
		end
	end
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_grenade")] = g.tbl.a_b.throw_wpn.grnd.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_bzgas")] = g.tbl.a_b.throw_wpn.bzg.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_molotov")] = g.tbl.a_b.throw_wpn.mltv.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_stickybomb")] = g.tbl.a_b.throw_wpn.stky.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_proxmine")] = g.tbl.a_b.throw_wpn.pxm.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_snowball")] = g.tbl.a_b.throw_wpn.snbl.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_pipebomb")] = g.tbl.a_b.throw_wpn.ppbm.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_ball")] = g.tbl.a_b.throw_wpn.ball.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_smokegrenade")] = g.tbl.a_b.throw_wpn.smkgnd.value
	g.tbl.a_b.wpn_trgt[API.get_hash_key("weapon_flare")] = g.tbl.a_b.throw_wpn.flare.value
end

g.tbl.a_b.auto_sticky=menu_add_feature("Auto-explode sticky bomb","toggle",g.tbl.a_b.throw_wpn_prnt.id)
funcs.add_to_S_L(g.tbl.a_b.auto_sticky,"g.tbl.a_b.auto_sticky")

g.tbl.a_b.throw_wpn_all=menu_add_feature("Change all to:","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(f.value)
end)
new_set_str_data(g.tbl.a_b.throw_wpn_all,{"None","Gee-Seek","Kosatka"})

g.tbl.a_b.throw_wpn.grnd=menu_add_feature("Grenade","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.grnd,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.grnd,"g.tbl.a_b.throw_wpn.grnd")

g.tbl.a_b.throw_wpn.bzg=menu_add_feature("BZ-Gas","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.bzg,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.bzg,"g.tbl.a_b.throw_wpn.bzg")

g.tbl.a_b.throw_wpn.mltv=menu_add_feature("Molotov","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.mltv,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.mltv,"g.tbl.a_b.throw_wpn.mltv")

g.tbl.a_b.throw_wpn.stky=menu_add_feature("Sticky Bomb","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.stky,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.stky,"g.tbl.a_b.throw_wpn.stky")

g.tbl.a_b.throw_wpn.pxm=menu_add_feature("Proximity Mine","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.pxm,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.pxm,"g.tbl.a_b.throw_wpn.pxm")

g.tbl.a_b.throw_wpn.snbl=menu_add_feature("Snowball","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.snbl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.snbl,"g.tbl.a_b.throw_wpn.snbl")

g.tbl.a_b.throw_wpn.ppbm=menu_add_feature("Pipebomb","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.ppbm,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.ppbm,"g.tbl.a_b.throw_wpn.ppbm")

g.tbl.a_b.throw_wpn.ball=menu_add_feature("Ball","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.ball,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.ball,"g.tbl.a_b.throw_wpn.ball")

g.tbl.a_b.throw_wpn.smkgnd=menu_add_feature("Smoke Grenade","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.smkgnd,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.smkgnd,"g.tbl.a_b.throw_wpn.smkgnd")

g.tbl.a_b.throw_wpn.flare=menu_add_feature("Flare","autoaction_value_str",g.tbl.a_b.throw_wpn_prnt.id,function(f)
	g.tbl.a_b.throw_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.throw_wpn.flare,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.throw_wpn.flare,"g.tbl.a_b.throw_wpn.flare")


g.tbl.a_b.veh_wpn_prnt=menu_add_feature("Vehicle weapons","parent",g.tbl.a_b.weapons_prnt.id)

g.tbl.a_b.veh_wpn={}
function g.tbl.a_b.veh_wpn_set(_val)
	if _val ~= nil then
		for _,feat in pairs(g.tbl.a_b.veh_wpn) do
			if feat.name == "Fixed machine guns" then
				if _val == 0 or _val == 1 then
					feat.value = _val
				else
					feat.value = 0
				end
			else
				feat.value=_val
			end
		end
	end
	for i=1,#weap_info.veh.list_prjctl do
		if weap_info.veh.type[weap_info.veh.list_prjctl[i]]=="Missile" then
			g.tbl.a_b.wpn_trgt[weap_info.veh.list_prjctl[i]]=g.tbl.a_b.veh_wpn.mssl.value
		elseif weap_info.veh.type[weap_info.veh.list_prjctl[i]]=="Grenade" then
			g.tbl.a_b.wpn_trgt[weap_info.veh.list_prjctl[i]]=g.tbl.a_b.veh_wpn.grnde.value
		elseif weap_info.veh.type[weap_info.veh.list_prjctl[i]]=="Mortar" then
			g.tbl.a_b.wpn_trgt[weap_info.veh.list_prjctl[i]]=g.tbl.a_b.veh_wpn.mrtr.value
		elseif weap_info.veh.type[weap_info.veh.list_prjctl[i]]=="Tank" then
			g.tbl.a_b.wpn_trgt[weap_info.veh.list_prjctl[i]]=g.tbl.a_b.veh_wpn.tank.value
		end
	end
	for i=1,#weap_info.veh.list_mg do
		g.tbl.a_b.wpn_trgt[weap_info.veh.list_mg[i]]=g.tbl.a_b.veh_wpn.mg.value
	end
end

g.tbl.a_b.veh_wpn_all=menu_add_feature("Change all to:","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(f.value)
end)
new_set_str_data(g.tbl.a_b.veh_wpn_all,{"None","Gee-Seek","Kosatka"})

g.tbl.a_b.veh_wpn.mssl=menu_add_feature("Missiles/Torpedos","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.mssl,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.mssl,"g.tbl.a_b.veh_wpn.mssl")

g.tbl.a_b.veh_wpn.grnde=menu_add_feature("Grenades","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.grnde,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.grnde,"g.tbl.a_b.veh_wpn.grnde")

g.tbl.a_b.veh_wpn.mrtr=menu_add_feature("Mortars","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.mrtr,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.mrtr,"g.tbl.a_b.veh_wpn.mrtr")

g.tbl.a_b.veh_wpn.tank=menu_add_feature("Tank cannons","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.tank,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.tank,"g.tbl.a_b.veh_wpn.tank")

g.tbl.a_b.veh_wpn.bomb=menu_add_feature("Aircraft bombs","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.bomb,{"None","Gee-Seek","Kosatka"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.bomb,"g.tbl.a_b.veh_wpn.bomb")

g.tbl.a_b.veh_wpn.mg=menu_add_feature("Fixed machine guns","autoaction_value_str",g.tbl.a_b.veh_wpn_prnt.id,function(f)
	g.tbl.a_b.veh_wpn_set(nil)
end)
new_set_str_data(g.tbl.a_b.veh_wpn.mg,{"None","Gee-Seek"})
funcs.add_to_S_L(g.tbl.a_b.veh_wpn.mg,"g.tbl.a_b.veh_wpn.mg")

function g.tbl.a_b.set_all_weap_seek(_val)
	g.tbl.a_b.hand_wpn_all.value=_val
	g.tbl.a_b.throw_wpn_all.value=_val
	g.tbl.a_b.veh_wpn_all.value=_val
	g.tbl.a_b.veh_wpn_set(_val)
	g.tbl.a_b.throw_wpn_set(_val)
	g.tbl.a_b.hand_wpn_set(_val)
end
g.tbl.a_b.set_all_weap_seek(1)

g.tbl.a_b.gee_seek_prnt=menu_add_feature("Gee-Seek Options","parent",g.prnt.self_weapons_s_a_b.id)

	g.tbl.a_b.veh_mg_prnt=menu_add_feature("Vehicle MG Options","parent",g.tbl.a_b.gee_seek_prnt.id)

		g.tbl.a_b.aircrft_mg=menu_add_feature("Plane/Helo assistance","action_value_str",g.tbl.a_b.veh_mg_prnt.id)
		new_set_str_data(g.tbl.a_b.aircrft_mg,{"No help","Maintain elevation","Hold position"})
		funcs.add_to_S_L(g.tbl.a_b.aircrft_mg,"g.tbl.a_b.aircrft_mg")

		g.tbl.a_b.mg_trgt_type=menu_add_feature("Aiming assistance","action_value_str",g.tbl.a_b.veh_mg_prnt.id)
		new_set_str_data(g.tbl.a_b.mg_trgt_type,{"No help","Draw a circle","Draw a spiral"})
		funcs.add_to_S_L(g.tbl.a_b.mg_trgt_type,"g.tbl.a_b.mg_trgt_type")

		g.tbl.a_b.mg_trgt_width=menu_add_feature("Circle/Spiral max width","action_value_f",g.tbl.a_b.veh_mg_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.mg_trgt_width,0.05,2,0.05,0.5,"g.tbl.a_b.mg_trgt_width")

		g.tbl.a_b.mg_trgt_height=menu_add_feature("Circle/Spiral max height","action_value_f",g.tbl.a_b.veh_mg_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.mg_trgt_height,0.05,2,0.05,0.5,"g.tbl.a_b.mg_trgt_height")

		g.tbl.a_b.mg_trgt_speed=menu_add_feature("Circle/Spiral speed","action_value_i",g.tbl.a_b.veh_mg_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.mg_trgt_speed,1,10,1,5,"g.tbl.a_b.mg_trgt_speed")

	g.tbl.a_b.hopeful_prnt=menu_add_feature("Hopeful shot","parent",g.tbl.a_b.gee_seek_prnt.id)

		g.tbl.a_b.hopeful_feat=menu_add_feature("Auto seek target you can't see","toggle",g.tbl.a_b.hopeful_prnt.id)
		funcs.add_to_S_L(g.tbl.a_b.hopeful_feat,"g.tbl.a_b.hopeful_feat")

		g.tbl.a_b.hopeful_flight=menu_add_feature("Trajectory while searching","action_value_str",g.tbl.a_b.hopeful_prnt.id)
		new_set_str_data(g.tbl.a_b.hopeful_flight,{"No change","Camera-Straight","Camera-Javelin",})
		funcs.add_to_S_L(g.tbl.a_b.hopeful_flight,"g.tbl.a_b.hopeful_flight")

		g.tbl.a_b.hopeful_straight=menu_add_feature("Straight minimum travel","action_value_i",g.tbl.a_b.hopeful_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.hopeful_straight,0,250,5,5,"g.tbl.a_b.hopeful_straight")

		g.tbl.a_b.hopeful_javelin=menu_add_feature("Javelin minimum height","action_value_i",g.tbl.a_b.hopeful_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.hopeful_javelin,0,250,5,100,"g.tbl.a_b.hopeful_javelin")

		g.tbl.a_b.hopeful_speed=menu_add_feature("Straight/Javelin speed","action_value_f",g.tbl.a_b.hopeful_prnt.id)
		funcs.set_feat_i_f(g.tbl.a_b.hopeful_speed,0.25,10,.25,3,"g.tbl.a_b.hopeful_speed")


	g.tbl.a_b.add_orbital=menu_add_feature("Add Orbital cannon explosion","toggle",g.tbl.a_b.gee_seek_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.add_orbital,"g.tbl.a_b.add_orbital")

	g.tbl.a_b.add_blackhole=menu_add_feature("Add Black Hole","value_str",g.tbl.a_b.gee_seek_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.add_blackhole,"g.tbl.a_b.add_blackhole")
	new_set_str_data(g.tbl.a_b.add_blackhole,{"Precise","Chaotic"})

	g.tbl.a_b.mrkr_show_line=menu_add_feature("Show trajectory on screen","toggle",g.tbl.a_b.gee_seek_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.mrkr_show_line,"g.tbl.a_b.mrkr_show_line")
	g.tbl.a_b.mrkr_show_line.on = true

	g.tbl.a_b.keep=menu_add_feature("Keep same target while shooting","toggle",g.tbl.a_b.gee_seek_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.keep,"g.tbl.a_b.keep")

	g.tbl.a_b.max_shots=menu_add_feature("Max shots per target","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.max_shots,1,25,1,3,"g.tbl.a_b.max_shots")

	g.tbl.a_b.god=menu_add_feature("Auto-remove target god","toggle",g.tbl.a_b.gee_seek_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.god,"g.tbl.a_b.god")

	g.tbl.a_b.veh_trgt_lock=menu_add_feature("GTA vehicle homing lock:","action_value_str",g.tbl.a_b.gee_seek_prnt.id)
	new_set_str_data(g.tbl.a_b.veh_trgt_lock,{"Ignore","Prefer","Exclusive"})
	funcs.add_to_S_L(g.tbl.a_b.veh_trgt_lock,"g.tbl.a_b.veh_trgt_lock")

	g.tbl.a_b.close_or_aim=menu_add_feature("Seek target closest to:","action_value_str",g.tbl.a_b.gee_seek_prnt.id)
	new_set_str_data(g.tbl.a_b.close_or_aim,{"Center of FOV","My position"})
	funcs.add_to_S_L(g.tbl.a_b.close_or_aim,"g.tbl.a_b.close_or_aim")

	g.tbl.a_b.fov_limits=menu_add_feature("Limit targets to:","action_value_str",g.tbl.a_b.gee_seek_prnt.id)
	new_set_str_data(g.tbl.a_b.fov_limits,{"Selected FOV limit","Anywhere on screen","Any direction"})
	funcs.add_to_S_L(g.tbl.a_b.fov_limits,"g.tbl.a_b.fov_limits")

	g.tbl.a_b.use_los=menu_add_feature("Line-of-sight to target:","action_value_str",g.tbl.a_b.gee_seek_prnt.id)
	new_set_str_data(g.tbl.a_b.use_los,{"Required","Not required"})
	funcs.add_to_S_L(g.tbl.a_b.use_los,"g.tbl.a_b.use_los")

	g.tbl.a_b.home_type=menu_add_feature("Seek type:","action_value_str",g.tbl.a_b.gee_seek_prnt.id)
	new_set_str_data(g.tbl.a_b.home_type,{"Homing","Orbital"})
	funcs.add_to_S_L(g.tbl.a_b.home_type,"g.tbl.a_b.home_type")

	g.tbl.a_b.max_guide=menu_add_feature("Seek time (Max seconds)","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.max_guide,1,30,1,10,"g.tbl.a_b.max_guide")

	g.tbl.a_b.speed=menu_add_feature("Seek flight speed","action_value_f",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.speed,0.25,10,.25,2,"g.tbl.a_b.speed")

	g.tbl.a_b.orb_height=menu_add_feature("Orbital height","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.orb_height,0,250,5,250,"g.tbl.a_b.orb_height")

	g.tbl.a_b.max_trgt_swtch=menu_add_feature("Target switch time (ms)","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.max_trgt_swtch,25,1000,25,150,"g.tbl.a_b.max_trgt_swtch")

	g.tbl.a_b.hght_init=menu_add_feature("Homing height curve - At launch","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.hght_init,0,10,1,1,"g.tbl.a_b.hght_init")

	g.tbl.a_b.hght_crv=menu_add_feature("Homing height curve - In flight","action_value_i",g.tbl.a_b.gee_seek_prnt.id)
	funcs.set_feat_i_f(g.tbl.a_b.hght_crv,0,10,1,1,"g.tbl.a_b.hght_crv")



	g.tbl.a_b.fov_prnt=menu_add_feature("Hand/Throwable Weapons FOV","parent",g.tbl.a_b.gee_seek_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
		g.tbl.a_b.hand_fov_hide()
	end)

	function g.tbl.a_b.hand_fov_hide()
		g.tbl.a_b.box_r.hidden=(not g.tbl.a_b.fov_show.on)
		g.tbl.a_b.box_g.hidden=(not g.tbl.a_b.fov_show.on)
		g.tbl.a_b.box_b.hidden=(not g.tbl.a_b.fov_show.on)
		g.tbl.a_b.box_a.hidden=(not g.tbl.a_b.fov_show.on)
	end

	g.tbl.a_b.fov_x=menu_add_feature("FOV X limit","autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.fov_x,1,100,1,18,"g.tbl.a_b.fov_x")

	g.tbl.a_b.fov_y=menu_add_feature("FOV Y limit","autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.fov_y,1,100,1,32,"g.tbl.a_b.fov_y")

	g.tbl.a_b.fov_show=menu_add_feature("Show FOV box when aiming","toggle",g.tbl.a_b.fov_prnt.id,function(f)
		g.tbl.a_b.test_fov_start(f.on,false)
		g.tbl.a_b.hand_fov_hide()
	end)
	funcs.add_to_S_L(g.tbl.a_b.fov_show,"g.tbl.a_b.fov_show")

	g.tbl.a_b.box_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.box_r,0,255,1,255,"g.tbl.a_b.box_r")

	g.tbl.a_b.box_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.box_g,0,255,1,0,"g.tbl.a_b.box_g")

	g.tbl.a_b.box_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.box_b,0,255,1,0,"g.tbl.a_b.box_b")

	g.tbl.a_b.box_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.a_b.fov_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show.on,false)
	end)
	funcs.set_feat_i_f(g.tbl.a_b.box_a,0,255,1,255,"g.tbl.a_b.box_a")

	g.tbl.a_b.test_fov_show=false
	g.tbl.a_b.test_fov_show_v=false
	g.tbl.a_b.test_fov=og_menu_add_feature("Show  fov box HIDDEN", "toggle", g.tbl.a_b.fov_prnt.id,function(f)
		if g.var.GS_has_loaded then
			local time = TIME_MS() + 3000
			local hand_time = TIME_MS()-1
			local veh_time = TIME_MS()-1
			while time > TIME_MS() do
				if g.tbl.a_b.test_fov_show then
					g.tbl.a_b.test_fov_show=false
					time = TIME_MS() + 3000
					hand_time = TIME_MS() + 3000
				elseif g.tbl.a_b.test_fov_show_v then
					g.tbl.a_b.test_fov_show_v=false
					time = TIME_MS() + 3000
					veh_time = TIME_MS() + 3000
				end
				if hand_time > TIME_MS() then
					g.tbl.a_b.show_fov_box(false,mth.flr((hand_time-TIME_MS()) /3000*g.tbl.a_b.box_a.value))
				end
				if veh_time > TIME_MS() then
					g.tbl.a_b.show_fov_box(true,mth.flr((veh_time-TIME_MS()) /3000*g.tbl.a_b.box_a_v.value))
				end
				YIELD(5)
			end
		end
		f.on=false
	end)
	g.tbl.a_b.test_fov.hidden=true
	g.tbl.a_b.fov_show.on=true
---------------------------------------------------------------------------------------------------------------------------
	g.tbl.a_b.fov_prnt_v=menu_add_feature("Vehicle Weapons FOV","parent",g.tbl.a_b.gee_seek_prnt.id,function()
		g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		g.tbl.a_b.veh_fov_hide()
	end)

		function g.tbl.a_b.test_fov_start(_bool,_veh)
			if _bool then
				if _veh then
					g.tbl.a_b.test_fov_show_v=true
				else
					g.tbl.a_b.test_fov_show=true
				end
				g.tbl.a_b.test_fov.on=true
			end
		end

		function g.tbl.a_b.veh_fov_hide()
			g.tbl.a_b.box_r_v.hidden=(not g.tbl.a_b.fov_show_v.on)
			g.tbl.a_b.box_g_v.hidden=(not g.tbl.a_b.fov_show_v.on)
			g.tbl.a_b.box_b_v.hidden=(not g.tbl.a_b.fov_show_v.on)
			g.tbl.a_b.box_a_v.hidden=(not g.tbl.a_b.fov_show_v.on)
		end

		g.tbl.a_b.fov_x_v=menu_add_feature("FOV X limit","autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.fov_x_v,1,100,1,45,"g.tbl.a_b.fov_x_v")

		g.tbl.a_b.fov_y_v=menu_add_feature("FOV Y limit","autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.fov_y_v,1,100,1,80,"g.tbl.a_b.fov_y_v")

		g.tbl.a_b.fov_show_v=menu_add_feature("Show FOV box for vehicle weapons","toggle",g.tbl.a_b.fov_prnt_v.id,function(f)
			g.tbl.a_b.test_fov_start(f.on,true)
			g.tbl.a_b.veh_fov_hide()
		end)
		funcs.add_to_S_L(g.tbl.a_b.fov_show_v,"g.tbl.a_b.fov_show_v")

		g.tbl.a_b.box_r_v = menu_add_feature("Red", "autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.box_r_v,0,255,1,255,"g.tbl.a_b.box_r_v")

		g.tbl.a_b.box_g_v = menu_add_feature("Green", "autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.box_g_v,0,255,1,0,"g.tbl.a_b.box_g_v")

		g.tbl.a_b.box_b_v = menu_add_feature("Blue", "autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.box_b_v,0,255,1,0,"g.tbl.a_b.box_b_v")

		g.tbl.a_b.box_a_v = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.a_b.fov_prnt_v.id,function()
			g.tbl.a_b.test_fov_start(g.tbl.a_b.fov_show_v.on,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.box_a_v,0,255,1,255,"g.tbl.a_b.box_a_v")
		g.tbl.a_b.fov_show_v.on=true
------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------Kosatka
------------------------------------------------------------------------------------------------------------------

g.tbl.a_b.flight_cntrls_k=menu_add_feature("Kosatka Options","parent",g.prnt.self_weapons_s_a_b.id,function()
	g.tbl.a_b.speed_up_set_k.name = "Set key for increase ("..inputs.vk_list[g.tbl.a_b.speed_up_key_k.value+1]..")"
	g.tbl.a_b.speed_dwn_set_k.name = "Set key for decrease ("..inputs.vk_list[g.tbl.a_b.speed_dwn_key_k.value+1]..")"
	g.tbl.a_b.speed_stop_set_k.name = "Set key for cancel ("..inputs.vk_list[g.tbl.a_b.speed_stop_key_k.value+1]..")"
end)

		g.tbl.a_b.aircrft_k=menu_add_feature("Plane/Helo help","action_value_str",g.tbl.a_b.flight_cntrls_k.id)
		new_set_str_data(g.tbl.a_b.aircrft_k,{"No help","Maintain elevation","Hold position"})
		funcs.add_to_S_L(g.tbl.a_b.aircrft_k,"g.tbl.a_b.aircrft_k")

		g.tbl.a_b.speed_k=menu_add_feature("Flight speed","action_value_f",g.tbl.a_b.flight_cntrls_k.id)
		funcs.set_feat_i_f(g.tbl.a_b.speed_k,0.1,10,.1,1,"g.tbl.a_b.speed_k")

		g.tbl.a_b.speed_up_k=menu_add_feature("Speed increase multiplier","action_value_f",g.tbl.a_b.flight_cntrls_k.id)
		funcs.set_feat_i_f(g.tbl.a_b.speed_up_k,1.25,10,.25,3,"g.tbl.a_b.speed_up_k")

		g.tbl.a_b.speed_dwn_k=menu_add_feature("Speed decrease multiplier","action_value_f",g.tbl.a_b.flight_cntrls_k.id)
		funcs.set_feat_i_f(g.tbl.a_b.speed_dwn_k,0.0,.9,.05,0.25,"g.tbl.a_b.speed_dwn_k")

		g.tbl.a_b.speed_up_key_k=og_menu_add_feature("Key1 for Speed increase","action_value_str",g.tbl.a_b.flight_cntrls_k.id)
		g.tbl.a_b.speed_up_key_k:set_str_data(inputs.vk_list)
		funcs.add_to_S_L(g.tbl.a_b.speed_up_key_k,"g.tbl.a_b.speed_up_key_k")
		g.tbl.a_b.speed_up_key_k.hidden=true
		g.tbl.a_b.speed_up_key_k.value=53

		g.tbl.a_b.speed_up_set_k=menu_add_feature("Set key for speed increase","action",g.tbl.a_b.flight_cntrls_k.id,function(f)
			funcs.doo.set_keybinds(1,"Speed increase",g.tbl.a_b.speed_up_key_k)
			f.name = "Set key for increase ("..inputs.vk_list[g.tbl.a_b.speed_up_key_k.value+1]..")"
		end)

		g.tbl.a_b.speed_dwn_key_k=og_menu_add_feature("Key1 for Speed decrease","action_value_str",g.tbl.a_b.flight_cntrls_k.id)
		g.tbl.a_b.speed_dwn_key_k:set_str_data(inputs.vk_list)
		funcs.add_to_S_L(g.tbl.a_b.speed_dwn_key_k,"g.tbl.a_b.speed_dwn_key_k")
		g.tbl.a_b.speed_dwn_key_k.hidden=true
		g.tbl.a_b.speed_dwn_key_k.value=55

		g.tbl.a_b.speed_dwn_set_k=menu_add_feature("Set key for speed decrease","action",g.tbl.a_b.flight_cntrls_k.id,function(f)
			funcs.doo.set_keybinds(1,"Speed decrease",g.tbl.a_b.speed_dwn_key_k)
			f.name = "Set key for decrease ("..inputs.vk_list[g.tbl.a_b.speed_dwn_key_k.value+1]..")"
		end)

		g.tbl.a_b.speed_stop_key_k=og_menu_add_feature("Key1 for flight cancel","action_value_str",g.tbl.a_b.flight_cntrls_k.id)
		g.tbl.a_b.speed_stop_key_k:set_str_data(inputs.vk_list)
		funcs.add_to_S_L(g.tbl.a_b.speed_stop_key_k,"g.tbl.a_b.speed_stop_key_k")
		g.tbl.a_b.speed_stop_key_k.hidden=true
		g.tbl.a_b.speed_stop_key_k.value=84

		g.tbl.a_b.speed_stop_set_k=menu_add_feature("Set key for cancel","action",g.tbl.a_b.flight_cntrls_k.id,function(f)
			funcs.doo.set_keybinds(1,"Flight cancel",g.tbl.a_b.speed_stop_key_k)
			f.name = "Set key for cancel ("..inputs.vk_list[g.tbl.a_b.speed_stop_key_k.value+1]..")"
		end)

---------------------------------------------------------------------------------------------------------------------------
g.tbl.a_b.type_prnt=menu_add_feature("Target Selection","parent",g.prnt.self_weapons_s_a_b.id,function(f)
	g.tbl.a_b.ped_hide()
end)

	function g.tbl.a_b.ped_hide()
		g.tbl.a_b.type_csa.hidden=(not g.tbl.a_b.type_npc.on)
		g.tbl.a_b.type_mssn.hidden=(not g.tbl.a_b.type_npc.on)
		g.tbl.a_b.type_othr_npc.hidden=(not g.tbl.a_b.type_npc.on)
		g.tbl.a_b.type_frnd.hidden=(not g.tbl.a_b.type_plyr.on)
		g.tbl.a_b.type_org.hidden=(not g.tbl.a_b.type_plyr.on)
		g.tbl.a_b.type_othr_plyr.hidden=(not g.tbl.a_b.type_plyr.on)
		g.tbl.a_b.type_only_veh.hidden=(not g.tbl.a_b.type_plyr.on)
	end

	g.tbl.a_b.type_npc=menu_add_feature("NPC", "toggle", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.ped_hide()
		if not f.on and not g.tbl.a_b.type_plyr.on then
			g.tbl.a_b.type_plyr.on=true
		end
	end)
	funcs.add_to_S_L(g.tbl.a_b.type_npc,"g.tbl.a_b.type_npc")

	function g.tbl.a_b.npc_no_option(_bool,_feat)
		if _bool and g.tbl.a_b.type_csa.value==1 and g.tbl.a_b.type_mssn.value==1 and g.tbl.a_b.type_othr_npc.value==1 then
			_feat.value = 0
		end
	end

	g.tbl.a_b.type_csa=menu_add_feature("Cops/Security/Army", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.npc_no_option(f.value==1,g.tbl.a_b.type_mssn)
	end)
	new_set_str_data(g.tbl.a_b.type_csa,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.a_b.type_csa,"g.tbl.a_b.type_csa")

	g.tbl.a_b.type_mssn=menu_add_feature("Mission/Angry", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.npc_no_option(f.value==1,g.tbl.a_b.type_othr_npc)
	end)
	new_set_str_data(g.tbl.a_b.type_mssn,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.a_b.type_mssn,"g.tbl.a_b.type_mssn")

	g.tbl.a_b.type_othr_npc=menu_add_feature("All other NPC", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.npc_no_option(f.value==1,g.tbl.a_b.type_csa)
	end)
	new_set_str_data(g.tbl.a_b.type_othr_npc,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.a_b.type_othr_npc,"g.tbl.a_b.type_othr_npc")

	g.tbl.a_b.type_plyr=menu_add_feature("Players", "toggle", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.ped_hide()
		if not f.on and not g.tbl.a_b.type_npc.on then
			g.tbl.a_b.type_npc.on=true
		end
	end)
	funcs.add_to_S_L(g.tbl.a_b.type_plyr,"g.tbl.a_b.type_plyr")

	function g.tbl.a_b.plyr_show_or_hide(_bool,_feat)
		if _bool and g.tbl.a_b.type_frnd.value==0 and g.tbl.a_b.type_org.value==0 and g.tbl.a_b.type_othr_plyr.value==0 then
			_feat.value = 1
		end
	end

	g.tbl.a_b.type_only_veh=menu_add_feature("Only players in vehicles", "toggle", g.tbl.a_b.type_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.type_only_veh,"g.tbl.a_b.type_only_veh")

	g.tbl.a_b.type_frnd=menu_add_feature("My Friends", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.plyr_show_or_hide(f.value==0,g.tbl.a_b.type_org)
	end)
	new_set_str_data(g.tbl.a_b.type_frnd,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.a_b.type_frnd,"g.tbl.a_b.type_frnd")

	g.tbl.a_b.type_org=menu_add_feature("My ORG/MC", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.plyr_show_or_hide(f.value==0,g.tbl.a_b.type_othr_plyr)
	end)
	new_set_str_data(g.tbl.a_b.type_org,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.a_b.type_org,"g.tbl.a_b.type_org")

	g.tbl.a_b.type_othr_plyr=menu_add_feature("All other players", "autoaction_value_str", g.tbl.a_b.type_prnt.id,function(f)
		g.tbl.a_b.plyr_show_or_hide(f.value==0,g.tbl.a_b.type_frnd)
	end)
	new_set_str_data(g.tbl.a_b.type_othr_plyr,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.a_b.type_othr_plyr,"g.tbl.a_b.type_othr_plyr")


	g.tbl.a_b.type_npc.on=true
	g.tbl.a_b.type_plyr.on=true
	g.tbl.a_b.type_othr_plyr.value=1

g.tbl.a_b.trgt_optns_prnt=menu_add_feature("Target Information","parent",g.prnt.self_weapons_s_a_b.id)

	g.tbl.a_b.mrkr_show=menu_add_feature("Show target icon on screen","toggle",g.tbl.a_b.trgt_optns_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.mrkr_show,"g.tbl.a_b.mrkr_show")
	g.tbl.a_b.mrkr_show.on=true

	g.tbl.a_b.show_name=menu_add_feature("Show name on screen","toggle",g.tbl.a_b.trgt_optns_prnt.id)
	funcs.add_to_S_L(g.tbl.a_b.show_name,"g.tbl.a_b.show_name")
	g.tbl.a_b.show_name.on=true

	function g.tbl.a_b.start_test_display(_bool,_k)
		if  g.var.GS_has_loaded and _bool then
			if _k then
				g.tbl.a_b.test_geeseek=false
				g.tbl.a_b.test_kosatka=true
			else
				g.tbl.a_b.test_kosatka=false
				g.tbl.a_b.test_geeseek=true
			end
			g.tbl.a_b.test_display=true
			g.tbl.a_b.test_display_feat.on=true
		end
	end

	g.tbl.a_b.test_display=false
	g.tbl.a_b.test_geeseek=false
	g.tbl.a_b.test_kosatka=false
	g.tbl.a_b.test_display_feat=og_menu_add_feature("Gee-Seek Show icon/name HIDDEN", "toggle", g.tbl.a_b.trgt_optns_prnt.id,function(f)
		local time,ent,alpha = TIME_MS() + 3000
		while time > TIME_MS() do
			if g.tbl.a_b.test_display then
				g.tbl.a_b.test_display=false
				time = TIME_MS() + 3000
			end
			if g.tbl.a_b.test_kosatka then
				g.tbl.a_b.test_geeseek=false
				if g.tbl.a_b.mrkr_rot_k.on then
					API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct_k.value],funcs.vec(0,0),1*g.tbl.a_b.mrkr_s_k.value,g.tbl.a_b.mrkr_val_k, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r_k.value,g.tbl.a_b.mrkr_g_k.value,g.tbl.a_b.mrkr_b_k.value,mth.flr((time-TIME_MS())/3000*g.tbl.a_b.mrkr_a_k.value)))
				else
					API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct_k.value],funcs.vec(0,0),1*g.tbl.a_b.mrkr_s_k.value,0, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r_k.value,g.tbl.a_b.mrkr_g_k.value,g.tbl.a_b.mrkr_b_k.value,mth.flr((time-TIME_MS())/3000*g.tbl.a_b.mrkr_a_k.value)))
				end
			elseif g.tbl.a_b.test_geeseek then
				g.tbl.a_b.test_kosatka=false
				if g.tbl.a_b.mrkr_rot.on then
					API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct.value],funcs.vec(0,0),1*g.tbl.a_b.mrkr_s.value,g.tbl.a_b.mrkr_val, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r.value,g.tbl.a_b.mrkr_g.value,g.tbl.a_b.mrkr_b.value,mth.flr((time-TIME_MS())/3000*g.tbl.a_b.mrkr_a.value)))
				else
					API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.a_b.slct.value],funcs.vec(0,0),1*g.tbl.a_b.mrkr_s.value,0, funcs.get.rgba_to_int(g.tbl.a_b.mrkr_r.value,g.tbl.a_b.mrkr_g.value,g.tbl.a_b.mrkr_b.value,mth.flr((time-TIME_MS())/3000*g.tbl.a_b.mrkr_a.value)))
				end
			end
			g.tbl.a_b.show_that_name2(funcs.ME._ped(),funcs.vec(0,0),funcs.get.pid_name(funcs.ME._id()),mth.flr((time-TIME_MS())/3000*g.tbl.a_b.name_a.value))
			YIELD(5)
		end
		f.on=false
	end)
	g.tbl.a_b.test_display_feat.hidden=true



g.tbl.a_b.mrkr_prnt=menu_add_feature("Gee-Seek Icon Options","parent",g.tbl.a_b.trgt_optns_prnt.id,function()
	g.tbl.a_b.homing_target_hide()
end)

		function g.tbl.a_b.homing_target_hide()
			g.tbl.a_b.mrkr_wbl.hidden=(g.tbl.a_b.mrkr_rot.value~=0 or not g.tbl.a_b.mrkr_rot.on)
			g.tbl.a_b.mrkr_rot_spd.hidden=(not g.tbl.a_b.mrkr_rot.on)
		end



		g.tbl.a_b.mrkr_show_stay=menu_add_feature("Retain icon after homing launch","toggle",g.tbl.a_b.mrkr_prnt.id)
		funcs.add_to_S_L(g.tbl.a_b.mrkr_show_stay,"g.tbl.a_b.mrkr_show_stay")
		g.tbl.a_b.mrkr_show_stay.on=true

		g.tbl.a_b.slct = menu_add_feature("Select icon", "autoaction_value_i", g.tbl.a_b.mrkr_prnt.id, function(f)
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.slct,1,#g.tbl.reticle_files,1,35,"g.tbl.a_b.slct")

		g.tbl.a_b.mrkr_s = menu_add_feature("Icon size", "autoaction_value_f",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_s,0,3,0.01,1,"g.tbl.a_b.mrkr_s")

		g.tbl.a_b.mrkr_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_r,0,255,1,255,"g.tbl.a_b.mrkr_r")

		g.tbl.a_b.mrkr_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_g,0,255,1,0,"g.tbl.a_b.mrkr_g")

		g.tbl.a_b.mrkr_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_b,0,255,1,0,"g.tbl.a_b.mrkr_b")

		g.tbl.a_b.mrkr_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_a,0,255,1,255,"g.tbl.a_b.mrkr_a")

		g.tbl.a_b.mrkr_val = 0
		g.tbl.a_b.mrkr_rot = menu_add_feature("Icon rotation", "value_str",g.tbl.a_b.mrkr_prnt.id,function(f)
			local flip,f_value,_min,_max = true
			g.tbl.a_b.start_test_display(f.on,false)
			while f.on do
				if f_value ~= f.value then
					g.tbl.a_b.start_test_display(true,false)
					f_value = f.value
					g.tbl.a_b.mrkr_val=0
				end
				if f.value == 0 then
					_max = g.tbl.a_b.mrkr_wbl.value/360*2*mth.pi
					_min = _max*-1
					if flip then
						if g.tbl.a_b.mrkr_val <= _min then
							flip = false
						else
							g.tbl.a_b.mrkr_val=g.tbl.a_b.mrkr_val-(0.02*g.tbl.a_b.mrkr_rot_spd.value)
						end
					elseif g.tbl.a_b.mrkr_val >= _max then
						flip = true
					else
						g.tbl.a_b.mrkr_val=g.tbl.a_b.mrkr_val+(0.02*g.tbl.a_b.mrkr_rot_spd.value)
					end
					if not funcs.is.num_in_range(g.tbl.a_b.mrkr_val,_min,_max) then
						flip=funcs.get.opp_bool(flip)
					end
				elseif f.value == 1 then
					if g.tbl.a_b.mrkr_val >= (2*mth.pi) then
						g.tbl.a_b.mrkr_val = g.tbl.a_b.mrkr_val -(2*mth.pi)
					else
						g.tbl.a_b.mrkr_val=g.tbl.a_b.mrkr_val+(0.02*g.tbl.a_b.mrkr_rot_spd.value)
					end
				elseif g.tbl.a_b.mrkr_val <= (-2*mth.pi) then
					g.tbl.a_b.mrkr_val = g.tbl.a_b.mrkr_val+(-2*mth.pi)
				else
					g.tbl.a_b.mrkr_val=g.tbl.a_b.mrkr_val-(0.02*g.tbl.a_b.mrkr_rot_spd.value)
				end
				g.tbl.a_b.homing_target_hide()
				YIELD(25)
			end
			g.tbl.a_b.mrkr_wbl.hidden=true
			g.tbl.a_b.mrkr_rot_spd.hidden=true
		end)
		new_set_str_data(g.tbl.a_b.mrkr_rot,{"Wobble","Clockwise","Counter-Clockwise"})
		funcs.add_to_S_L(g.tbl.a_b.mrkr_rot,"g.tbl.a_b.mrkr_rot")

		g.tbl.a_b.mrkr_wbl = menu_add_feature("Wobble range", "autoaction_value_i",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
			g.tbl.a_b.mrkr_val=0
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_wbl,0,360,5,15,"g.tbl.a_b.mrkr_wbl")

		g.tbl.a_b.mrkr_rot_spd = menu_add_feature("Rotation speed", "autoaction_value_f",g.tbl.a_b.mrkr_prnt.id,function()
			g.tbl.a_b.start_test_display(true,false)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_rot_spd,0.1,3,0.1,1,"g.tbl.a_b.mrkr_rot_spd")


g.tbl.a_b.mrkr_prnt_k=menu_add_feature("Kosatka Icon Options","parent",g.tbl.a_b.trgt_optns_prnt.id,function()
	g.tbl.a_b.kosatka_target_hide()
end)

		function g.tbl.a_b.kosatka_target_hide()
			g.tbl.a_b.mrkr_wbl_k.hidden=(g.tbl.a_b.mrkr_rot_k.value~=0 or not g.tbl.a_b.mrkr_rot_k.on)
			g.tbl.a_b.mrkr_rot_spd_k.hidden=(not g.tbl.a_b.mrkr_rot_k.on)
		end

		g.tbl.a_b.slct_k = menu_add_feature("Select icon", "autoaction_value_i", g.tbl.a_b.mrkr_prnt_k.id, function(f)
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.slct_k,1,#g.tbl.reticle_files,1,28,"g.tbl.a_b.slct_k")

		g.tbl.a_b.mrkr_s_k = menu_add_feature("Icon size", "autoaction_value_f",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_s_k,0,3,0.01,1,"g.tbl.a_b.mrkr_s_k")

		g.tbl.a_b.mrkr_r_k = menu_add_feature("Red", "autoaction_value_i",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_r_k,0,255,1,255,"g.tbl.a_b.mrkr_r_k")

		g.tbl.a_b.mrkr_g_k = menu_add_feature("Green", "autoaction_value_i",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_g_k,0,255,1,0,"g.tbl.a_b.mrkr_g_k")

		g.tbl.a_b.mrkr_b_k = menu_add_feature("Blue", "autoaction_value_i",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_b_k,0,255,1,0,"g.tbl.a_b.mrkr_b_k")

		g.tbl.a_b.mrkr_a_k = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_a_k,0,255,1,255,"g.tbl.a_b.mrkr_a_k")

		g.tbl.a_b.mrkr_val_k = 0
		g.tbl.a_b.mrkr_rot_k = menu_add_feature("Icon rotation", "value_str",g.tbl.a_b.mrkr_prnt_k.id,function(f)
			local flip,f_value,_min,_max = true
			g.tbl.a_b.start_test_display(f.on,true)
			while f.on do
				if f_value ~= f.value then
					g.tbl.a_b.start_test_display(true,true)
					f_value = f.value
					g.tbl.a_b.mrkr_val_k=0
				end
				if f.value == 0 then
					_max = g.tbl.a_b.mrkr_wbl.value/360*2*mth.pi
					_min = _max*-1
					if flip then
						if g.tbl.a_b.mrkr_val_k <= _min then
							flip = false
						else
							g.tbl.a_b.mrkr_val_k=g.tbl.a_b.mrkr_val_k-(0.02*g.tbl.a_b.mrkr_rot_spd_k.value)
						end
					elseif g.tbl.a_b.mrkr_val_k >= _max then
						flip = true
					else
						g.tbl.a_b.mrkr_val_k=g.tbl.a_b.mrkr_val_k+(0.02*g.tbl.a_b.mrkr_rot_spd_k.value)
					end
					if not funcs.is.num_in_range(g.tbl.a_b.mrkr_val_k,_min,_max) then
						flip=funcs.get.opp_bool(flip)
					end
				elseif f.value == 1 then
					if g.tbl.a_b.mrkr_val_k >= (2*mth.pi) then
						g.tbl.a_b.mrkr_val_k = g.tbl.a_b.mrkr_val_k-(2*mth.pi)
					else
						g.tbl.a_b.mrkr_val_k=g.tbl.a_b.mrkr_val_k+(0.02*g.tbl.a_b.mrkr_rot_spd_k.value)
					end
				elseif g.tbl.a_b.mrkr_val_k <= (-2*mth.pi) then
					g.tbl.a_b.mrkr_val_k = g.tbl.a_b.mrkr_val_k+(-2*mth.pi)
				else
					g.tbl.a_b.mrkr_val_k=g.tbl.a_b.mrkr_val_k-(0.02*g.tbl.a_b.mrkr_rot_spd_k.value)
				end
				g.tbl.a_b.mrkr_wbl_k.hidden=(f.value~=0)
				YIELD(25)
			end
			g.tbl.a_b.mrkr_wbl_k.hidden=true
			g.tbl.a_b.mrkr_rot_spd_k.hidden=true
		end)new_set_str_data(g.tbl.a_b.mrkr_rot_k,{"Wobble","Clockwise","Counter-Clockwise"})
		funcs.add_to_S_L(g.tbl.a_b.mrkr_rot_k,"g.tbl.a_b.mrkr_rot_k")
		g.tbl.a_b.mrkr_rot_k.value=1

		g.tbl.a_b.mrkr_wbl_k = menu_add_feature("Wobble range", "autoaction_value_i",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
			g.tbl.a_b.mrkr_val_k=0
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_wbl_k,0,360,5,15,"g.tbl.a_b.mrkr_wbl_k")

		g.tbl.a_b.mrkr_rot_spd_k = menu_add_feature("Rotation speed", "autoaction_value_f",g.tbl.a_b.mrkr_prnt_k.id,function()
			g.tbl.a_b.start_test_display(true,true)
		end)
		funcs.set_feat_i_f(g.tbl.a_b.mrkr_rot_spd_k,0.1,3,0.1,2,"g.tbl.a_b.mrkr_rot_spd_k")

		g.tbl.a_b.mrkr_rot_k.on=true


-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
g.tbl.a_b.name_prnt=menu_add_feature("Name Options","parent",g.tbl.a_b.trgt_optns_prnt.id)

g.tbl.a_b.name_flags=(1<<1)+(1<<0)
g.tbl.a_b.name_x_flag=(2/3)

function g.tbl.a_b.name_flags_do()
	if g.tbl.a_b.name_just.value == 0 then
		g.tbl.a_b.name_flags=(1<<1)
		g.tbl.a_b.name_x_flag=1
	elseif g.tbl.a_b.name_just.value == 1 then
		g.tbl.a_b.name_flags=(1<<1)+(1<<0)
		g.tbl.a_b.name_x_flag=(2/3)
	else
		g.tbl.a_b.name_flags=(1<<1)+(1<<4)
		g.tbl.a_b.name_x_flag=1
	end
end


function g.tbl.a_b.show_that_name(ent,pos,name,alpha)
	if g.tbl.a_b.show_name.on then
		pos.x=pos.x*g.tbl.a_b.name_x_flag
		pos.x=pos.x+g.tbl.a_b.name_x.value
		pos.y=pos.y+g.tbl.a_b.name_y.value
		local _r,_g,_b = g.tbl.a_b.name_r.value,g.tbl.a_b.name_g.value,g.tbl.a_b.name_b.value
		if funcs.is.ent(ent) and API.ent.is.ped(ent) and API.Ped.is.plyr(ent) and glbls.team_rgb_int(API.plyr.get.plyr_from_ped(ent)) > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.get.plyr_from_ped(ent)+1,nil)
		end
		API.SD.draw_text(name,pos,pos,g.tbl.a_b.name_s.value,funcs.get.rgba_to_int(_r,_g,_b,mth.flr(alpha/255*g.tbl.a_b.name_a.value)),g.tbl.a_b.name_flags,nil)
	end
end

-- function g.tbl.a_b.name_xy_do()
	-- g.tbl.a_b.name_x.name = "X Pos Offset: "..funcs.get._3_dec(g.tbl.a_b.name_x.value)
	-- g.tbl.a_b.name_y.name = "Y Pos Offset: "..funcs.get._3_dec(g.tbl.a_b.name_y.value)
-- end

g.tbl.a_b.name_just = menu_add_feature("Justification", "autoaction_value_str",g.tbl.a_b.name_prnt.id,function(f)
	g.tbl.a_b.name_flags_do()
end)
new_set_str_data(g.tbl.a_b.name_just,{"Left","Center","Right"})
funcs.add_to_S_L(g.tbl.a_b.name_just,"g.tbl.a_b.name_just")
g.tbl.a_b.name_just.value=1

g.tbl.a_b.name_s=menu_add_feature("Size","action_value_f",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_s,0,3,0.01,1,"g.tbl.a_b.name_s")

g.tbl.a_b.name_x=menu_add_feature("X Pos Offset","autoaction_value_f",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_x,-1,1,0.0025,0,"g.tbl.a_b.name_x")

g.tbl.a_b.name_y=menu_add_feature("Y Pos Offset","autoaction_value_f",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_y,-1,1,0.0025,-0.025,"g.tbl.a_b.name_y")

g.tbl.a_b.name_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_r,0,255,1,255,"g.tbl.a_b.name_r")

g.tbl.a_b.name_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_g,0,255,1,255,"g.tbl.a_b.name_g")

g.tbl.a_b.name_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_b,0,255,1,255,"g.tbl.a_b.name_b")

g.tbl.a_b.name_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.a_b.name_prnt.id)
funcs.set_feat_i_f(g.tbl.a_b.name_a,0,255,1,255,"g.tbl.a_b.name_a")
g.tbl.a_b.defaults()

g.print_load_info("Special Aim-Bot",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Vehicle ESP"

g.tbl.r_f ={}

function g.tbl.r_f._do(temp_weap,_delay)
	local my_weap = funcs.ME._weap()
	if temp_weap[my_weap] ~= nil then
		if not API.wpn.ped_has(funcs.ME._ped(), temp_weap[my_weap]) then
			funcs.doo.give_ped_weap(funcs.ME._ped(),temp_weap[my_weap])
		end
		funcs.doo.give_ped_ammo(funcs.ME._ped(),my_weap)
		ntv.set.ped_weap(funcs.ME._ped(),temp_weap[my_weap])
		funcs.doo.delay(_delay+30)
		funcs.doo.give_ped_ammo(funcs.ME._ped(),temp_weap[my_weap])
		ntv.set.ped_weap(funcs.ME._ped(),my_weap)
	end
end

g.tbl.r_f.lnchr_prnt=menu_add_feature("Launchers","parent",g.prnt.self_weapons_r_f.id)

g.tbl.r_f.heavy=menu_add_feature("Rapid-Fire launchers","value_i",g.tbl.r_f.lnchr_prnt.id,function(f)
	local temp_weap = {
	[API.get_hash_key("weapon_rpg")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_stinger")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_compactlauncher")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_grenadelauncher")] = API.get_hash_key("weapon_compactlauncher"),
	[API.get_hash_key("weapon_hominglauncher")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_firework")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_emplauncher")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_railgun")] = API.get_hash_key("weapon_grenade"),
	[API.get_hash_key("weapon_railgunxm3")] = API.get_hash_key("weapon_grenade"),
	}
	local grnd_weap = {
	[API.get_hash_key("weapon_rpg")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_stinger")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_compactlauncher")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_grenadelauncher")] = API.get_hash_key("weapon_compactlauncher"),
	[API.get_hash_key("weapon_hominglauncher")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_firework")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_emplauncher")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_railgun")] = API.get_hash_key("weapon_grenadelauncher"),
	[API.get_hash_key("weapon_railgunxm3")] = API.get_hash_key("weapon_grenadelauncher"),
	}
	while f.on do
		YIELD(0)
		if funcs.ME._shoot() then
			if g.tbl.r_f.grenade.on then
				g.tbl.r_f._do(grnd_weap,f.value)
			else
				g.tbl.r_f._do(temp_weap,f.value)
			end
		end
	end
end)
funcs.set_feat_i_f(g.tbl.r_f.heavy,0,250,10,50,"g.tbl.r_f.heavy")

g.tbl.r_f.grenade=menu_add_feature("Use grenade launcher as secondary for all","toggle",g.tbl.r_f.lnchr_prnt.id)
funcs.add_to_S_L(g.tbl.r_f.grenade,"g.tbl.r_f.grenade")

g.tbl.r_f.shtgn_msk=menu_add_feature("Rapid-Fire Shotguns/Musket","value_i",g.prnt.self_weapons_r_f.id,function(f)
	local temp_weap = {}
	for i=1,#weap_info.hand.info.shotgun do
		temp_weap[weap_info.hand.info.shotgun[i][1]] = API.get_hash_key("weapon_grenade")
	end
	while f.on do
		YIELD(0)
		if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then
			g.tbl.r_f._do(temp_weap,f.value)
		end
	end
end)
funcs.set_feat_i_f(g.tbl.r_f.shtgn_msk,0,250,10,50,"g.tbl.r_f.shtgn_msk")

g.tbl.r_f.hndgn=menu_add_feature("Rapid-Fire Handguns","value_i",g.prnt.self_weapons_r_f.id,function(f)
	local temp_weap = {}
	for i=1,#weap_info.hand.info.handgun do
		temp_weap[weap_info.hand.info.handgun[i][1]] = API.get_hash_key("weapon_grenade")
	end
	while f.on do
		YIELD(0)
		if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then
			g.tbl.r_f._do(temp_weap,f.value)
		end
	end
end)
funcs.set_feat_i_f(g.tbl.r_f.hndgn,0,250,10,50,"g.tbl.r_f.hndgn")

g._veh_double_shot=menu_add_feature("Vehicle Double Shot","toggle",g.prnt.self_weapons_r_f.id,function(f)
	if f.on then
		g._veh_rapid_fire_tank.on=false
		g._veh_rapid_fire_tank2.on=false
		g._veh_rapid_fire.on=false
	end
	while f.on do
		YIELD(0)
		if funcs.ME._in_veh() then
			local veh = funcs.ME._veh()
			if ntv.is.veh_have_weap(veh) and funcs.ME._shoot() then
				funcs.doo.veh_repair_and_speed(veh)
			end
		end
	end
end)
funcs.add_to_S_L(g._veh_double_shot,"g._veh_double_shot")

function funcs.doo.veh_repair_and_speed(veh)
	local speed = API.ent.get.velocity(veh)
	API.veh.set.fixed(veh)
	YIELD(0)
	API.ent.set.velocity(veh,speed)
end

g._veh_rapid_fire=menu_add_feature("Vehicle Rapid Fire","slider",g.prnt.self_weapons_r_f.id,function(f)
	if f.on then
		g._veh_rapid_fire_tank.on=false
		g._veh_rapid_fire_tank2.on=false
		g._veh_double_shot.on=false
	end
	local  t = {
	[0] = 425,
	[100] = 375,
	[200] = 300,
	[300] = 225,
	[400] = 150,
	[500] = 75,
	}
	while f.on do
		YIELD(0)
		if funcs.ME._in_veh() then
			local veh = funcs.ME._veh()
			if ntv.is.veh_have_weap(veh) then
				funcs.doo.veh_repair_and_speed(veh)
				YIELD(t[f.value])
			end
		end
	end
end)
funcs.set_feat_i_f(g._veh_rapid_fire,0,500,100,0,"g._veh_rapid_fire")

g._veh_rapid_fire_tank=menu_add_feature("Vehicle Rapid Fire (Tanks/APC)","toggle",g.prnt.self_weapons_r_f.id,function(f)
	if f.on then
		g._veh_rapid_fire.on=false
		g._veh_rapid_fire_tank2.on=false
		g._veh_double_shot.on=false
	end
	local rhino = API.get_hash_key("rhino")
	local apc = API.get_hash_key("apc")
	local khanjali = API.get_hash_key("khanjali")
	while f.on do
		YIELD(0)
		if funcs.ME._in_veh() and funcs.ME._shoot() then
			local veh = funcs.ME._veh()
			if ntv.is.veh_have_weap(veh) then
				local hash = API.ent.get.model_hash(veh)
				local driver = API.veh.get.ped_in_seat(veh, -1) == funcs.ME._ped()
				local passenger = API.veh.get.ped_in_seat(veh, 0) == funcs.ME._ped()
				if hash == rhino and driver then
					funcs.doo.veh_repair_and_speed(veh)
					system.wait(50)
				elseif hash == apc and passenger then
					if funcs.ntwrk.ask_long(veh,50) then
						funcs.doo.veh_repair_and_speed(veh)
					end
				elseif hash == khanjali and driver then
					funcs.doo.veh_repair_and_speed(veh)
					system.wait(100)
				end
			end
		end
	end
end)
funcs.add_to_S_L(g._veh_rapid_fire_tank,"g._veh_rapid_fire_tank")

g._veh_rapid_fire_tank2=menu_add_feature("Vehicle Rapid Fire v2 (Tanks/APC/Chernobog)","toggle",g.prnt.self_weapons_r_f.id,function(f)
	if f.on then
		g._veh_rapid_fire.on=false
		g._veh_rapid_fire_tank.on=false
		g._veh_double_shot.on=false
	end
	local cam_z,in_seat,my_seat
	while f.on do
		YIELD(250)
		in_seat,my_seat = funcs.is.pid_in_turret_seat(funcs.ME._id())
		if in_seat then
			while API.veh.get.ped_in_seat(funcs.ME._veh(), my_seat) == funcs.ME._ped() and f.on do
				YIELD(5)
				if funcs.ME._shoot() then
					cam_z = (API.cam.get.rot().z-API.ent.get.heading(funcs.ME._veh()))/360*mth.pi*2
					API.veh.set.fixed(funcs.ME._veh())
					ntv.set.veh_turret_rot(funcs.ME._veh(),cam_z)
					API.ent.force(funcs.ME._veh(), 3, 0,0,-2, 0,0,0, false, true)
				end
			end
		end
	end
end)
funcs.add_to_S_L(g._veh_rapid_fire_tank2,"g._veh_rapid_fire_tank2")

g.tbl.rtcl={}
g.tbl.rtcl.ent_bool=nil
g.tbl.rtcl.is_active=false



g.tbl.rtcl.feat = menu_add_feature("Show reticle", "toggle", g.prnt.utils_rtcle.id, function(f)
	local g_time,s_time,size = TIME_MS(),TIME_MS(),1
	while f.on do
		YIELD(5)
		if g.tbl.rtcl.shld_show() then
			g.tbl.rtcl.is_active=true
			if g.tbl.rtcl.rtcl_react.on then
				if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then
					g_time = TIME_MS()+125
					s_time = TIME_MS()
					size=1
				end
				if g_time > TIME_MS() or s_time > TIME_MS() then
					if g_time > TIME_MS() then size = size *1.01
					else size = size *.99
					end
				else size=1
				end
				if size >= 1.25 then
					s_time = TIME_MS()+125
					g_time = TIME_MS()
				end
			else
				size=1
			end
			API.SD.draw_sprt(
			g.tbl.reticle_sprites[g.tbl.rtcl.slct.value],
			funcs.vec(0,0),
			g.tbl.rtcl.size.value*size*g.RES_H,
			0,
			g.tbl.rtcl.ent_bool and funcs.get.rgba_to_int(g.tbl.rtcl.ent_r.value,g.tbl.rtcl.ent_g.value,g.tbl.rtcl.ent_b.value,g.tbl.rtcl.ent_a.value) or funcs.get.rgba_to_int(g.tbl.rtcl.no_ent_r.value,g.tbl.rtcl.no_ent_g.value,g.tbl.rtcl.no_ent_b.value,g.tbl.rtcl.no_ent_a.value)
			)
		end
		g.tbl.rtcl.ent_bool=nil------future reference for gee-watch
	end
	g.tbl.rtcl.is_active=false
end)
funcs.add_to_S_L(g.tbl.rtcl.feat,"g.tbl.rtcl.feat")

function g.tbl.rtcl.shld_show()
	if g.tbl.rtcl.rtcl_slct.value==2 then
		g.tbl.rtcl.ent_bool=g.tbl.rtcl.is_ent()
		return true
	elseif funcs.ME._aim() then
		if g.tbl.rtcl.rtcl_slct.value==1 then
			g.tbl.rtcl.ent_bool=g.tbl.rtcl.is_ent()
			return true
		end
		g.tbl.rtcl.ent_bool=g.tbl.rtcl.is_ent()
		return g.tbl.rtcl.ent_bool
	end
	g.tbl.rtcl.is_active=false
	return false
end

function g.tbl.rtcl.is_ent()
	local aim = API.plyr.get.aim_at(API.plyr.my_id())
	return (funcs.is.ent(aim) and API.ent.is.ped(aim))
end

g.tbl.rtcl.splash=false
g.tbl.rtcl.slct = menu_add_feature("Select reticle", "autoaction_value_i", g.prnt.utils_rtcle.id, function(f)
	if g.var.GS_has_loaded then
		g.tbl.rtcl.splash=true
		g.tbl.rtcl.splash_feat.on=true
	end
end)
funcs.set_feat_i_f(g.tbl.rtcl.slct,1,#g.tbl.reticle_files,1,1,"g.tbl.rtcl.slct")

g.tbl.rtcl.splash_feat=og_menu_add_feature("Show  reticles HIDDEN", "toggle", g.prnt.utils_rtcle.id,function(f)
	local ret_value
	local function get_int(_num)
		if g.tbl.reticle_sprites[ret_value+_num] ~= nil then
			return g.tbl.reticle_sprites[ret_value+_num]
		elseif ret_value+_num > #g.tbl.reticle_files then
			return g.tbl.reticle_sprites[ret_value+_num-#g.tbl.reticle_files]
		end
		return g.tbl.reticle_sprites[#g.tbl.reticle_files+ret_value+_num]
	end
	local time,alpha_t,x_pos,y_pos,alpha,ret_size,ret_color = TIME_MS() + 4000,TIME_MS() + 1000
	while time > TIME_MS() do
		if g.tbl.rtcl.splash then
			g.tbl.rtcl.splash=false
			time = TIME_MS() + 4000
			alpha_t = TIME_MS() + 1000
		end
		alpha = alpha_t > TIME_MS() and 255 or mth.flr((time-TIME_MS()) /1000/3*255)
		ret_size = g.tbl.rtcl.size.value
		ret_color = funcs.get.rgba_to_int(g.tbl.rtcl.no_ent_r.value,g.tbl.rtcl.no_ent_g.value,g.tbl.rtcl.no_ent_b.value,alpha)
		x_pos=API.gfx.get_w()/69000 + (3840/69000 - API.gfx.get_w()/69000)
		x_pos=x_pos*ret_size
		y_pos=API.gfx.get_h()/40000 + (2160/40000 - API.gfx.get_h()/40000)
		y_pos=y_pos*ret_size
		ret_value = g.tbl.rtcl.slct.value
		for i=-3,3 do
			API.SD.draw_sprt(get_int(i),funcs.vec(0+(x_pos*i),0),ret_size*g.RES_H,0,ret_color)
		end
		API.SD.draw_line(funcs.vec(x_pos*-.5,y_pos),funcs.vec(x_pos*.5,y_pos), 1, funcs.get.rgba_to_int(255,0,0,alpha))
		API.SD.draw_line(funcs.vec(x_pos*.5,y_pos),funcs.vec(x_pos*.5,y_pos*-1), 1, funcs.get.rgba_to_int(255,0,0,alpha))
		API.SD.draw_line(funcs.vec(x_pos*.5,y_pos*-1),funcs.vec(x_pos*-.5,y_pos*-1), 1, funcs.get.rgba_to_int(255,0,0,alpha))
		API.SD.draw_line(funcs.vec(x_pos*-.5,y_pos*-1),funcs.vec(x_pos*-.5,y_pos), 1, funcs.get.rgba_to_int(255,0,0,alpha))
		if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then time = TIME_MS() end
		YIELD(5)
	end
	f.on=false
end)
g.tbl.rtcl.splash_feat.hidden=true

g.tbl.rtcl.size = menu_add_feature("Reticle size", "action_value_f", g.prnt.utils_rtcle.id)
funcs.set_feat_i_f(g.tbl.rtcl.size,0.01,2,0.01,1,"g.tbl.rtcl.size")

g.tbl.rtcl.rtcl_slct=menu_add_feature("Conditions:", "action_value_str",g.prnt.utils_rtcle.id)
new_set_str_data(g.tbl.rtcl.rtcl_slct,{"Aiming at ped","If aiming","Always"})
funcs.add_to_S_L(g.tbl.rtcl.rtcl_slct,"g.tbl.rtcl.rtcl_slct")

g.tbl.rtcl.rtcl_react=menu_add_feature("Reactive", "toggle",g.prnt.utils_rtcle.id)
funcs.add_to_S_L(g.tbl.rtcl.rtcl_react,"g.tbl.rtcl.rtcl_react")

g.tbl.rtcl.no_ent_r = menu_add_feature("Red", "action_value_i",g.prnt.utils_rtcle.id)
funcs.set_feat_i_f(g.tbl.rtcl.no_ent_r,0,255,5,255,"g.tbl.rtcl.no_ent_r")

g.tbl.rtcl.no_ent_g = menu_add_feature("Green", "action_value_i",g.prnt.utils_rtcle.id)
funcs.set_feat_i_f(g.tbl.rtcl.no_ent_g,0,255,5,255,"g.tbl.rtcl.no_ent_g")

g.tbl.rtcl.no_ent_b = menu_add_feature("Blue", "action_value_i",g.prnt.utils_rtcle.id)
funcs.set_feat_i_f(g.tbl.rtcl.no_ent_b,0,255,5,255,"g.tbl.rtcl.no_ent_b")

g.tbl.rtcl.no_ent_a = menu_add_feature("Alpha", "action_value_i",g.prnt.utils_rtcle.id)
funcs.set_feat_i_f(g.tbl.rtcl.no_ent_a,0,255,5,255,"g.tbl.rtcl.no_ent_a")

g.tbl.rtcl.ent_prnt=menu_add_feature("Color while aiming at ped", "parent",g.prnt.utils_rtcle.id)

g.tbl.rtcl.ent_r = menu_add_feature("Red", "action_value_i",g.tbl.rtcl.ent_prnt.id)
funcs.set_feat_i_f(g.tbl.rtcl.ent_r,0,255,5,255,"g.tbl.rtcl.ent_r")

g.tbl.rtcl.ent_g = menu_add_feature("Green", "action_value_i",g.tbl.rtcl.ent_prnt.id)
funcs.set_feat_i_f(g.tbl.rtcl.ent_g,0,255,5,255,"g.tbl.rtcl.ent_g")

g.tbl.rtcl.ent_b = menu_add_feature("Blue", "action_value_i",g.tbl.rtcl.ent_prnt.id)
funcs.set_feat_i_f(g.tbl.rtcl.ent_b,0,255,5,255,"g.tbl.rtcl.ent_b")

g.tbl.rtcl.ent_a = menu_add_feature("Alpha", "action_value_i",g.tbl.rtcl.ent_prnt.id)
funcs.set_feat_i_f(g.tbl.rtcl.ent_a,0,255,5,255,"g.tbl.rtcl.ent_a")

g.tbl.spwn = {}
g.tbl.spwn.history = {}
g.tbl.spwn.qck_srch_table = {}
g.tbl.spwn.feat_srch_table = {}
g.tbl.spwn.old_veh=nil
g.tbl.spwn.plt_directory = g.paths._user.."\\Vehicle License Plate\\"
function g.tbl.spwn.spwn_plate_write(_text,_file)
	local file = io.open(g.tbl.spwn.plt_directory.._file..".txt", "w")
	file:write(_text)
	file:close()
end

function g.tbl.spwn.spwn_plate_get(_file)
	local file = io.open(g.tbl.spwn.plt_directory.._file..".txt", "r")
	local text = nil
	for line in file:lines() do
		if line ~= nil and string.len(tostring(line)) > 0 and string.len(tostring(line)) < 9 then
			text = tostring(line)
			break
		end
	end
	file:close()
	return text
end

function g.tbl.spwn.spwn_plate_check(_file)
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.tbl.spwn.plt_directory)
	if not utils.file_exists(g.tbl.spwn.plt_directory.._file..".txt") then
		g.tbl.spwn.spwn_plate_write("GeeSpawn",_file)
	end
	local text = g.tbl.spwn.spwn_plate_get(_file)
	if text == nil then
		g.tbl.spwn.spwn_plate_write("GeeSpawn",_file)
	end
end
g.tbl.spwn.spwn_plate_check("Self Vehicle Spawn")
g.tbl.spwn.spwn_plate_txt = g.tbl.spwn.spwn_plate_get("Self Vehicle Spawn")

function g.tbl.spwn.quick_spawn_write(_text)
	local file = io.open(g.paths._user.."Vehicle Quick Spawn List.txt", "w")
	file:write(_text)
	file:close()
end

function g.tbl.spwn.quick_spawn_get()
	local file = io.open(g.paths._user.."Vehicle Quick Spawn List.txt", "r")
	local list = {}
	for line in file:lines() do
		if API.strm.is.valid(API.get_hash_key(line)) then
			list[#list+1] = line
		end
	end
	file:close()
	return list
end

function g.tbl.spwn.quick_spawn_check()
	funcs.doo.check_create_dir(g.paths._user)
	if not utils.file_exists(g.paths._user.."Vehicle Quick Spawn List.txt") then
		g.tbl.spwn.quick_spawn_write(g.var.quick_spawn_default)
	end
	local list = g.tbl.spwn.quick_spawn_get()
	if #list == 0 then
		g.tbl.spwn.quick_spawn_write(g.var.quick_spawn_default)
	end
end

g.var.quick_spawn_default = ""

g.tbl.spwn.quick_spawn_default_table={
"oppressor",
"oppressor2",
"deluxo",
"toreador",
"rhino",
"khanjali",
"menacer",
"nightshark",
"insurgent3",
"phantom2",
"dune4",
"buzzard",
"savage",
"akula",
"hunter",
"nokota",
"seabreeze",
"rogue",
"molotok",
"strikeforce",
"hydra",
"lazer",
}

for i=1,#g.tbl.spwn.quick_spawn_default_table do
	g.var.quick_spawn_default=g.var.quick_spawn_default..g.tbl.spwn.quick_spawn_default_table[i].."\n"
end

g.tbl.spwn.quick_spawn_check()
g.tbl.spwn.quick_spawn_list = g.tbl.spwn.quick_spawn_get() --had plans to make this update-able in game

function g.tbl.spwn.apply_upgrades(_veh)
	if funcs.is.ent(_veh) then
		funcs.ntwrk.ask_quick(_veh)
		API.veh.set.kit_type(_veh, 0)
		if g.tbl.spwn.spwn_god.on then
			API.ent.set.god(_veh,true)
		end
		if g.tbl.spwn.spwn_upg.on then
			if g.tbl.spwn.spwn_upg.value == 0 then
				funcs.doo.veh_upgr_basic(_veh)
				funcs.doo.veh_upgr_perf(_veh)
				funcs.doo.veh_upgr_wheels(_veh)
				funcs.doo.veh_upgr_lights(_veh,"random")
				funcs.doo.veh_upgr_neons(_veh,"random")
				funcs.doo.veh_upgr_paint(_veh,"random")
				funcs.doo.veh_upgr_livery(_veh)
				funcs.doo.veh_weap_best(_veh)
				funcs.doo.veh_upgr_bombs(_veh)
				funcs.doo.veh_upgr_cntrmsrs(_veh)
			else
				funcs.doo.veh_upgr_perf(_veh)
			end
		end
		if g.tbl.spwn.spwn_f1.on then
			funcs.doo.veh_upgr_wheels(_veh,"f1")
		end
		API.ent.set.max_speed(_veh, 45000)
		API.veh.set.top_speed(_veh, (g.tbl.spwn.spwn_spd_tq.value/100 - 1) * 100)
		if g.tbl.spwn.paint_list.rand_paint.on then
			if g.tbl.spwn.paint_list.rand_paint.value == 0 then
				funcs.doo.veh_upgr_paint(_veh,"random")
			elseif g.tbl.spwn.paint_list.rand_paint.value == 1 then
				funcs.doo.veh_upgr_paint(_veh,"random_solid")
			elseif g.tbl.spwn.paint_list.rand_paint.value == 2 then
				funcs.doo.veh_upgr_paint(_veh,funcs.get.rand_paint_shade("Dark"))
			else
				funcs.doo.veh_upgr_paint(_veh,funcs.get.rand_paint_shade("Bright"))
			end
		elseif g.tbl.spwn.paint_list.cust_paint.on then
			funcs.doo.veh_upgr_paint(_veh,(g.tbl.spwn.spwn_cust_paint_r.value * 65536 + g.tbl.spwn.spwn_cust_paint_g.value * 256 + g.tbl.spwn.spwn_cust_paint_b.value))
		else
			funcs.doo.veh_upgr_paint(_veh,g.tbl.spwn.paint_list_slct)
		end
		if g.tbl.spwn.neon.choose.value == 0 then
			funcs.doo.veh_upgr_neons(_veh,"random")
		else
			funcs.doo.veh_upgr_neons(_veh,g.tbl.spwn.neon_slct)
		end
		if g.tbl.spwn.h_light.choose.value == 0 then
			funcs.doo.veh_upgr_lights(_veh,"random")
		else
			funcs.doo.veh_upgr_lights(_veh,g.tbl.spwn.h_light_slct)
		end
		if g.tbl.spwn.spwn_max_tint.on then
			vehicle.set_vehicle_window_tint(_veh,1)
		end
		if g.tbl.spwn.spwn_invcn_wind.on then
			ntv.set.veh_invncbl_wndws(_veh,1)
		end
		if g.tbl.spwn.spwn_in_veh.on then
			API.Ped.set.into_veh(API.plyr.get.ped(API.plyr.my_id()),_veh,-1)
		end
		if g.tbl.spwn.spwn_plate_i.on then
			API.veh.set.plate_index(_veh, g.tbl.spwn.spwn_plate_i.value)
		end
		if g.tbl.spwn.spwn_plate.on then
			API.veh.set.plate_text(_veh, g.tbl.spwn.spwn_plate_txt )
		end
		YIELD(0)
		if g.tbl.spwn.remove_old.on and funcs.is.ent(g.tbl.spwn.old_veh) then
			funcs.doo.kick_all_from_veh(g.tbl.spwn.old_veh,false)
			funcs.doo.remove_ent(g.tbl.spwn.old_veh,1000)
		end
		g.tbl.spwn.old_veh=_veh
		g.tbl.spwn.history[#g.tbl.spwn.history+1]=_veh
	end
end

g.tbl.spwn.optns_prnt=menu_add_feature("Options", "parent", g.prnt.spawn.id)

g.tbl.spwn.mk_mdl_clss_prnt=menu_add_feature("All vehicles by type", "parent", g.prnt.spawn.id)
g.tbl.spwn.temp_list_sort = {}
for i=1,#veh_stuff.class_list do
	g.tbl.spwn.temp_list_sort[i]={}
	for ii=1,#veh_stuff.master do
		if veh_stuff.master[ii][6] == veh_stuff.class_list[i] then
			g.tbl.spwn.temp_list_sort[i][#g.tbl.spwn.temp_list_sort[i]+1]=veh_stuff.master[ii]
		end
	end
	table.sort(g.tbl.spwn.temp_list_sort[i], function(a, b) return a[1]:lower() <  b[1]:lower() end)
end
for i=1,#veh_stuff.class_list do
	g.tbl.spwn.feat_srch_table[#g.tbl.spwn.feat_srch_table+1] = menu_add_feature(veh_stuff.class_list[i], "parent",g.tbl.spwn.mk_mdl_clss_prnt.id)
	for ii=1,#g.tbl.spwn.temp_list_sort[i] do
		g.tbl.spwn.temp_list_name = ""
		if g.tbl.spwn.temp_list_sort[i][ii][2] == "" then
			g.tbl.spwn.temp_list_name = g.tbl.spwn.temp_list_sort[i][ii][1]
		else
			g.tbl.spwn.temp_list_name = g.tbl.spwn.temp_list_sort[i][ii][1].." - "..g.tbl.spwn.temp_list_sort[i][ii][2]
		end
		og_menu_add_feature(g.tbl.spwn.temp_list_name, "action", g.tbl.spwn.feat_srch_table[i].id,function()
			if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
				API.ent.set.no_need(g.tbl.spwn.old_veh)
				API.ent.delete(g.tbl.spwn.old_veh)
			end
			funcs.doo.req_model(g.tbl.spwn.temp_list_sort[i][ii][5])
			local veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),g.tbl.spwn.temp_list_sort[i][ii][5],false,g.tbl.spwn.spwn_front.value==0)
			g.tbl.spwn.apply_upgrades(veh)
		end)
	end
end
g.tbl.spwn.mk_mdl_srch_prnt=menu_add_feature("Make/Model search list", "parent", g.prnt.spawn.id)

g.tbl.spwn.quick_spwn_prnt=menu_add_feature("Quick spawn list", "parent", g.prnt.spawn.id)

g.tbl.spwn.quick_spawn_feats = {}

menu_add_feature("Quick search on-screen", "action", g.prnt.spawn.id, function(f)
	g.tbl.spwn.quick_start(g.tbl.spwn.qck_srch_table,"Vehicle Spawn - Self",false)
end)

g.tbl.spwn.mk_mdl_search_feat = {}
g.tbl.spwn.mk_mdl_search_temp = {}
g.tbl.spwn.inpt_srch=menu_add_feature("Search for vehicles", "action_value_str", g.tbl.spwn.mk_mdl_srch_prnt.id, function(f)
	local status,str,veh = 1
	status,str = funcs.get.text_input("Vehicle Make/Model","",25,0)
	if status == 0 then
		g.tbl.spwn.mk_mdl_search_temp = {}
		g.tbl.spwn.ovrly_srch_do(str,f.value,g.tbl.spwn.mk_mdl_search_temp)
		if #g.tbl.spwn.mk_mdl_search_temp > 0 then
			for i=1,#g.tbl.spwn.mk_mdl_search_feat do
				YIELD(0)
				if g.tbl.spwn.mk_mdl_search_feat[i] ~= nil then menu.delete_feature(g.tbl.spwn.mk_mdl_search_feat[i].id) end
			end
			g.tbl.spwn.mk_mdl_search_feat = {}
			for i=1,#g.tbl.spwn.mk_mdl_search_temp do
				if f.value == 0 then
					g.tbl.spwn.mk_mdl_search_feat[#g.tbl.spwn.mk_mdl_search_feat+1]=menu_add_feature(g.tbl.spwn.mk_mdl_search_temp[i][1], "action", g.tbl.spwn.mk_mdl_srch_prnt.id,function()
						if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
							API.ent.set.no_need(g.tbl.spwn.old_veh)
							API.ent.delete(g.tbl.spwn.old_veh)
						end
						funcs.doo.req_model(g.tbl.spwn.mk_mdl_search_temp[i][5])
						local veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),g.tbl.spwn.mk_mdl_search_temp[i][5],false,g.tbl.spwn.spwn_front.value==0)
						g.tbl.spwn.apply_upgrades(veh)
					end)
				else
					g.tbl.spwn.mk_mdl_search_feat[#g.tbl.spwn.mk_mdl_search_feat+1]=menu_add_feature(g.tbl.spwn.mk_mdl_search_temp[i][3], "action", g.tbl.spwn.mk_mdl_srch_prnt.id,function()
						if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
							API.ent.set.no_need(g.tbl.spwn.old_veh)
							API.ent.delete(g.tbl.spwn.old_veh)
						end
						funcs.doo.req_model(g.tbl.spwn.mk_mdl_search_temp[i][5])
						local veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),g.tbl.spwn.mk_mdl_search_temp[i][5],false,g.tbl.spwn.spwn_front.value==0)
						g.tbl.spwn.apply_upgrades(veh)
					end)
				end
			end
		end
	end
end)
new_set_str_data(g.tbl.spwn.inpt_srch,{"Model", "Make","Make or Model"})

g.tbl.spwn.qck_srch_optns = menu_add_feature("Quick Search Options", "parent", g.tbl.spwn.optns_prnt.id)

menu_add_feature("Display 'quick search' test", "action", g.tbl.spwn.qck_srch_optns.id, function()
	local time = TIME_MS() + 10000
	local _table = {}
	for i=1,7 do
		_table[i] = veh_stuff.master[mth.rndm(1,#veh_stuff.master)]
	end
	while time > TIME_MS() do
		YIELD(0)
		g.tbl.spwn.ovrly_srch_show(_table, "Vehicle test - Self "..funcs.get.round_num((time - TIME_MS())/1000),0,g.tbl.spwn.qck_srch_optns_x.value/300, g.tbl.spwn.qck_srch_optns_y.value/300,false)
	end
end)

g.tbl.spwn.qck_srch_optns_x = menu_add_feature("Quick search X Pos", "action_slider", g.tbl.spwn.qck_srch_optns.id)
funcs.set_feat_i_f(g.tbl.spwn.qck_srch_optns_x,0,300,1,150,"g.tbl.spwn.qck_srch_optns_x")

g.tbl.spwn.qck_srch_optns_y = menu_add_feature("Quick search Y Pos", "action_slider", g.tbl.spwn.qck_srch_optns.id, function()
end)funcs.set_feat_i_f(g.tbl.spwn.qck_srch_optns_y,0,300,1,135,"g.tbl.spwn.qck_srch_optns_y")

g.tbl.spwn.spwn_in_veh = menu_add_feature("Spawn in vehicle", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.spwn_in_veh,"g.tbl.spwn.spwn_in_veh")

g.tbl.spwn.spwn_upg = menu_add_feature("Upgrades", "value_str", g.tbl.spwn.optns_prnt.id)
new_set_str_data(g.tbl.spwn.spwn_upg,{"All","Only performance"})
funcs.add_to_S_L(g.tbl.spwn.spwn_upg,"g.tbl.spwn.spwn_upg")
g.tbl.spwn.spwn_upg.on=true

g.tbl.spwn.spwn_f1 = menu_add_feature("Always F1 Wheels", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.spwn_f1,"g.tbl.spwn.spwn_f1")

g.tbl.spwn.spwn_god = menu_add_feature("God-Mode", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.spwn_god,"g.tbl.spwn.spwn_god")

g.tbl.spwn.spwn_max_tint = menu_add_feature("Max tint", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.spwn_max_tint,"g.tbl.spwn.spwn_max_tint")

g.tbl.spwn.spwn_invcn_wind = menu_add_feature("Invincible windows", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.spwn_invcn_wind,"g.tbl.spwn.spwn_invcn_wind")

g.tbl.spwn.spwn_plate_i=menu_add_feature("Plate color", "value_str", g.tbl.spwn.optns_prnt.id)
new_set_str_data(g.tbl.spwn.spwn_plate_i,{"Blue/White","Yellow/black","Yellow/Blue","Blue/White2","Blue/White3","Yankton"})
funcs.add_to_S_L(g.tbl.spwn.spwn_plate_i,"g.tbl.spwn.spwn_plate_i")
g.tbl.spwn.spwn_plate_i.value=1
g.tbl.spwn.spwn_plate_i.on=true

g.tbl.spwn.spwn_plate = menu_add_feature("Plate text - "..g.tbl.spwn.spwn_plate_txt, "toggle", g.tbl.spwn.optns_prnt.id,function(f)
	if f.on and g.var.GS_has_loaded then
		local status,str = 1,""
		status,str = funcs.get.text_input("Non alpha-numeric characters act as blank space",g.tbl.spwn.spwn_plate_txt,8,0)
		if status == 0 then
			g.tbl.spwn.spwn_plate_check("Self Vehicle Spawn")
			g.tbl.spwn.spwn_plate_write(str,"Self Vehicle Spawn")
			g.tbl.spwn.spwn_plate_txt=str
			f.name="Plate text - "..g.tbl.spwn.spwn_plate_txt
		else
			f.on=false
		end
	end
end)
funcs.add_to_S_L(g.tbl.spwn.spwn_plate,"g.tbl.spwn.spwn_plate")
g.tbl.spwn.spwn_plate.on=true

g.tbl.spwn.remove_old = menu_add_feature("Remove previous vehicle", "toggle", g.tbl.spwn.optns_prnt.id)
funcs.add_to_S_L(g.tbl.spwn.remove_old,"g.tbl.spwn.remove_old")

g.tbl.spwn.spwn_front=menu_add_feature("Spawn using heading of my: ", "action_value_str", g.tbl.spwn.optns_prnt.id)
new_set_str_data(g.tbl.spwn.spwn_front,{"Cam","Ped"})
funcs.add_to_S_L(g.tbl.spwn.spwn_front,"g.tbl.spwn.spwn_front")

g.tbl.spwn.spwn_spd_tq=menu_add_feature("Vehicle max speed/torque %","action_value_i", g.tbl.spwn.optns_prnt.id)
funcs.set_feat_i_f(g.tbl.spwn.spwn_spd_tq,0,700,5,100,"g.tbl.spwn.spwn_spd_tq")

----------------------------------------------------------------------------------------------------------------------------------------------aaa
g.tbl.spwn.paint_prnts_new = {}
g.tbl.spwn.paint_list_slct = nil
g.tbl.spwn.paint_list={}
g.tbl.spwn.paint_prnt = menu_add_feature("Paint", "parent", g.tbl.spwn.optns_prnt.id)

function g.tbl.spwn.paint_tog_do(_bool,_feat,_paint)
	if _bool then
		if _paint then
			g.tbl.spwn.paint_list_slct =_paint
		end
		for _, feat in pairs(g.tbl.spwn.paint_list) do
			if feat ~=_feat then
				feat.on = false
			end
		end
	else
		local is_one_on = false
		for _, feat in pairs(g.tbl.spwn.paint_list) do
			if feat.on then
				is_one_on=true
				break
			end
		end
		if not is_one_on then
			g.tbl.spwn.paint_list.rand_paint.on=true
		end
	end
end



g.tbl.spwn.paint_list.rand_paint = menu_add_feature("Random paint", "value_str", g.tbl.spwn.paint_prnt.id,function(f)
	g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.rand_paint,nil)
end)
new_set_str_data(g.tbl.spwn.paint_list.rand_paint,{"Non-matching", "Matching","Dark","Bright"})
funcs.add_to_S_L(g.tbl.spwn.paint_list.rand_paint,"g.tbl.spwn.paint_list.rand_paint")
g.tbl.spwn.paint_list.rand_paint.on=true

g.tbl.spwn.paint_list.cust_paint = menu_add_feature("Custom paint", "toggle", g.tbl.spwn.paint_prnt.id,function(f)
	g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.cust_paint,nil)
end)
funcs.add_to_S_L(g.tbl.spwn.paint_list.cust_paint,"g.tbl.spwn.paint_list.cust_paint")

g.tbl.spwn.spwn_cust_paint_r=menu_add_feature("Custom Red","autoaction_value_i",g.tbl.spwn.paint_prnt.id)
funcs.set_feat_i_f(g.tbl.spwn.spwn_cust_paint_r,0,255,1,0,"g.tbl.spwn.spwn_cust_paint_r")

g.tbl.spwn.spwn_cust_paint_g=menu_add_feature("Custom Green","autoaction_value_i",g.tbl.spwn.paint_prnt.id)
funcs.set_feat_i_f(g.tbl.spwn.spwn_cust_paint_g,0,255,1,0,"g.tbl.spwn.spwn_cust_paint_g")

g.tbl.spwn.spwn_cust_paint_b=menu_add_feature("Custom Blue","autoaction_value_i",g.tbl.spwn.paint_prnt.id)
funcs.set_feat_i_f(g.tbl.spwn.spwn_cust_paint_b,0,255,1,0,"g.tbl.spwn.spwn_cust_paint_b")

for k,v in ipairs (g.tbl.paints2) do
	local t = paints[v]
	if type(t) == "table" then
		g.tbl.spwn.paint_prnts_new[v]=menu_add_feature(v,"parent",g.tbl.spwn.paint_prnt.id)
		for kk,vv in ipairs (t) do
			local str = v.."|"..vv.NAME
			g.tbl.spwn.paint_list[str]=og_menu_add_feature(vv.NAME_IN_COLOR,"toggle",g.tbl.spwn.paint_prnts_new[v].id,function(f)
				g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list[str],vv.INT)
			end)
			funcs.add_to_S_L(g.tbl.spwn.paint_list[str],"g.tbl.spwn.paint_list."..str)
		end
	end
end



-- g.tbl.spwn.paint_list.pnt_Purewhite=menu_add_feature("Pure white","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Purewhite,16777215)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Purewhite,"g.tbl.spwn.paint_list.pnt_Purewhite")

-- g.tbl.spwn.paint_list.pnt_White=menu_add_feature("White","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_White,13487565)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_White,"g.tbl.spwn.paint_list.pnt_White")

-- g.tbl.spwn.paint_list.pnt_Cream=menu_add_feature("Cream","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Cream,10197915)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Cream,"g.tbl.spwn.paint_list.pnt_Cream")

-- g.tbl.spwn.paint_list.pnt_Grey=menu_add_feature("Grey","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Grey,5066061)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Grey,"g.tbl.spwn.paint_list.pnt_Grey")

-- g.tbl.spwn.paint_list.pnt_Black=menu_add_feature("Black","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Black,0)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Black,"g.tbl.spwn.paint_list.pnt_Black")

-- g.tbl.spwn.paint_list.pnt_PastelPink=menu_add_feature("Pastel Pink","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_PastelPink,15767961)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_PastelPink,"g.tbl.spwn.paint_list.pnt_PastelPink")

-- g.tbl.spwn.paint_list.pnt_Pink=menu_add_feature("Pink","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Pink,13317780)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Pink,"g.tbl.spwn.paint_list.pnt_Pink")

-- g.tbl.spwn.paint_list.pnt_PinkRed=menu_add_feature("Pink/Red","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_PinkRed,14692914)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_PinkRed,"g.tbl.spwn.paint_list.pnt_PinkRed")

-- g.tbl.spwn.paint_list.pnt_WineRed=menu_add_feature("Wine Red","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_WineRed,3014656)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_WineRed,"g.tbl.spwn.paint_list.pnt_WineRed")

-- g.tbl.spwn.paint_list.pnt_Red=menu_add_feature("Red","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Red,7346457)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Red,"g.tbl.spwn.paint_list.pnt_Red")

-- g.tbl.spwn.paint_list.pnt_BrightRed=menu_add_feature("Bright Red","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_BrightRed,16711680)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_BrightRed,"g.tbl.spwn.paint_list.pnt_BrightRed")

-- g.tbl.spwn.paint_list.pnt_Salmon=menu_add_feature("Salmon","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Salmon,16761514)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Salmon,"g.tbl.spwn.paint_list.pnt_Salmon")

-- g.tbl.spwn.paint_list.pnt_BrightBlue=menu_add_feature("Bright Blue","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_BrightBlue,56306)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_BrightBlue,"g.tbl.spwn.paint_list.pnt_BrightBlue")

-- g.tbl.spwn.paint_list.pnt_LightBlue=menu_add_feature("Light Blue","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_LightBlue,6141669)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_LightBlue,"g.tbl.spwn.paint_list.pnt_LightBlue")

-- g.tbl.spwn.paint_list.pnt_Teal=menu_add_feature("Teal","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Teal,3103859)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Teal,"g.tbl.spwn.paint_list.pnt_Teal")

-- g.tbl.spwn.paint_list.pnt_RoyalBlue=menu_add_feature("Royal Blue","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_RoyalBlue,18309)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_RoyalBlue,"g.tbl.spwn.paint_list.pnt_RoyalBlue")

-- g.tbl.spwn.paint_list.pnt_CreamYellow=menu_add_feature("Cream Yellow","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_CreamYellow,16706473)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_CreamYellow,"g.tbl.spwn.paint_list.pnt_CreamYellow")

-- g.tbl.spwn.paint_list.pnt_Yellow=menu_add_feature("Yellow","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Yellow,15779920)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Yellow,"g.tbl.spwn.paint_list.pnt_Yellow")

-- g.tbl.spwn.paint_list.pnt_Mustard=menu_add_feature("Mustard","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Mustard,8284969)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Mustard,"g.tbl.spwn.paint_list.pnt_Mustard")

-- g.tbl.spwn.paint_list.pnt_Brightyellow=menu_add_feature("Bright yellow","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Brightyellow,16757504)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Brightyellow,"g.tbl.spwn.paint_list.pnt_Brightyellow")

-- g.tbl.spwn.paint_list.pnt_Schoolbus=menu_add_feature("Schoolbus","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_Schoolbus,16750350)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_Schoolbus,"g.tbl.spwn.paint_list.pnt_Schoolbus")

-- g.tbl.spwn.paint_list.pnt_DarkOrange=menu_add_feature("Dark Orange","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_DarkOrange,8340010)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_DarkOrange,"g.tbl.spwn.paint_list.pnt_DarkOrange")

-- g.tbl.spwn.paint_list.pnt_CreamGreen=menu_add_feature("Cream Green","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_CreamGreen,12183225)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_CreamGreen,"g.tbl.spwn.paint_list.pnt_CreamGreen")

-- g.tbl.spwn.paint_list.pnt_LightGreen=menu_add_feature("Light Green","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_LightGreen,7523442)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_LightGreen,"g.tbl.spwn.paint_list.pnt_LightGreen")

-- g.tbl.spwn.paint_list.pnt_BrightGreen=menu_add_feature("Bright Green","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_BrightGreen,2803792)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_BrightGreen,"g.tbl.spwn.paint_list.pnt_BrightGreen")

-- g.tbl.spwn.paint_list.pnt_DarkGreen=menu_add_feature("Dark Green","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_DarkGreen,3761721)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_DarkGreen,"g.tbl.spwn.paint_list.pnt_DarkGreen")

-- g.tbl.spwn.paint_list.pnt_CreamPurple=menu_add_feature("Cream Purple","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_CreamPurple,12628975)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_CreamPurple,"g.tbl.spwn.paint_list.pnt_CreamPurple")

-- g.tbl.spwn.paint_list.pnt_BrightPurple=menu_add_feature("Bright Purple","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_BrightPurple,8677090)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_BrightPurple,"g.tbl.spwn.paint_list.pnt_BrightPurple")

-- g.tbl.spwn.paint_list.pnt_DarkPurple=menu_add_feature("Dark Purple","toggle",g.tbl.spwn.paint_prnt.id,function(f)
	-- g.tbl.spwn.paint_tog_do(f.on,g.tbl.spwn.paint_list.pnt_DarkPurple,4405615)
-- end)
-- funcs.add_to_S_L(g.tbl.spwn.paint_list.pnt_DarkPurple,"g.tbl.spwn.paint_list.pnt_DarkPurple")

-- g.tbl.spwn.paint_list.pnt_DarkGreen.on=true

g.tbl.spwn.neon = {}
g.tbl.spwn.neon.list={}
g.tbl.spwn.neon_slct=nil
function g.tbl.spwn.neon_tog_do(_bool,_feat,_neon)
	if _bool then
		g.tbl.spwn.neon_slct=_neon
		for _, feat in pairs(g.tbl.spwn.neon.list) do
			if feat ~=_feat then
				feat.on = false
			end
		end
	end
end

function g.tbl.spwn.hide_neon(_bool)
	YIELD(0)
	if _bool then
		for _, feat in pairs (g.tbl.spwn.neon.list) do
			feat.hidden=(g.tbl.spwn.neon.choose.value==0)
		end
	end
end

g.tbl.spwn.neon.prnt = menu_add_feature("Neon lights", "parent", g.tbl.spwn.optns_prnt.id, function (f)
	g.tbl.spwn.hide_neon(g.tbl.spwn.neon.choose.value==0)
end)


g.tbl.spwn.neon.choose=menu_add_feature("Neon color","autoaction_value_str",g.tbl.spwn.neon.prnt.id,function(f)
	g.tbl.spwn.hide_neon(true)
end)
new_set_str_data(g.tbl.spwn.neon.choose,{"Random","List"})
funcs.add_to_S_L(g.tbl.spwn.neon.choose,"g.tbl.spwn.neon.choose")

g.tbl.spwn.neon.list.White=menu_add_feature("White", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.White,4292796159)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.White,"g.tbl.spwn.neon.list.White")

g.tbl.spwn.neon.list.Blue=menu_add_feature("Blue", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.Blue,4278326783)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.Blue,"g.tbl.spwn.neon.list.Blue")

g.tbl.spwn.neon.list.ElectricBlue=menu_add_feature("Electric Blue", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.ElectricBlue,4278408191)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.ElectricBlue,"g.tbl.spwn.neon.list.ElectricBlue")

g.tbl.spwn.neon.list.MintGreen=menu_add_feature("Mint Green", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.MintGreen,4278255500)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.MintGreen,"g.tbl.spwn.neon.list.MintGreen")

g.tbl.spwn.neon.list.LimeGreen=menu_add_feature("Lime Green", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.LimeGreen,4284415745)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.LimeGreen,"g.tbl.spwn.neon.list.LimeGreen")

g.tbl.spwn.neon.list.Yellow=menu_add_feature("Yellow", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.Yellow,4294967040)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.Yellow,"g.tbl.spwn.neon.list.Yellow")

g.tbl.spwn.neon.list.GoldenShower=menu_add_feature("Golden Shower", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.GoldenShower,4294940165)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.GoldenShower,"g.tbl.spwn.neon.list.GoldenShower")

g.tbl.spwn.neon.list.Orange=menu_add_feature("Orange", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.Orange,4294917632)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.Orange,"g.tbl.spwn.neon.list.Orange")

g.tbl.spwn.neon.list.Red=menu_add_feature("Red", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.Red,4294902017)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.Red,"g.tbl.spwn.neon.list.Red")

g.tbl.spwn.neon.list.PonyPink=menu_add_feature("Pony Pink", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.PonyPink,4294914660)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.PonyPink,"g.tbl.spwn.neon.list.PonyPink")

g.tbl.spwn.neon.list.HotPink=menu_add_feature("Hot Pink", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.HotPink,4294903230)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.HotPink,"g.tbl.spwn.neon.list.HotPink")

g.tbl.spwn.neon.list.Purple=menu_add_feature("Purple", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.Purple,4280484351)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.Purple,"g.tbl.spwn.neon.list.Purple")

g.tbl.spwn.neon.list.BlackLight=menu_add_feature("Black Light", "toggle", g.tbl.spwn.neon.prnt.id, function (f)
	g.tbl.spwn.neon_tog_do(f.on,g.tbl.spwn.neon.list.BlackLight,4279174143)
end)
funcs.add_to_S_L(g.tbl.spwn.neon.list.BlackLight,"g.tbl.spwn.neon.list.BlackLight")

g.tbl.spwn.neon.list.MintGreen.on=true

g.tbl.spwn.h_light={}
g.tbl.spwn.h_light.list={}
g.tbl.spwn.h_light_slct=nil

function g.tbl.spwn.h_light_tog_do(_bool,_feat,_h_light)
	if _bool then
		g.tbl.spwn.h_light_slct=_h_light
		for _, feat in pairs(g.tbl.spwn.h_light.list) do
			if feat ~=_feat then
				feat.on = false
			end
		end
	end
end

function g.tbl.spwn.hide_h_light(_bool)
	YIELD(0)
	if _bool then
		for _, feat in pairs(g.tbl.spwn.h_light.list) do
			feat.hidden=(g.tbl.spwn.h_light.choose.value==0)
		end
	end
end

g.tbl.spwn.h_light.prnt = menu_add_feature("Headlights", "parent", g.tbl.spwn.optns_prnt.id, function (f)
	g.tbl.spwn.hide_h_light(g.tbl.spwn.h_light.choose.value==0)
end)


g.tbl.spwn.h_light.choose=menu_add_feature("Headlight color","autoaction_value_str",g.tbl.spwn.h_light.prnt.id,function(f)
	g.tbl.spwn.hide_h_light(true)
end)
new_set_str_data(g.tbl.spwn.h_light.choose,{"Random","List"})
funcs.add_to_S_L(g.tbl.spwn.h_light.choose,"g.tbl.spwn.h_light.choose")

g.tbl.spwn.h_light.list.White=menu_add_feature("White", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.White,0)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.White,"g.tbl.spwn.h_light.list.White")

g.tbl.spwn.h_light.list.Blue=menu_add_feature("Blue", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.Blue,1)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.Blue,"g.tbl.spwn.h_light.list.Blue")

g.tbl.spwn.h_light.list.ElectricBlue=menu_add_feature("Electric Blue", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.ElectricBlue,2)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.ElectricBlue,"g.tbl.spwn.h_light.list.ElectricBlue")

g.tbl.spwn.h_light.list.MintGreen=menu_add_feature("Mint Green", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.MintGreen,3)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.MintGreen,"g.tbl.spwn.h_light.list.MintGreen")

g.tbl.spwn.h_light.list.LimeGreen=menu_add_feature("Lime Green", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.LimeGreen,4)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.LimeGreen,"g.tbl.spwn.h_light.list.LimeGreen")

g.tbl.spwn.h_light.list.Yellow=menu_add_feature("Yellow", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.Yellow,5)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.Yellow,"g.tbl.spwn.h_light.list.Yellow")

g.tbl.spwn.h_light.list.GoldenShower=menu_add_feature("Golden Shower", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.GoldenShower,6)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.GoldenShower,"g.tbl.spwn.h_light.list.GoldenShower")

g.tbl.spwn.h_light.list.Orange=menu_add_feature("Orange", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.Orange,7)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.Orange,"g.tbl.spwn.h_light.list.Orange")

g.tbl.spwn.h_light.list.Red=menu_add_feature("Red", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.Red,8)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.Red,"g.tbl.spwn.h_light.list.Red")

g.tbl.spwn.h_light.list.PonyPink=menu_add_feature("Pony Pink", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.PonyPink,9)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.PonyPink,"g.tbl.spwn.h_light.list.PonyPink")

g.tbl.spwn.h_light.list.HotPink=menu_add_feature("Hot Pink", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.HotPink,10)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.HotPink,"g.tbl.spwn.h_light.list.HotPink")

g.tbl.spwn.h_light.list.Purple=menu_add_feature("Purple", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.Purple,11)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.Purple,"g.tbl.spwn.h_light.list.Purple")

g.tbl.spwn.h_light.list.BlackLight=menu_add_feature("Black Light", "toggle", g.tbl.spwn.h_light.prnt.id, function (f)
	g.tbl.spwn.h_light_tog_do(f.on,g.tbl.spwn.h_light.list.BlackLight,12)
end)
funcs.add_to_S_L(g.tbl.spwn.h_light.list.BlackLight,"g.tbl.spwn.h_light.list.BlackLight")

g.tbl.spwn.h_light.list.MintGreen.on=true

function g.tbl.spwn.ovrly_srch_do(_str,_type,_table)
	for i=1,#veh_stuff.master do
		if #_table < 50 then
			if _type == 0 then
				if string.match(string.lower(veh_stuff.master[i][1]), string.lower(_str)) ~= nil then
					_table[#_table+1]= veh_stuff.master[i]
				end
			elseif _type == 1 then
				if string.match(string.lower(veh_stuff.master[i][2]), string.lower(_str)) ~= nil then
					_table[#_table+1]= veh_stuff.master[i]
				end
			elseif string.match(string.lower(veh_stuff.master[i][3]), string.lower(_str)) ~= nil then
				_table[#_table+1]= veh_stuff.master[i]
			end
		end
	end
	if #_table > 1 then
		if _type == 0 then
			table.sort(_table, function(a, b) return a[1]:lower() <  b[1]:lower() end)
		else
			table.sort(_table, function(a, b) return a[3]:lower() <  b[3]:lower() end)
		end
	end
end

function g.tbl.spwn.ovrly_srch_show(_table,_title,selection,x_val_box,y_val,_session)
	ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.0175, 0, 0, 0, 155)
	funcs.doo.overlay(_title,75,150,75,255,.2,0,x_val_box,y_val)
	y_val=y_val+0.0171
	-- if _session then
		-- ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.0175, 0, 0, 0, 155)
		-- funcs.doo.overlay(g.tbl.sssn_stf.old.veh_or_plyr_string(),75,150,75,255,.2,0,0.5,y_val)
		-- y_val=y_val+0.0171
	-- end
	for i=1, #_table do
		if i < 8 then
			ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.0175, 0, 0, 0, 155)
			if i == selection then
				ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.017, 155, 155, 155, 155)
			end
			funcs.doo.overlay_left(i.."  ".._table[i][1],255,255,255,255,.2,0,x_val_box-0.045,y_val)
			y_val=y_val+0.0171
		end
	end
end

function g.tbl.spwn.quick_start(_table,_title,_session)
	local vk_1_7 = {"1","2","3","4","5","6","7",}
	local status,num_name,str,y_val,x_val_box,selection,name,veh = 1,"",""
	local search,key_time=true,TIME_MS()
	_table = {}
	status, str = funcs.get.text_input(_title,"",25,0)
	local function key_press(_key)
		if TIME_MS() > key_time and funcs.is.vk_key_down(_key) then
			key_time = TIME_MS() + 100
			return true
		end
		return false
	end
	if status == 0 then
		g.tbl.spwn.ovrly_srch_do(str,0,_table)
		if #_table > 0 then
			for i=1, #_table do
				if i > 7 then _table[i]=nil end
			end
			selection = 1
			if _session then
				y_val = g.tbl.sssn_stf.new.quick_y.value/300
				x_val_box = g.tbl.sssn_stf.new.quick_x.value/300
			else
				y_val = g.tbl.spwn.qck_srch_optns_y.value/300
				x_val_box = g.tbl.spwn.qck_srch_optns_x.value/300
			end
			while search do
				YIELD(0)
				ntv.doo.hide_weapon_wheel_from_mouse()
				g.tbl.spwn.ovrly_srch_show(_table,_title,selection,x_val_box,y_val,_session)
				if funcs.is.key_active(14,1) or API.cntrl.is.just_pressed(1, 187) or key_press("S") then
					if _table[selection+1] ~= nil then selection = selection+1
					else selection = 1
					end
				elseif funcs.is.key_active(15,1) or API.cntrl.is.just_pressed(1, 188) or key_press("W") then
					if _table[selection-1] ~= nil then selection = selection-1
					else selection = #_table
					end
				end
				for i=1,#vk_1_7 do
					if funcs.is.vk_key_down(vk_1_7[i]) and _table[i] ~= nil then
						if _session then
							funcs.doo.sssn_spawn_vehs(_table[i][5])
						else
							if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
								API.ent.set.no_need(g.tbl.spwn.old_veh)
								API.ent.delete(g.tbl.spwn.old_veh)
							end
							funcs.doo.req_model(_table[i][5])
							veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),_table[i][5],false,g.tbl.spwn.spwn_front.value==0)
							g.tbl.spwn.apply_upgrades(veh)
						end
						search = false
						break
					end
				end
				if funcs.is.vk_key_down("RETURN") then
					if _session then
						funcs.doo.sssn_spawn_vehs(_table[selection][5])
					else
						if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
							API.ent.set.no_need(g.tbl.spwn.old_veh)
							API.ent.delete(g.tbl.spwn.old_veh)
						end
						funcs.doo.req_model(_table[selection][5])
						veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),_table[selection][5],false,g.tbl.spwn.spwn_front.value==0)
						g.tbl.spwn.apply_upgrades(veh)
					end
					search = false
				elseif funcs.is.vk_key_down("ESCAPE") then
					search = false
				end
			end
		end
	end
end
----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------


g.tbl.plate_anim={}
g.tbl.plate_anim.list_feat = {}
g.tbl.plate_anim.index=nil
g.tbl.plate_anim.plate=nil
g.tbl.plate_anim.my_veh=nil
g.tbl.plate_anim.plyr_delay=false
g.tbl.plate_anim.plate_delay=false
g.tbl.plate_anim.directory = g.paths._user.."\\Vehicle License Plate\\"
g.tbl.plate_anim.list_optns = menu_add_feature("String list options", "parent", g.prnt.self_veh_crrnt_plate.id)
g.tbl.plate_anim.list_prnt=menu_add_feature("String list", "parent", g.tbl.plate_anim.list_optns.id)

g.tbl.plate_anim.str_scrl={}
g.tbl.plate_anim.str_scrl.new_dly=false
g.tbl.plate_anim.str_scrl.new_txt=false
g.tbl.plate_anim.str_scrl.optns = menu_add_feature("String scroll options", "parent", g.prnt.self_veh_crrnt_plate.id, function()
	g.tbl.plate_anim.str_scrl.updt_name()
end)

function g.tbl.plate_anim.str_scrl.updt_name()
	g.tbl.plate_anim.str_scrl.check()
	local text,name = g.tbl.plate_anim.str_scrl.text(),"Update text"
	for i=1,31 do
		if i == 31 then
			name = string.sub(text,1,30)
		elseif string.len(text) == i then
			name = string.sub(text,1,i)
			break
		end
	end
	if string.len(name) >= 30 then
		name=name.."..."
	end
	g.tbl.plate_anim.str_scrl.update.name = name
end

g.tbl.plate_anim.spdo={}
g._Disp_Cust_Plate_Speedo = menu_add_feature("Speedometer options", "parent", g.prnt.self_veh_crrnt_plate.id, function()
	g.tbl.plate_anim.spdo.dick_lngth.hidden=(g.tbl.plate_anim.spdo.type.value~=2)
end)

g.tbl.plate_anim.plyr={}
g.tbl.plate_anim.plyr.name=""
g.tbl.plate_anim.plyr.dist=10000
g._Disp_Cust_Plate_Plyr = menu_add_feature("Closest player options", "parent", g.prnt.self_veh_crrnt_plate.id, function()
	g.tbl.plate_anim.plyr.dist_type.hidden=(not g.tbl.plate_anim.plyr.show_dist.on)
end)

g.tbl.plate_anim.wp={}
g.tbl.plate_anim.wp.blink=false
g.tbl.plate_anim.wp.blnk_new=false
g.tbl.plate_anim.wp.const=false
g.tbl.plate_anim.wp.dist=0
g.tbl.plate_anim.wp.prnt=menu_add_feature("Waypoint options", "parent", g.prnt.self_veh_crrnt_plate.id)




function g.tbl.plate_anim.file_check()
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.tbl.plate_anim.directory)
	if not utils.file_exists(g.tbl.plate_anim.directory.."String List Animation.txt") then
		g.tbl.plate_anim.file_write()
	end
end

function g.tbl.plate_anim.file_write()
	local file = io.open(g.tbl.plate_anim.directory.."String List Animation.txt", "w")
	file:write("g       \nge      \ngee     \ngeee    \ngeeee   \ngeeeee  \ngeeeeee \ngeeeeeee\n\nskid    \n    skid\nskid    \n    skid\n\ngee-skid\n\ngee-skid\n")
	file:close()
end

function g.tbl.plate_anim.file_get()
	g.tbl.plate_anim.file_check()
	::start::
	local file = io.open(g.tbl.plate_anim.directory.."String List Animation.txt", "r")
	local strings = {}
	for line in file:lines() do
		if line ~= nil and string.len(tostring(line)) < 9 then
			strings[#strings+1] = tostring(line)
		end
	end
	file:close()
	if # strings == 0 then
		g.tbl.plate_anim.file_write()
		goto start
	end
	return strings
end

g.tbl.plate_anim.plate_refresh=false
function g.tbl.plate_anim.do_text(val,last,first,index,add)
	local status,str,continue = 1,"",false
	if val == 0 or add then
		status,str = funcs.get.text_input("Non alpha-numeric characters act as blank space","",8,0)
	end
	if add then
		if status == 0 then
			continue = true
		end
	elseif val ~= 0 or status == 0 then
		continue=true
	end
	if continue then
		local _table={}
		if add then
			if val == 4 then
				for i=1,#g.tbl.plate_anim.strings do
					if i < index then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					elseif i == index then
						_table[#_table+1]=str
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					else
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					end
				end
			else
				if val == 0 then
					_table[#_table+1]=str
				end
				for i=1,#g.tbl.plate_anim.strings do
					_table[#_table+1]=g.tbl.plate_anim.strings[i]
				end
				if val == 1 then
					_table[#_table+1]=str
				end
			end
		elseif val == 0 or val == 1 then
			for i=1,#g.tbl.plate_anim.strings do
				if val == 0 then
					if i == index then
						_table[#_table+1]=str
					else
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					end
				else
					if i ~= index then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					end
				end
			end
		else
			if val == 3 and last then
				_table[#_table+1]=g.tbl.plate_anim.strings[index]
			end
			for i=1,#g.tbl.plate_anim.strings do
				if val == 2 then
					if first then
						if i ~= index then
							_table[#_table+1]=g.tbl.plate_anim.strings[i]
						end
					elseif i < index-1 then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					elseif i == index-1 then
						if g.tbl.plate_anim.strings[index] ~= nil then
							_table[#_table+1]=g.tbl.plate_anim.strings[index]
						end
						if g.tbl.plate_anim.strings[index-1] ~= nil then
							_table[#_table+1]=g.tbl.plate_anim.strings[index-1]
						end
					elseif i > index then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					end
				else
					if last then
						if i ~= index then
							_table[#_table+1]=g.tbl.plate_anim.strings[i]
						end
					elseif i < index then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					elseif i == index then
						if g.tbl.plate_anim.strings[index+1] ~= nil then
							_table[#_table+1]=g.tbl.plate_anim.strings[index+1]
						end
						if g.tbl.plate_anim.strings[index] ~= nil then
							_table[#_table+1]=g.tbl.plate_anim.strings[index]
						end
					elseif i > index+1 then
						_table[#_table+1]=g.tbl.plate_anim.strings[i]
					end
				end
			end
			if val == 2 and first then
				_table[#_table+1]=g.tbl.plate_anim.strings[index]
			end
		end
		g.tbl.plate_rpr_upgr.file_check()
		local contents = ""
		for i=1,#_table do
			contents = contents.._table[i]
			if _table[i+1] ~= nil then
				contents = contents.."\n"
			end
		end
		local file = io.open(g.tbl.plate_anim.directory.."String List Animation.txt", "w")
		file:write(contents)
		file:close()
		g.tbl.plate_anim.list_delete()
		g.tbl.plate_anim.list_add()
		g.tbl.plate_anim.plate_refresh=true
	end
end

function g.tbl.plate_anim.list_delete()
	for i=1,#g.tbl.plate_anim.list_feat do
		menu.delete_feature(g.tbl.plate_anim.list_feat[i].id)
		if #g.tbl.plate_anim.list_feat % 100 == 0 then
			system.wait(0)
		end
	end
	menu.delete_feature(g.tbl.plate_anim.add_str_bttm_feat.id)
	g.tbl.plate_anim.list_feat={}
end

g.tbl.plate_anim.add_str_top_feat=menu_add_feature("Add entry to top", "action", g.tbl.plate_anim.list_prnt.id, function(f)
	g.tbl.plate_anim.do_text(0,nil,nil,nil,true)
end)

function g.tbl.plate_anim.list_add()
	g.tbl.plate_anim.strings=g.tbl.plate_anim.file_get()
	for i=1,#g.tbl.plate_anim.strings do
		local _last = (i==#g.tbl.plate_anim.strings)
		local _first = (i==1)
		g.tbl.plate_anim.list_feat[i]=og_menu_add_feature(g.tbl.plate_anim.strings[i], "action_value_str", g.tbl.plate_anim.list_prnt.id, function(f)
			local last,first,index=_last,_first,i
			g.tbl.plate_anim.do_text(f.value,last,first,index,f.value==4)
		end)
		if 1 == #g.tbl.plate_anim.strings then
			g.tbl.plate_anim.list_feat[i]:set_str_data({"Replace"}) --
			--new_set_str_data(g.tbl.plate_anim.list_feat[i],{"Replace"},true)
		else
			g.tbl.plate_anim.list_feat[i]:set_str_data({"Replace","Remove","Move up","Move down","Insert new"}) --
			--new_set_str_data(g.tbl.plate_anim.list_feat[i],{"Replace","Remove","Move up","Move down","Insert new"},true)
		end
	end
	g.tbl.plate_anim.add_str_bttm_feat=menu_add_feature("Add entry to bottom", "action", g.tbl.plate_anim.list_prnt.id, function(f)
		g.tbl.plate_anim.do_text(1,nil,nil,nil,true)
	end)
end
g.tbl.plate_anim.list_add()

function g.tbl.plate_anim.reset_plate()
	if funcs.is.veh(g.tbl.plate_anim.my_veh) then
		if g.tbl.plate_anim.index ~= nil then
			API.veh.set.plate_index(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.index)
		end
		if g.tbl.plate_anim.plate ~= nil then
			API.veh.set.plate_text(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.plate)
		end
	end
	g.tbl.plate_anim.index=nil
	g.tbl.plate_anim.plate=nil
	g.tbl.plate_anim.my_veh=nil
end

function g.tbl.plate_anim.record_plate()
	if g.tbl.plate_anim.index == nil then
		g.tbl.plate_anim.index = API.veh.get.plate_i(g.tbl.plate_anim.my_veh)
	end
	if g.tbl.plate_anim.plate == nil then
		g.tbl.plate_anim.plate = ntv.get.veh_plate_text(g.tbl.plate_anim.my_veh)
	end
end
function g.tbl.plate_anim.index_do()
	if g.tbl.plate_anim.style_tog.on then
		API.veh.set.plate_index(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.style_tog.value)
	elseif g.tbl.plate_anim.index ~= nil and API.veh.get.plate_i(g.tbl.plate_anim.my_veh) ~= g.tbl.plate_anim.index then
		API.veh.set.plate_index(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.index)
	end
end

g.tbl.plate_anim.tog=menu_add_feature("Custom license plate", "value_str", g.prnt.self_veh_crrnt_plate.id, function(f)
	local _table,do_once,f_value,time = {},false
	local function set_bools_false()
		g.tbl.plate_anim.str_scrl.new_txt=false
		g.tbl.plate_anim.str_scrl.new_dly=false
		g.tbl.plate_anim.plate_refresh=false
		g.tbl.plate_anim.plyr_delay=false
		g.tbl.plate_anim.plate_delay=false
	end
	local function reset_plate()
		g.tbl.plate_anim.reset_plate()
		set_bools_false()
		do_once=false
	end
	local function wp_show_const()
		g.tbl.plate_anim.wp.tog.on=(g.tbl.plate_anim.wp.select.value~=0)
		return (g.tbl.plate_anim.wp.select.value == 1 and g.tbl.plate_anim.wp.const and g.tbl.plate_anim.wp.dist ~= 0)
	end
	local function wp_show_blink()
		g.tbl.plate_anim.wp.tog.on=(g.tbl.plate_anim.wp.select.value~=0)
		return (g.tbl.plate_anim.wp.select.value == 2 and g.tbl.plate_anim.wp.blink and g.tbl.plate_anim.wp.dist ~= 0)
	end
	local function wp_show_any()
		g.tbl.plate_anim.wp.tog.on=(g.tbl.plate_anim.wp.select.value~=0)
		return (wp_show_const() or wp_show_blink())
	end
	local function wp_do_blink()
		while wp_show_any() and funcs.ME._in_veh() and f.on and not g.tbl.plate_anim.wp.blnk_new do
			API.veh.set.plate_text(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.dist_str(g.tbl.plate_anim.wp.dist_mtrc.value,g.tbl.plate_anim.wp.dist))
			YIELD(0)
		end
		g.tbl.plate_anim.wp.blnk_new=false
	end
	while f.on do
		f_value = f.value
		g.tbl.plate_anim.plyr.hddn.on=(f.value==2)
		g.tbl.plate_anim.wp.tog.on=(g.tbl.plate_anim.wp.select.value~=0)
		if g.tbl.plate_anim.my_veh ~= nil and API.plyr.get.veh(API.plyr.my_id()) ~= g.tbl.plate_anim.my_veh then
			reset_plate()
			YIELD(250)
		elseif funcs.ME._in_veh() then
			g.tbl.plate_anim.my_veh=API.plyr.get.veh(API.plyr.my_id())
			if not do_once then
				YIELD(250)
				g.tbl.plate_anim.record_plate()
				do_once=true
			end
			g.tbl.plate_anim.index_do()
			if wp_show_const() then
				API.veh.set.plate_text(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.dist_str(g.tbl.plate_anim.wp.dist_mtrc.value,g.tbl.plate_anim.wp.dist))
				YIELD(100)
			elseif f.value == 0 then
				YIELD(5)
				_table = g.tbl.plate_anim.strings
				for i=1,#_table do
					if not funcs.ME._in_veh() or not f.on or g.tbl.plate_anim.plate_refresh or (f_value ~= f.value) or wp_show_const() then
						break
					else
						g.tbl.plate_anim.index_do()
						API.veh.set.plate_text(g.tbl.plate_anim.my_veh, _table[i])
						time = TIME_MS() + g.tbl.plate_anim.delay.value*1000
						while time > TIME_MS() and not g.tbl.plate_anim.plate_refresh and not g.tbl.plate_anim.plate_delay and (f_value == f.value) and not wp_show_any() do
							YIELD(5)
						end
						g.tbl.plate_anim.plate_delay=false
						wp_do_blink()
					end
				end
			elseif f.value == 1 then
				YIELD(50)
				API.veh.set.plate_text(g.tbl.plate_anim.my_veh, g.tbl.plate_anim.spdo.math())
				wp_do_blink()
			elseif f.value == 2 then
				YIELD(0)
				_table=g.tbl.plate_anim.plyr.scroll()
				for i=1,#_table do
					if not funcs.ME._in_veh() or not f.on or (f_value ~= f.value) or wp_show_const() then
						break
					else
						API.veh.set.plate_text(g.tbl.plate_anim.my_veh, _table[i])
						time = TIME_MS() + g.tbl.plate_anim.plyr.delay.value*1000
						while time > TIME_MS() and not g.tbl.plate_anim.plyr_delay and (f_value == f.value) and not wp_show_any() do
							YIELD(5)
						end
						wp_do_blink()
					end
					g.tbl.plate_anim.plyr_delay=false
				end
			else
				_table=g.tbl.plate_anim.str_scrl.get()
				for i=1,#_table do
					if not funcs.ME._in_veh() or not f.on or (f_value ~= f.value) or wp_show_const() or g.tbl.plate_anim.str_scrl.new_txt then
						break
					else
						API.veh.set.plate_text(g.tbl.plate_anim.my_veh, _table[i])
						time = TIME_MS() + g.tbl.plate_anim.str_scrl.spd.value*1000
						while time > TIME_MS() and not g.tbl.plate_anim.str_scrl.new_dly and not g.tbl.plate_anim.str_scrl.new_txt and (f_value == f.value) and not wp_show_any() do
							YIELD(5)
						end
						wp_do_blink()
					end
					g.tbl.plate_anim.str_scrl.new_dly=false
				end
			end
			set_bools_false()
		else
			reset_plate()
			YIELD(250)
		end
	end
	reset_plate()
end)
new_set_str_data(g.tbl.plate_anim.tog,{"String list","Speedometer","Closest player","String scroll"})
funcs.add_to_S_L(g.tbl.plate_anim.tog,"g.tbl.plate_anim.tog")

function g.tbl.plate_anim.dist_str(_type,_dist)
	if _type==0 then
		if _dist >= 10000 then
			return tostring(funcs.get.round_num(_dist/1000).."km")
		end
		return tostring(funcs.get.round_num(_dist).."m")
	end
	if _dist*3.28084 >= 999999 then
		return tostring(funcs.get.round_num(_dist*3.28084/5280).."mls")
	end
	return tostring(funcs.get.round_num(_dist*3.28084).."ft")
end

function g.tbl.plate_anim.plyr.scroll()
	local _table,_table2 = {},{}
	local function max_num(_max,_num)
		if _num > _max then
			return _num-_max
		end
		return _num
	end
	if g.tbl.plate_anim.plyr.blank.on then
		for i=1,string.len(g.tbl.plate_anim.plyr.name) do
			_table[#_table+1]=string.sub(g.tbl.plate_anim.plyr.name,i,i)
		end
	else
		for char in g.tbl.plate_anim.plyr.name:gmatch("([a-zA-Z0-9])") do
			_table[#_table + 1] = char
		end
	end
	for i=1,g.tbl.plate_anim.plyr.space.value do
		_table[#_table+1]=" "
	end
	if g.tbl.plate_anim.plyr.show_dist.on then
		local text = g.tbl.plate_anim.dist_str(g.tbl.plate_anim.plyr.dist_type.value,g.tbl.plate_anim.plyr.dist)
		for i=1,string.len(text) do
			_table[#_table+1]=string.sub(text,i,i)
		end
		for i=1,g.tbl.plate_anim.plyr.space.value do
			_table[#_table+1]=" "
		end
	end
	if #_table< 9 then
		local limit = 9-#_table
		for i=1,limit do
			_table[#_table+1]=" "
		end
	end
	for i=1,#_table do
		local text=""
		for t=0,7 do
			if _table[max_num(#_table,i+t)] ~= nil then
				text=text.._table[max_num(#_table,i+t)]
			end
		end
		_table2[#_table2+1]=text
	end
	return _table2
end

g.tbl.plate_anim.plyr.hddn=og_menu_add_feature("Closest player HIDDEN", "toggle", g._Disp_Cust_Plate_Plyr.id, function(f)
	local _table,_bool,name,dist
	while f.on do
		if g.tbl.plate_anim.tog.value == 2 then
			_table = {}
			for i=1,32 do
				_table[i]=g.tbl.PID_OSD.dist_table[i]
			end
			table.sort(_table, function(a, b) return (a[1])<(b[1]) end)
			_bool = false
			for i=1,32 do
				if API.plyr.is.valid(_table[i][3]) and _table[i][3] ~= API.plyr.my_id() then
					name=funcs.get.pid_name(_table[i][3])
					dist=funcs.get.dist_me_pid_3d(_table[i][3])
					_bool = true
					break
				end
			end
			if _bool then
				g.tbl.plate_anim.plyr.name=name
				g.tbl.plate_anim.plyr.dist=dist
				_bool = false
			else
				g.tbl.plate_anim.plyr.name=funcs.get.pid_name(API.plyr.my_id())
				g.tbl.plate_anim.plyr.dist=0
			end
		end
		YIELD(100)
		f.on = (g.tbl.plate_anim.tog.on and g.tbl.plate_anim.tog.value == 2)
	end
end)g.tbl.plate_anim.plyr.hddn.hidden=true

g.tbl.plate_anim.plyr.show_dist=menu_add_feature("Show distance", "toggle", g._Disp_Cust_Plate_Plyr.id, function(f)
	g.tbl.plate_anim.plyr.dist_type.hidden=(not f.on)
end)
funcs.add_to_S_L(g.tbl.plate_anim.plyr.show_dist,"g.tbl.plate_anim.plyr.show_dist")

g.tbl.plate_anim.plyr.dist_type=menu_add_feature("Distance metric", "action_value_str", g._Disp_Cust_Plate_Plyr.id)
new_set_str_data(g.tbl.plate_anim.plyr.dist_type,{"Meters/KM","Feet"})
funcs.add_to_S_L(g.tbl.plate_anim.plyr.dist_type,"g.tbl.plate_anim.plyr.dist_type")

g.tbl.plate_anim.plyr.space=menu_add_feature("Extra spaces between info", "action_value_i", g._Disp_Cust_Plate_Plyr.id)
funcs.set_feat_i_f(g.tbl.plate_anim.plyr.space,2,8,1,4,"g.tbl.plate_anim.plyr.space")


g.tbl.plate_anim.plyr.delay=menu_add_feature("Scroll speed", "autoaction_value_f", g._Disp_Cust_Plate_Plyr.id, function(f)
	g.tbl.plate_anim.plyr_delay=true
end)
funcs.set_feat_i_f(g.tbl.plate_anim.plyr.delay,0.01,1,0.05,.25,"g.tbl.plate_anim.plyr.delay")

g.tbl.plate_anim.plyr.blank=menu_add_feature("Make special characters blank spaces", "toggle", g._Disp_Cust_Plate_Plyr.id)
funcs.add_to_S_L(g.tbl.plate_anim.plyr.blank,"g.tbl.plate_anim.plyr.blank")

g.tbl.plate_anim.delay=menu_add_feature("Animation delay (seconds)", "autoaction_value_f", g.tbl.plate_anim.list_optns.id, function(f)
	g.tbl.plate_anim.plate_delay=true
end)
funcs.set_feat_i_f(g.tbl.plate_anim.delay,0.01,30,0.05,.25,"g.tbl.plate_anim.delay")

g.tbl.plate_anim.style_tog=menu_add_feature("Include plate color", "value_str", g.prnt.self_veh_crrnt_plate.id)
new_set_str_data(g.tbl.plate_anim.style_tog,{"Blue/White","Yellow/black","Yellow/Blue","Blue/White2","Blue/White3","Yankton"})
funcs.add_to_S_L(g.tbl.plate_anim.style_tog,"g.tbl.plate_anim.style_tog")
g.tbl.plate_anim.style_tog.value=1



function g.tbl.plate_anim.spdo.math()
	if g.tbl.plate_anim.spdo.type.value==0 then
		return tostring(funcs.get.round_num(API.ent.get.speed(API.plyr.get.veh(API.plyr.my_id()))*2.23694)).." MPH"
	elseif g.tbl.plate_anim.spdo.type.value==1 then
		return tostring(funcs.get.round_num(API.ent.get.speed(API.plyr.get.veh(API.plyr.my_id()))*3.6)).." KPH"
	else
		local fps = API.ent.get.speed(API.plyr.get.veh(API.plyr.my_id()))*11811.02
		if g.tbl.plate_anim.spdo.dick_lngth.value == 0 then
			if fps*(12/5) > 999 then
				return tostring(funcs.get.round_num(fps*(12/5)/1000).."k DPH")
			end
			return tostring(funcs.get.round_num(fps*(12/5)).." DPH")
		elseif g.tbl.plate_anim.spdo.dick_lngth.value == 1 then
			if fps*(12/7) > 999 then
				return tostring(funcs.get.round_num(fps*(12/7)/1000).."k DPH")
			end
			return tostring(funcs.get.round_num(fps*(12/7)).." DPH")
		end
		if fps*(12/10) > 999 then
			return tostring(funcs.get.round_num(fps*(12/10)/1000).."k DPH")
		end
		return tostring(funcs.get.round_num(fps*(12/10)).." DPH")
	end
end

g.tbl.plate_anim.spdo.type=menu_add_feature("Speed metric", "autoaction_value_str", g._Disp_Cust_Plate_Speedo.id, function(f)
	g.tbl.plate_anim.spdo.dick_lngth.hidden=(f.value~=2)
end)
new_set_str_data(g.tbl.plate_anim.spdo.type,{"MPH","KPH","Dicks per hour"})
funcs.add_to_S_L(g.tbl.plate_anim.spdo.type,"g.tbl.plate_anim.spdo.type")

g.tbl.plate_anim.spdo.dick_lngth=menu_add_feature("Dick length", "autoaction_value_str", g._Disp_Cust_Plate_Speedo.id)
new_set_str_data(g.tbl.plate_anim.spdo.dick_lngth,{"Asian","Average","BBC"})
funcs.add_to_S_L(g.tbl.plate_anim.spdo.dick_lngth,"g.tbl.plate_anim.spdo.dick_lngth")

g.tbl.plate_anim.wp.select=menu_add_feature("Waypoint distance", "action_value_str", g.tbl.plate_anim.wp.prnt.id)
new_set_str_data(g.tbl.plate_anim.wp.select,{"Not shown","Always","Blink"})
funcs.add_to_S_L(g.tbl.plate_anim.wp.select,"g.tbl.plate_anim.wp.select")

g.tbl.plate_anim.wp.dist_mtrc=menu_add_feature("Distance metric", "action_value_str", g.tbl.plate_anim.wp.prnt.id)
new_set_str_data(g.tbl.plate_anim.wp.dist_mtrc,{"Meters/KM","Feet"})
funcs.add_to_S_L(g.tbl.plate_anim.wp.dist_mtrc,"g.tbl.plate_anim.wp.dist_mtrc")

g.tbl.plate_anim.wp.blnk_spd=menu_add_feature("Blink time (seconds)", "autoaction_value_f", g.tbl.plate_anim.wp.prnt.id, function()
	g.tbl.plate_anim.wp.blnk_new=true
end)
funcs.set_feat_i_f(g.tbl.plate_anim.wp.blnk_spd,.5,5,.25,1,"g.tbl.plate_anim.wp.blnk_spd")

g.tbl.plate_anim.wp.tog=og_menu_add_feature("Show waypoint distance HIDDEN", "toggle", g.tbl.plate_anim.wp.prnt.id, function(f)
	local blink_time,dist_time
	local function wp_reset()
		g.tbl.plate_anim.wp.blink=false
		g.tbl.plate_anim.wp.const=false
	end
	while f.on do
		if g.tbl.plate_anim.wp.select.value ~= 0 and funcs.ME._in_veh() then
			if ntv.is.waypoint() and g.var.wp_low.x~=0 and g.var.wp_low.y~=0 then
				blink_time,dist_time = TIME_MS(),TIME_MS()
				while ntv.is.waypoint() and g.var.wp_low.x~=0 and g.var.wp_low.y~=0 and f.on and g.tbl.plate_anim.wp.select.value ~= 0 do
					if dist_time < TIME_MS() then
						g.tbl.plate_anim.wp.dist = funcs.get.dist_pospos_v3(API.plyr.get.coords(API.plyr.my_id()),g.var.wp_low)
						if mth.flr(g.tbl.plate_anim.wp.blnk_spd.value*1000*.15)<100 then
							dist_time = TIME_MS()+100
						else
							dist_time = mth.flr(g.tbl.plate_anim.wp.blnk_spd.value*1000*.15)
						end
					end
					if g.tbl.plate_anim.wp.select.value == 1 then
						g.tbl.plate_anim.wp.const=true
						g.tbl.plate_anim.wp.blink=false
					else
						g.tbl.plate_anim.wp.const=false
						if blink_time < TIME_MS() then
							g.tbl.plate_anim.wp.blink=funcs.get.opp_bool(g.tbl.plate_anim.wp.blink)
							blink_time = TIME_MS()+g.tbl.plate_anim.wp.blnk_spd.value*1000
						end
					end
					YIELD(50)
				end
			end
		end
		wp_reset()
		f.on=(g.tbl.plate_anim.wp.select.value ~= 0 and g.tbl.plate_anim.tog.on)
		YIELD(500)
	end
	wp_reset()
end)
g.tbl.plate_anim.wp.tog.hidden=true

function g.tbl.plate_anim.str_scrl.write(_text)
	local file = io.open(g.tbl.plate_anim.directory.."String Scroll Animation.txt", "w")
	file:write(_text)
	file:close()
end

function g.tbl.plate_anim.str_scrl.check()
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.tbl.plate_anim.directory)
	if not utils.file_exists(g.tbl.plate_anim.directory.."String Scroll Animation.txt") then
		g.tbl.plate_anim.str_scrl.write("OMG GeeSkid is the best")
	end
	local file = io.open(g.tbl.plate_anim.directory.."String Scroll Animation.txt", "r")
	local text = nil
	for line in file:lines() do
		if line ~= nil and string.len(tostring(line)) > 0 then
			text = tostring(line)
			break
		end
	end
	file:close()
	if text == nil then
		g.tbl.plate_anim.str_scrl.write("OMG GeeSkid is the best")
	end
end
g.tbl.plate_anim.str_scrl.check()

function g.tbl.plate_anim.str_scrl.text()
	local file = io.open(g.tbl.plate_anim.directory.."String Scroll Animation.txt", "r")
	local text = nil
	for line in file:lines() do
		if line ~= nil and string.len(tostring(line)) > 0 then
			text = tostring(line)
			break
		end
	end
	file:close()
	return text
end

function g.tbl.plate_anim.str_scrl.get()
	local _table,_table2 = {},{}
	local function max_num(_max,_num)
		if _num > _max then
			return _num-_max
		end
		return _num
	end
	g.tbl.plate_anim.str_scrl.check()
	local text = g.tbl.plate_anim.str_scrl.text()
	for char in text:gmatch("([a-zA-Z0-9 ])") do
		_table[#_table + 1] = char
	end
	for i=1,g.tbl.plate_anim.str_scrl.space.value do
		_table[#_table+1]=" "
	end
	if #_table< 9 then
		local limit = 9-#_table
		for i=1,limit do
			_table[#_table+1]=" "
		end
	end
	for i=1,#_table do
		text=""
		for t=0,7 do
			if _table[max_num(#_table,i+t)] ~= nil then
				text=text.._table[max_num(#_table,i+t)]
			end
		end
		_table2[#_table2+1]=text
	end
	return _table2
end

g.tbl.plate_anim.str_scrl.spd = menu_add_feature("Scroll speed", "autoaction_value_f", g.tbl.plate_anim.str_scrl.optns.id, function()
	g.tbl.plate_anim.str_scrl.new_dly=true
end)
funcs.set_feat_i_f(g.tbl.plate_anim.str_scrl.spd,.01,1,.01,.2,"g.tbl.plate_anim.str_scrl.spd")

g.tbl.plate_anim.str_scrl.space=menu_add_feature("Extra spaces added at the end", "action_value_i", g.tbl.plate_anim.str_scrl.optns.id)
funcs.set_feat_i_f(g.tbl.plate_anim.str_scrl.space,0,8,1,4,"g.tbl.plate_anim.str_scrl.space")

g.tbl.plate_anim.str_scrl.update = menu_add_feature("Update text", "action_value_str", g.tbl.plate_anim.str_scrl.optns.id, function(f)
	g.tbl.plate_anim.str_scrl.check()
	local continue,text = true,""
	if f.value == 1 then
		text = g.tbl.plate_anim.str_scrl.text()
		if string.len(text) > 128 then
			continue=false
			g.N_P(2,"The string is too long to edit",__GV__,4,"Red")
		end
	end
	if continue then
		local status,str = 1,""
		status,str = funcs.get.text_input("Non alpha-numeric characters act as blank space",text,128,0)
		if status == 0 then
			g.tbl.plate_anim.str_scrl.write(str)
			g.tbl.plate_anim.str_scrl.new_txt=true
			g.tbl.plate_anim.str_scrl.updt_name()
		end
	end
end)
new_set_str_data(g.tbl.plate_anim.str_scrl.update,{"Replace","Edit"})
funcs.add_to_S_L(g.tbl.plate_anim.str_scrl.update,"g.tbl.plate_anim.str_scrl.update")



g.tbl.pid_veh_history={}
g.tbl.pid_veh_history_order={}
g.tbl.pid_veh_history_feats={}
g.tbl.pid_veh_history_count={}
g.tbl.pid_veh_history_hash={}
-- spawn vehicle
for i=0,31 do
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local function spawn_veh(f,hist,scid,VEH,hash,id_hash,i)
			if f.value == 2 then
				hist[scid][VEH]=nil
				hash[scid][id_hash]=false
				menu.delete_feature(f.id)
			else
				funcs.doo.req_model(hist[scid][VEH]["hash"])
				funcs.doo.create_clone_veh(hist[scid][VEH],nil,nil,true,nil,nil,f.value==0 and i or funcs.ME._id(),f.value==1)
			end
		end
		local function delete_feat(feats,scid,i)
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local FEAT = feats[scid][#feats[scid]].id
				local scid = scid
				while API.plyr.is.valid(i) and scid == API.plyr.get.scid(i) do
					YIELD(0)
				end
				menu.delete_feature(FEAT) --100% success
			end)
		end
		local veh,scid,name,name_num,last
		local hist,order,feats,count,hash = g.tbl.pid_veh_history,g.tbl.pid_veh_history_order,g.tbl.pid_veh_history_feats,g.tbl.pid_veh_history_count,g.tbl.pid_veh_history_hash

		while true do
			if API.plyr.is.valid(i) then
				last=nil
				scid = API.plyr.get.scid(i) --ntv.get.net_hash_from_player(i)--network.network_hash_from_player(i)
				feats[scid] = feats[scid] or {}
				hist[scid] = hist[scid] or {}
				order[scid] = order[scid] or {}
				hash[scid] = hash[scid] or {}
				count[scid] = {}
				for k,v in pairs(count[scid]) do
					for kk,vv in pairs(v) do
						vv=0
					end
				end
				--make features for existing vehicles that match that net hash. That way it remembers through sessions
				for v=#order[scid],1,-1 do
					if API.plyr.is.valid(i) then
						name = hist[scid][order[scid][v]]["name"] --order[scid][v]["name"]
						count[scid][name] = count[scid][name] or 0
						count[scid][name] = count[scid][name] + 1
						name = count[scid][name] > 1 and name.." ("..count[scid][name]..")" or name
						feats[scid][#feats[scid]+1]=menu.add_integrated_feature(name, "action_value_str", menu.get_feature_by_hierarchy_key("online.online_players.player_"..i..".script_features.gee_skid.spawn_vehicle.history"), function(f)
							spawn_veh(f,hist,scid,order[scid][v],hash,id_hash,i)
						end)
						new_set_str_data(feats[scid][#feats[scid]],{"Spawn for them","Spawn for me","Remove from list"})
						delete_feat(feats,scid,i)
						if v%3==0 then
							YIELD(0)
						end
						if not last then
							last = menu.get_feature_by_hierarchy_key("online.online_players.player_"..i..".script_features.gee_skid.spawn_vehicle.history."..funcs.get.hierarchy_text(name))
						end
					end
				end
				while API.plyr.is.valid(i) and scid == API.plyr.get.scid(i) do
					if API.plyr.is.in_veh(i) then
						local veh = API.plyr.get.veh(i)
						local id_hash = funcs.get.veh_id_hash(veh)
						if not hist[scid][veh] and not hash[scid][id_hash] then
							funcs.doo.record_clone_veh(hist[scid],veh)
							hash[scid][id_hash]=true
							order[scid][#order[scid]+1]=veh
							name = hist[scid][veh]["name"]
							count[scid][name] = count[scid][name] or 0
							count[scid][name] = count[scid][name] + 1
							name = count[scid][name] > 1 and name.." ("..count[scid][name]..")" or name
							if last and type(last) == "userdata" and last.parent then
								feats[scid][#feats[scid]+1]=menu.add_integrated_feature_before(name, "action_value_str", last, function(f)
									spawn_veh(f,hist,scid,veh,hash,id_hash,i)
								end)
							else
								feats[scid][#feats[scid]+1]=menu.add_integrated_feature(name, "action_value_str", menu.get_feature_by_hierarchy_key("online.online_players.player_"..i..".script_features.gee_skid.spawn_vehicle.history"), function(f)
									spawn_veh(f,hist,scid,veh,hash,id_hash,i)
								end)
							end
							new_set_str_data(feats[scid][#feats[scid]],{"Spawn for them","Spawn for me","Remove from list"})
							delete_feat(feats,scid,i)
							last = menu.get_feature_by_hierarchy_key("online.online_players.player_"..i..".script_features.gee_skid.spawn_vehicle.history."..funcs.get.hierarchy_text(name))
						end
					end
					YIELD(0)
				end
			end
			while not API.plyr.is.valid(i) do
				YIELD(0)
			end
		end

	end)
end

function funcs.get.veh_id_hash(_veh)
	local count =
	API.ent.get.model_hash(_veh)+
	API.veh.get.primary_color(_veh)+
	API.veh.get.pearl_color(_veh)+
	API.veh.get.secondary_color(_veh)+
	API.veh.get.tint(_veh) +
	API.veh.get.wheel_type(_veh)+
	API.veh.get.headlight_color(_veh)
	for i = 0, 65 do
		if funcs.is.num(API.veh.get.mod(_veh, i)) then
			count=count+API.veh.get.mod(_veh, i)
		end
	end
	return count
end


g.tbl.veh_clone={}
function funcs.doo.record_clone_veh(tbl,_veh)
	if funcs.is.veh(_veh) then
		tbl[_veh] = tbl[_veh] or {}
		tbl[_veh]["hash"]=API.ent.get.model_hash(_veh)
		tbl[_veh]["id_hash"]=funcs.get.veh_id_hash(_veh)
		tbl[_veh]["name"]=funcs.get.veh_model_name(_veh)
		tbl[_veh]["god"]=API.ent.get.god(_veh)
		tbl[_veh]["primary_color"]=API.veh.get.primary_color(_veh)
		tbl[_veh]["primary_colors"]={}
		tbl[_veh]["primary_colors"]["r"],
		tbl[_veh]["primary_colors"]["g"],
		tbl[_veh]["primary_colors"]["b"] = ntv.get.veh_primary_color_custom_rgb(_veh)
		tbl[_veh]["primary_color_custom"]= API.veh.is.primary_color_custom(_veh)
		tbl[_veh]["secondary_color"]=API.veh.get.secondary_color(_veh)
		tbl[_veh]["secondary_colors"]={}
		tbl[_veh]["secondary_colors"]["r"],
		tbl[_veh]["secondary_colors"]["g"],
		tbl[_veh]["secondary_colors"]["b"] = ntv.get.veh_secondary_color_custom_rgb(_veh)
		tbl[_veh]["secondary_color_custom"]= API.veh.is.secondary_color_custom(_veh)
		tbl[_veh]["pearl_color"]=API.veh.get.pearl_color(_veh)
		tbl[_veh]["pearl_color_custom"]=API.veh.get.pearl_color_custom(_veh)
		tbl[_veh]["tint"]=API.veh.get.tint(_veh)
		tbl[_veh]["wheel_type"]=API.veh.get.wheel_type(_veh)
		tbl[_veh]["wheel_color"]=API.veh.get.wheel_color(_veh)
		tbl[_veh]["wheel_color_custom"]=API.veh.get.wheel_color_custom(_veh)
		tbl[_veh]["bulletproof"]=ntv.get.veh_tires_can_burst(_veh)
		tbl[_veh]["headlight_color"]=API.veh.get.headlight_color(_veh)
		tbl[_veh]["interior_color"]=ntv.get.veh_interior_color(_veh) --doesnt actually work
		tbl[_veh]["dashboard_color"]=ntv.get.veh_dashboard_color(_veh) --doesnt actually work
		tbl[_veh]["plate_i"]=API.veh.get.plate_i(_veh)
		tbl[_veh]["plate_t"]=ntv.get.veh_plate_text(_veh)
		tbl[_veh]["neon_bool"]={}
		tbl[_veh]["tog_mods"] = {}
		tbl[_veh]["set_mods"] = {}
		tbl[_veh]["extras"] = {}
		tbl[_veh]["tire_smoke"]={}
		tbl[_veh]["tire_smoke"]["r"],
		tbl[_veh]["tire_smoke"]["g"],
		tbl[_veh]["tire_smoke"]["b"] =	ntv.get.veh_smoke_color(_veh)
		tbl[_veh]["drift"] = API.veh.get.drift_tires(_veh)
		for i=-1,5 do
			tbl[_veh]["neon_bool"][i] = API.veh.is.neon_on(_veh, i,true)
		end
		for i=-1,5 do
			if tbl[_veh]["neon_bool"][i] then
				tbl[_veh]["neon_color"]=API.veh.get.neon_color(_veh)
				break
			end
		end
		for i = 0, 65 do
			if funcs.is.num(API.veh.get.mod(_veh, i)) then
				tbl[_veh]["set_mods"][i]=API.veh.get.mod(_veh, i)
				tbl[_veh]["tog_mods"][i] = API.veh.is.tog_on(_veh, i) --{17,18,19,21,18,20,22}
			else
				tbl[_veh]["set_mods"][i]=nil
				tbl[_veh]["tog_mods"][i]=nil
			end

		end
		for i = 1, 14 do
			if API.veh.is.extra(_veh, i) and API.veh.is.extra_on(_veh, i) then
				tbl[_veh]["extras"][i] = true
			else
				tbl[_veh]["extras"][i] = false
			end
		end
		if API.strm.is.valid_helo(API.ent.get.model_hash(_veh)) then --because helos lose their "extras" when damaged/destroyed
			tbl[_veh]["extras"][1] = true
			tbl[_veh]["extras"][2] = true
			tbl[_veh]["extras"][7] = true
		end
	end
	return tbl[_veh]
end

function funcs.doo.create_clone_veh(VEH,_pos,_heading,_keep,_ntwrk,_cllsn,_pid,_cam)
	if VEH ~= nil and VEH["hash"] ~= nil and API.strm.is.valid(VEH["hash"]) then
		local veh
		if _pid then
			veh = funcs.doo.spawn_veh_at_pid(_pid,VEH["hash"],false,_cam,_keep)
		else
			veh = funcs.doo.spawn_veh(_pos,VEH["hash"],false,_heading,_keep,_ntwrk,_cllsn)
		end
		if funcs.is.veh(veh) then
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local _veh,__keep = veh,_keep
				funcs.doo.id_migrate(_veh,0)
				API.veh.set.kit_type(_veh, 0)
				API.ent.set.god(_veh,VEH["god"])
				API.veh.set.colors(_veh, VEH["primary_color"], VEH["secondary_color"])
				API.veh.set.extra_colors(_veh, VEH["pearl_color"], VEH["wheel_color"])
				if VEH["primary_color_custom"] then
					ntv.set.veh_primary_color_custom_rgb(_veh, VEH["primary_colors"]["r"],VEH["primary_colors"]["g"],VEH["primary_colors"]["b"])
				end
				if VEH["secondary_color_custom"] then
					ntv.set.veh_secondary_color_custom_rgb(_veh, VEH["secondary_colors"]["r"],VEH["secondary_colors"]["g"],VEH["secondary_colors"]["b"])
				end
				API.veh.set.pearl_color_custom(_veh, VEH["pearl_color_custom"])
				YIELD(0)
				if funcs.is.ent(_veh) then
					for i = 0, 65 do
						if VEH["set_mods"][i] and funcs.is.ent(_veh) then
							API.veh.set.mod(_veh, i, VEH["set_mods"][i],true) -- couldnt figure  out how to check for custom tires
							if i % 10 == 0 then
								YIELD(0)
							end
						end
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					for i = 0, 65 do
						if VEH["tog_mods"][i] and funcs.is.ent(_veh) then
							API.veh.set.tog_mod(_veh, i, true) --{17,18,19,21,18,20,22}
							if i % 10 == 0 then
								YIELD(0)
							end
						end
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					for i = 1, 14 do
						if VEH["extras"][i] and funcs.is.ent(_veh) then
							API.veh.set.extra(_veh, i, false) -- seems backwards but  false is on
							YIELD(0)
						end
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					API.veh.set.tint(_veh,VEH["tint"])
					ntv.set.veh_interior_color(_veh, VEH["interior_color"])
					ntv.set.veh_dashboard_color(_veh, VEH["dashboard_color"])
					API.veh.set.headlight_color(_veh,VEH["headlight_color"])
					API.veh.set.fullbeam(_veh, true)
					for i=-1,5 do
						if VEH["neon_bool"][i] then
							API.veh.set.neon_on(_veh, i, true)
							API.veh.set.neon_color(_veh, VEH["neon_color"]) --only needs to happen once but whatever
						end
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					API.veh.set.wheel_type(_veh, VEH["wheel_type"])
					-- for some reason the wheels set sometimes if you dont double tap them
					if API.veh.get.num_mods(_veh, 23) > 0 and VEH["set_mods"][23] then
						API.veh.set.mod(_veh, 23, VEH["set_mods"][23],true)
					end
					if API.veh.get.num_mods(_veh, 24) > 0 and VEH["set_mods"][24] then
						API.veh.set.mod(_veh, 24, VEH["set_mods"][24],true)
					end
					if API.veh.get.class(_veh) ~= 8 and API.veh.get.num_mods(_veh, 62) > 0 and VEH["set_mods"][62] then
						API.veh.set.mod(_veh, 62, VEH["set_mods"][62],true)
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					API.veh.set.drift_tires(_veh,VEH["drift"])
					API.veh.set.tire_smoke_color(_veh,VEH["tire_smoke"]["r"],VEH["tire_smoke"]["g"],VEH["tire_smoke"]["b"])
					API.veh.set.tires_can_burst(_veh,VEH["bulletproof"])
					API.veh.set.plate_index(_veh,VEH["plate_i"])
					API.veh.set.plate_text(_veh,VEH["plate_t"])
					API.veh.set.wheel_color_custom(_veh, VEH["wheel_color_custom"])
					API.veh.set.fixed(_veh)
					ntv.set.veh_dirt_level(_veh,0.0)
					API.veh.set.engine_on(_veh, true, true, false)
					if not __keep then
						funcs.doo.id_migrate(_veh,1)
					end
				end
			end)
		end
		return veh
	end
end
g.var.spawn2t1_prev_veh=nil

g.prnt.spawn2t1_options=menu_add_feature("Spawn Options", "parent",g.prnt.spawn2t1.id)
g.prnt.spawn2t1_display=menu_add_feature("Display Options", "parent",g.prnt.spawn2t1.id)
g.prnt.spawn2t1_vehs=menu_add_feature("Saved Vehicles", "parent",g.prnt.spawn2t1.id)



g.feat.spawn2t1_x = menu_add_feature("Overlay X Pos", "action_slider", g.prnt.spawn2t1_display.id)
funcs.set_feat_i_f(g.feat.spawn2t1_x,0,300,1,150,"g.feat.spawn2t1_x")

g.feat.spawn2t1_y = menu_add_feature("Overlay Y Pos", "action_slider", g.prnt.spawn2t1_display.id)
funcs.set_feat_i_f(g.feat.spawn2t1_y,0,300,1,135,"g.feat.spawn2t1_y")

g.feat.spawn2t1_in_veh = menu_add_feature("Spawn in vehicle", "toggle", g.prnt.spawn2t1_options.id)
funcs.add_to_S_L(g.feat.spawn2t1_in_veh,"g.feat.spawn2t1_in_veh")

g.feat.spawn2t1_god = menu_add_feature("God-Mode", "toggle", g.prnt.spawn2t1_options.id)
funcs.add_to_S_L(g.feat.spawn2t1_god,"g.feat.spawn2t1_god")

g.feat.spawn2t1_invcn_wind = menu_add_feature("Invincible windows", "toggle", g.prnt.spawn2t1_options.id)
funcs.add_to_S_L(g.feat.spawn2t1_invcn_wind,"g.feat.spawn2t1_invcn_wind")

g.feat.spawn2t1_remove_old = menu_add_feature("Remove previous vehicle", "toggle", g.prnt.spawn2t1_options.id)
funcs.add_to_S_L(g.feat.spawn2t1_remove_old,"g.feat.spawn2t1_remove_old")

g.feat.spawn2t1_front=menu_add_feature("Spawn using heading of my: ", "action_value_str", g.prnt.spawn2t1_options.id)
new_set_str_data(g.feat.spawn2t1_front,{"Cam","Ped"})
funcs.add_to_S_L(g.feat.spawn2t1_front,"g.feat.spawn2t1_front")

g.feat.spawn2t1_spd_tq=menu_add_feature("Vehicle max speed/torque %","action_value_i", g.prnt.spawn2t1_options.id)
funcs.set_feat_i_f(g.feat.spawn2t1_spd_tq,0,700,5,100,"g.feat.spawn2t1_spd_tq")

function funcs.doo.spawn_2t1_veh_with_options(VEH,_pid)
	if VEH ~= nil and VEH["hash"] ~= nil and API.strm.is.valid(VEH["hash"]) then
		local pos,head
		if g.feat.spawn2t1_front.value == 0 and funcs.ME._id() == _pid then
			pos = funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),funcs.get.spawn_front_dist(funcs.ME._id(),_veh) + funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos()))+1
			head = API.cam.get.rot().z
		else
			pos = funcs.get.front_of_pos(funcs.get.pid_pos_z_guess(_pid), API.plyr.get.heading(_pid), funcs.get.spawn_front_dist(_pid,nil), 184, 1.5)
			head = API.plyr.get.heading(_pid)
		end
		funcs.doo.req_model(VEH["hash"])
		local veh = funcs.doo.saved_2t1_veh(VEH,pos,head,false,true,false,_pid)
	end


end

menu_add_player_feature("Refresh list", "action", g.o.prnt.spawn2t1.id, function(f)
	funcs.doo.generate_2t1_veh_feats()
end)

menu_add_feature("Refresh list", "action", g.prnt.spawn2t1_vehs.id, function(f)
	funcs.doo.generate_2t1_veh_feats()
end)

g.tbl.modded_vehs ={}
g.tbl.modded_vehs_hist ={}
g.tbl.modded_vehs_feats ={}
g.var.vehfeatint=1
function funcs.doo.generate_2t1_veh_feats(_bool) --bool just for yield when first loading script
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		funcs.doo.check_create_dir(g.paths._vehs)
		g.tbl._2t1_veh_files = utils.get_all_files_in_directory(g.paths._vehs,"ini")
		for k,v in pairs(g.tbl._2t1_veh_files)do
			if not g.tbl.modded_vehs[funcs.get.text_no_ext(v)] and funcs.is.good_veh_file_name(v) then
				g.var.veh_file=io.open(g.paths._vehs..v,"r")
				if g.var.veh_file then
					g.tbl.modded_vehs[funcs.get.text_no_ext(v)] = {}
					for i in g.var.veh_file:lines() do
						g.var.veh_file_temp_gsub={}
						i:gsub(string.format("([^%s]+)", "="), function(c) g.var.veh_file_temp_gsub[#g.var.veh_file_temp_gsub+1]=c end)
						if g.var.veh_file_temp_gsub[1] and g.var.veh_file_temp_gsub[2] then
							if g.var.veh_file_temp_gsub[1] == "plate" then
								g.tbl.modded_vehs[funcs.get.text_no_ext(v)][g.var.veh_file_temp_gsub[1]]=g.var.veh_file_temp_gsub[2]
							else
								g.tbl.modded_vehs[funcs.get.text_no_ext(v)][g.var.veh_file_temp_gsub[1]]=tonumber(g.var.veh_file_temp_gsub[2])
							end
						end
					end
					g.var.veh_file:close()
				end
			end
			if _bool then
				YIELD(0)
			end
		end
		g.tbl.modded_vehs_temp1 ={}
		for k,v in pairs(g.tbl.modded_vehs)do
			g.tbl.modded_vehs_temp1[#g.tbl.modded_vehs_temp1+1]=k
		end
		table.sort(g.tbl.modded_vehs_temp1, function(a, b) return a:lower() < b:lower() end)
		for i=1,#g.tbl.modded_vehs_temp1 do
			if not g.tbl.modded_vehs_hist[g.tbl.modded_vehs_temp1[i]] then
				g.tbl.modded_vehs_hist[g.tbl.modded_vehs_temp1[i]]=true
				g.tbl.modded_vehs_feats[g.tbl.modded_vehs_temp1[i]]=og_menu_add_feature(g.tbl.modded_vehs_temp1[i], "action_value_str", g.prnt.spawn2t1_vehs.id, function(f)

					--local VEH = g.tbl.modded_vehs[g.tbl.modded_vehs_temp1[i]]
					if f.value == 0 then
						funcs.doo.spawn_2t1_veh_with_options(g.tbl.modded_vehs[g.tbl.modded_vehs_temp1[i]],funcs.ME._id())
					elseif funcs.ME._in_veh() then
						local msg,keep = funcs.doo.resave_2t1_veh(g.tbl.modded_vehs[g.tbl.modded_vehs_temp1[i]],funcs.ME._veh())
						if msg then
							g.var.veh_file=io.open(g.paths._vehs..g.tbl.modded_vehs_temp1[i]..".ini","w")
							g.var.veh_file:write(msg)
							g.var.veh_file:close()
						else
							g.N_P(2,"Failed to retrieve vehicle info.",__GV__,4,"Red")
						end
					else
						g.N_P(2,"You are not in a vehicle.",__GV__,4,"Yellow")
					end
				end)
				g.tbl.modded_vehs_feats[g.tbl.modded_vehs_temp1[i]]:set_str_data({"Spawn","Overwrite"}) --
				--new_set_str_data(g.tbl.modded_vehs_feats[g.tbl.modded_vehs_temp1[i]],{"Spawn","Overwrite"},true)


				og_menu_add_player_feature(g.tbl.modded_vehs_temp1[i], "action", g.o.prnt.spawn2t1.id, function(f,pid)
					local VEH = g.tbl.modded_vehs[g.tbl.modded_vehs_temp1[i]]
					funcs.doo.spawn_2t1_veh_with_options(VEH,pid)
				end)
				if _bool then
					YIELD(0)
				end
			g.var.vehfeatint=g.var.vehfeatint+1
			end
		end
	end)
end
funcs.doo.generate_2t1_veh_feats(true)


function funcs.doo.saved_2t1_veh(VEH,_pos,_heading,_keep,_ntwrk,_cllsn,_pid)
	if VEH ~= nil and VEH["hash"] ~= nil and API.strm.is.valid(VEH["hash"]) then
		local veh = funcs.doo.spawn_veh(_pos,VEH["hash"],false,_heading,_keep,_ntwrk,_cllsn)
		if funcs.is.veh(veh) then
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local _veh,__keep,__pid = veh,_keep,_pid
				funcs.doo.id_migrate(_veh,0)
				API.veh.set.kit_type(_veh, 0)
				if funcs.is.num(VEH["primaryIndex"]) and funcs.is.num(VEH["secondaryIndex"]) then
					API.veh.set.colors(_veh, VEH["primaryIndex"], VEH["secondaryIndex"])
				end
				if funcs.is.num(VEH["pearl"]) and funcs.is.num(VEH["wheel"]) then
					API.veh.set.extra_colors(_veh, VEH["pearl"], VEH["wheel"])
				end
				if VEH["isPrimaryColorCostum"] == 1 then
					ntv.set.veh_primary_color_custom_rgb(_veh, VEH["primary_r"],VEH["primary_g"],VEH["primary_b"])
				end
				if VEH["isSecondaryColorCostum"] == 1 then
					ntv.set.veh_secondary_color_custom_rgb(_veh, VEH["secondary_r"],VEH["secondary_g"],VEH["secondary_b"])
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					for i = 0, 65 do
						if funcs.is.num(VEH["mod"..i]) and funcs.is.ent(_veh) then
							API.veh.set.mod(_veh, i, VEH["mod"..i],true) -- couldnt figure  out how to check for custom tires
							if i % 10 == 0 then
								YIELD(0)
							end
						end
					end
					if VEH["xenon"] == 1 then
						API.veh.set.tog_mod(_veh, 22, true)
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					for i = 1, 14 do
						if VEH["extra"..i] and funcs.is.ent(_veh) then
							API.veh.set.extra(_veh, i, VEH["extra"..i]==0) -- seems backwards but  false is on
							YIELD(0)
						end
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					if funcs.is.num(VEH["windowTint"]) then
						API.veh.set.tint(_veh,VEH["windowTint"])
					end
					if funcs.is.num(VEH["headlightColor"]) then
						API.veh.set.headlight_color(_veh,VEH["headlightColor"])
					end
					API.veh.set.fullbeam(_veh, true)
					API.veh.set.neon_on(_veh, 0, VEH["neonLeft"] == 1)
					API.veh.set.neon_on(_veh, 1, VEH["neonRight"] == 1)
					API.veh.set.neon_on(_veh, 2, VEH["neonFront"] == 1)
					API.veh.set.neon_on(_veh, 3, VEH["neonBack"] == 1)
					if funcs.is.num(VEH["neon_r"]) and funcs.is.num(VEH["neon_g"]) and funcs.is.num(VEH["neon_b"]) then
						API.veh.set.neon_color(_veh, funcs.get.rgba_to_int(VEH["neon_r"],VEH["neon_g"],VEH["neon_b"]))
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					if funcs.is.num(VEH["wheelType"]) then
						API.veh.set.wheel_type(_veh, VEH["wheelType"])
					end
					-- for some reason the wheels set sometimes if you dont double tap them
					if API.veh.get.num_mods(_veh, 23) > 0 and VEH["mod23"] then
						API.veh.set.mod(_veh, 23, VEH["mod23"],true)
					end
					if API.veh.get.num_mods(_veh, 24) > 0 and VEH["mod24"] then
						API.veh.set.mod(_veh, 24, VEH["mod24"],true)
					end
					if API.veh.get.class(_veh) ~= 8 and API.veh.get.num_mods(_veh, 62) > 0 and VEH["mod62"]then
						API.veh.set.mod(_veh, 62, VEH["mod62"],true)
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					API.veh.set.drift_tires(_veh,VEH["hasDriftTires"]==1)
					if funcs.is.num(VEH["tyressmoke_r"]) and funcs.is.num(VEH["tyressmoke_g"]) and funcs.is.num(VEH["tyressmoke_b"]) then
						API.veh.set.tire_smoke_color(_veh,VEH["tyressmoke_r"],VEH["tyressmoke_g"],VEH["tyressmoke_b"])
					end
					API.veh.set.tires_can_burst(_veh,VEH["bulletproof"]==1)
					if funcs.is.num(VEH["plateIndex"]) then
						API.veh.set.plate_index(_veh,VEH["plateIndex"])
					end
					if funcs.is.str(VEH["plate"]) then
						API.veh.set.plate_text(_veh,VEH["plate"])
					end
					API.veh.set.fixed(_veh)
					ntv.set.veh_dirt_level(_veh,0.0)
					API.veh.set.engine_on(_veh, true, true, false)
				end
				YIELD(0)
				if __pid == funcs.ME._id() and funcs.is.ent(_veh) then
					API.ent.set.god(_veh,g.feat.spawn2t1_god.on)
					ntv.set.veh_invncbl_wndws(_veh,g.feat.spawn2t1_invcn_wind.on)
					API.ent.set.max_speed(_veh, 45000)
					API.veh.set.top_speed(_veh, (g.feat.spawn2t1_spd_tq.value/100 - 1) * 100)
					if g.feat.spawn2t1_in_veh.on then
						API.Ped.set.into_veh(funcs.ME._ped(),_veh,-1)
					end
				end
				YIELD(0)
				if funcs.is.ent(_veh) then
					if __pid == funcs.ME._id() then
						local veh2 = g.var.spawn2t1_prev_veh
						if g.feat.spawn2t1_remove_old.on and funcs.is.veh(veh2) then
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								local _veh2 = veh2
								for i=1,funcs.get.veh_seats(_veh2) do
									if funcs.is.ent(API.veh.get.ped_in_seat(_veh2,i-2)) then
										API.Ped.clear_tasks(API.veh.get.ped_in_seat(_veh2, i-2))
									end
								end
								YIELD(500)
								if funcs.ntwrk.ask_long(_veh2,3000) then
									API.ent.set.no_need(_veh2)
									API.ent.delete(_veh2)
								end
							end)
						end
						g.var.spawn2t1_prev_veh = _veh
					end
					if not __keep then
						funcs.doo.id_migrate(_veh,1)
					end
				end
			end)
		end
		return veh
	end
end

function funcs.doo.resave_2t1_veh(VEH,_veh)
	if VEH ~= nil and funcs.is.veh(_veh) then
		local t,keep={},{}
		local msg="[VEHICLE]"
		t["hash"]=funcs.get.Int32(API.ent.get.model_hash(_veh))
		t["plateIndex"]=API.veh.get.plate_i(_veh)
		t["spawnInVehicle"]=((g.feat.spawn2t1_in_veh.on and 1) or 0)
		t["plate"]=(ntv.get.veh_plate_text(_veh):lower()).." " --idk why tf the  menu adds a space here  but whatever
		t["bypass"]=((ntv.get.veh_mod_kit(_veh) == 65535 and 0) or 1)
		t["primaryIndex"]=API.veh.get.primary_color(_veh)
		t["primary_b"],
		t["primary_g"],
		t["primary_r"] = ntv.get.veh_primary_color_custom_rgb(_veh) --yes its bgr
		t["isPrimaryColorCostum"]= ((API.veh.is.primary_color_custom(_veh) and 1) or 0)
		t["secondaryIndex"]=API.veh.get.secondary_color(_veh)
		t["secondary_b"],
		t["secondary_g"],
		t["secondary_r"] = ntv.get.veh_secondary_color_custom_rgb(_veh) --yes its bgr
		t["isSecondaryColorCostum"]= ((API.veh.is.secondary_color_custom(_veh) and 1) or 0)
		t["pearl"]=API.veh.get.pearl_color(_veh)
		t["wheel"]=API.veh.get.wheel_color(_veh)
		t["wheel_b"],
		t["wheel_g"],
		t["wheel_r"] = funcs.get.rgba_from_int(API.veh.get.wheel_color_custom(_veh)) --yes its bgr
		t["xenon"] = ((API.veh.is.tog_on(_veh, 22) and 1) or 255)
		t["windowTint"]=API.veh.get.tint(_veh)
		t["headlightColor"]=((API.veh.get.headlight_color(_veh) == -1 and 255) or API.veh.get.headlight_color(_veh))
		t["neonLeft"] = ((API.veh.is.neon_on(_veh, 0,true) and 1) or 0)
		t["neonRight"] = ((API.veh.is.neon_on(_veh, 1,true) and 1) or 0)
		t["neonFront"] = ((API.veh.is.neon_on(_veh, 2,true) and 1) or 0)
		t["neonBack"] = ((API.veh.is.neon_on(_veh, 3,true) and 1) or 0)
		t["neon_r"],
		t["neon_g"],
		t["neon_b"] = funcs.get.rgba_from_int(API.veh.get.neon_color(_veh))
		t["wheelType"] = ((t["bypass"]== 0 and 255) or API.veh.get.wheel_type(_veh))
		t["hasDriftTires"]=((API.veh.get.drift_tires(_veh) and 1) or 0)
		t["tyressmoke_r"],
		t["tyressmoke_g"],
		t["tyressmoke_b"] = ntv.get.veh_smoke_color(_veh)
		t["hasTireSmoke"] = ((API.veh.is.tog_on(_veh, 20) and 1) or 0)
		t["bulletproof"]=((ntv.get.veh_tires_can_burst(_veh) and 0) or 1)
		t["model_r"]=255 --no way to get this :(
		t["model_g"]=255
		t["model_b"]=255
		t["seat_r"]=8 --no way to get this :(
		t["seat_g"]=8
		t["seat_b"]=8
		for  k,v in pairs(t) do
			msg=msg.."\n"..k.."="..v
			keep[k]=v
		end
		t={}
		for i = 0, 48 do
			if i == 18 or i == 20 or i == 22 then
				t["mod"..i]=((API.veh.is.tog_on(_veh, i) and 1) or 0)
			elseif i == 17 or i == 19 or i == 21 then
				t["mod"..i]=((API.veh.is.tog_on(_veh, i) and 0) or -1)
			else
				t["mod"..i]=((funcs.is.num(API.veh.get.mod(_veh, i)) and API.veh.get.mod(_veh, i)) or -1)
			end
		end
		msg=msg.."\n".."[MODS]"
		for  k,v in pairs(t) do
			msg=msg.."\n"..k.."="..v
			keep[k]=v
		end
		t={}
		local found=false
		for i = 1, 12 do
			if API.veh.is.extra(_veh,i) then
				t["extra"..i]=((API.veh.is.extra_on(_veh,i) and 1) or 0)
			end
		end
		for  k,v in pairs(t) do
			found=true
			keep[k]=v
		end
		if found then
			msg=msg.."\n".."[EXTRAS]"
			for  k,v in pairs(t) do
				msg=msg.."\n"..k.."="..v
			end
		end
		for k,v in pairs(VEH) do
			if keep[k] then
				VEH[k]=keep[k]
			else
				k=nil
			end
		end
		return msg
	end
end

menu_add_feature("Open overlay selection window", "action", g.prnt.spawn2t1.id, function(f)
	f.hidden=true
	funcs.doo.saved_2t1_search("Saved 2T1 Vehicles")
	f.hidden=false
end)

function funcs.doo.saved_2t1_search_show(_table,_title,selection,start,x_val_box,y_val)
	ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.0175, 0, 0, 0, 155)
	funcs.doo.overlay(_title,75,150,75,255,.2,0,x_val_box,y_val)
	y_val=y_val+0.0171
	local count = 1
	local t={}
	for i=1, #_table do
		if i >= start and i <= start+6 then
			t[tostring(count)]=i
			ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.0175, 0, 0, 0, 155)
			if i == selection then
				ui.draw_rect(x_val_box, y_val+0.0072, 0.1,0.017, 155, 155, 155, 155)
			end
			funcs.doo.overlay_left("["..count.."] "..i.."  ".._table[i],255,255,255,255,.2,0,x_val_box-0.045,y_val)
			y_val=y_val+0.0171
			count=count+1
		end
	end
	return t
end

function funcs.doo.saved_2t1_search(_title)
	local y_val,x_val_box,selection,start
	local search,key_time=true,TIME_MS()
	local count=0
	local vehs2t1,t = {}
	for k,v in  pairs(g.tbl.modded_vehs) do
		count=count+1
		vehs2t1[#vehs2t1+1]=k
	end
	table.sort(vehs2t1, function(a, b) return a:lower() < b:lower() end)
	local function key_press(_key)
		if TIME_MS() > key_time and funcs.is.vk_key_down(_key) then
			key_time = TIME_MS() + 100
			return true
		end
		return false
	end
	if #vehs2t1 > 0 then
		selection,start = 1,1
		while search do
			YIELD(0)
			y_val = g.feat.spawn2t1_y.value/300
			x_val_box = g.feat.spawn2t1_x.value/300
			ntv.doo.hide_weapon_wheel_from_mouse()
			t=funcs.doo.saved_2t1_search_show(vehs2t1,_title,selection,start,x_val_box,y_val)
			if funcs.is.key_active(14,1) or API.cntrl.is.just_pressed(1, 187) or key_press("S") then
				if vehs2t1[selection+1] ~= nil then selection = selection+1
				else selection = 1
				end
			elseif funcs.is.key_active(15,1) or API.cntrl.is.just_pressed(1, 188) or key_press("W") then
				if vehs2t1[selection-1] ~= nil then selection = selection-1
				else selection = #vehs2t1
				end
			end
			for k,v in pairs(t) do
				if funcs.is.vk_key_down(k) and vehs2t1[v] ~= nil then
					funcs.doo.spawn_2t1_veh_with_options(g.tbl.modded_vehs[vehs2t1[v]],funcs.ME._id())
					search = false
					break
				end
			end
			if funcs.is.vk_key_down("RETURN") and vehs2t1[selection] ~= nil then
				funcs.doo.spawn_2t1_veh_with_options(g.tbl.modded_vehs[vehs2t1[selection]],funcs.ME._id())
				search = false
			elseif funcs.is.vk_key_down("ESCAPE") then
				search = false
			end
			if selection > start+6 then
				repeat
					start = start+1
				until selection <= start+6
			elseif selection < start then
				start =  selection
			end
		end
	end
end


---------------------------------------------------------------------------------------------------------------------------------------------------
g.tbl.punish_traffic={}

function g.tbl.punish_traffic.func2(veh,_cllsn)
	if not g.tbl.punish_traffic.veh_active[veh] then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local _veh = veh
			g.tbl.punish_traffic.veh_active[_veh]=true
			if g.tbl.punish_traffic.should_punish(_veh,_cllsn) then
				if g.tbl.punish_traffic.feat.value == 0 then--------------------------------------------TP
					if funcs.doo.remove_ent(_veh,250) then
						g.tbl.punish_traffic.veh_time[_veh][1] =TIME_MS()
					end
				elseif g.tbl.punish_traffic.feat.value == 1 then----------------------------------------Damage
					if funcs.ntwrk.ask_long(_veh,250) then
						g.tbl.punish_traffic.veh_time[_veh][2] =TIME_MS() + mth.rndm(4500,5500)
					end
					API.ent.set.god(_veh, false)
					funcs.doo.veh_tire_pop_guts(_veh,true)
					API.veh.set.engine_health(_veh, -4000)
					API.veh.set.plate_index(_veh, 1)
					API.veh.set.plate_text(_veh,"G-Damage")
					API.ent.set.velocity(_veh,API.ent.get.velocity(_veh)*0.5)
					ntv.set.veh_invncbl_wndws(_veh,0)
					ntv.doo.brk_veh_wndws(_veh)
				elseif g.tbl.punish_traffic.feat.value == 2 then----------------------------------------Launch
					if funcs.ntwrk.ask_long(_veh,250) then
						g.tbl.punish_traffic.veh_time[_veh][3]=TIME_MS() + mth.rndm(500,1000)
					end
					API.ent.set.velocity(_veh,v3(mth.rndm(-g.tbl.punish_traffic.launch.value*2,g.tbl.punish_traffic.launch.value*2),mth.rndm(-g.tbl.punish_traffic.launch.value*2,g.tbl.punish_traffic.launch.value*2),g.tbl.punish_traffic.launch.value*20))
				elseif g.tbl.punish_traffic.feat.value == 3 then
					if not ntv.is.veh_emp_disabled(_veh) and API.ent.get.speed(_veh) > 0.2 and funcs.ntwrk.ask_long(_veh,250) then -----EMP
						API.ent.set.god(_veh, false)
						API.veh.set.forward_speed(_veh,0)
						fire.add_explosion(API.ent.get.coords(_veh), 65, true, false, 0, funcs.get.non_plyr_ped(false))
						g.tbl.punish_traffic.veh_time[_veh][4]=TIME_MS() + mth.rndm(2500,3000)
					end
				else
					local ent_crds,move = API.ent.get.coords(_veh)
					if funcs.ME._in_veh() then	-----------------------------------------------------------------------------------------------Push away
						if ent_crds.z <= funcs.ME._veh_crds().z+0.5 and ent_crds.z >= funcs.ME._veh_crds().z-1.5 then
							ent_crds.z = funcs.ME._veh_crds().z+0.25
						end
						move = g.tbl.a_b.get_movement(ent_crds,funcs.ME._veh_crds(),(g.tbl.PID_INFO.plyr_speed_pos_mps[API.plyr.my_id()+1]+10)*.01)
					else
						if ent_crds.z <= funcs.ME._crds().z+0.5 and ent_crds.z >= funcs.ME._crds().z-1.5 then
							ent_crds.z = funcs.ME._crds().z+0.25
						end
						move = g.tbl.a_b.get_movement(ent_crds,funcs.ME._crds(),(g.tbl.PID_INFO.plyr_speed_pos_mps[API.plyr.my_id()+1]+10)*.01)*1.25
					end
					if funcs.ntwrk.ask_long(_veh,250) then
					--API.ent.force(_veh, 3, move.x*0.25,move.y*0.25,move.z*0.333, 0,0,0, false, true)
						API.ent.set.velocity(_veh,v3(move.x*(g.tbl.punish_traffic.push_h.value/5),move.y*(g.tbl.punish_traffic.push_h.value/5),move.z*(g.tbl.punish_traffic.push_v.value/5)))
						g.tbl.punish_traffic.veh_time[_veh][5]=TIME_MS()
					end
				end
			end
			g.tbl.punish_traffic.veh_active[_veh]=false
		end, nil)
	end
end

function g.tbl.punish_traffic.collision_thread()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local all_veh,veh
		while g.tbl.punish_traffic.feat.on do
			YIELD(0)
			if g.tbl.punish_traffic.when_to_punish() then
				if funcs.ME._in_veh() then
					if API.ent.is.collided(funcs.ME._veh()) then
						veh = API.ent.get.collided_with(funcs.ME._veh())
						if funcs.is.veh(veh) then
							g.tbl.punish_traffic.func2(veh,true)
						end
					end
				else
					all_veh=API.veh.get.all()
					for i=1,#all_veh do
						if (ntv.is.ents_touch(funcs.ME._ped(),all_veh[i]) or API.ent.get.collided_with(funcs.ME._ped())==all_veh[i]) then
							g.tbl.punish_traffic.func2(all_veh[i],true)
						end
					end
				end
			end
		end
	end, nil)
end

function g.tbl.punish_traffic.get_my_pos()
	if funcs.ME._in_veh() then
		return funcs.ME._veh_crds(),funcs.ME._veh_crds()+(API.ent.get.velocity(funcs.ME._veh())*0.2269)
	end
	return funcs.ME._crds(),funcs.ME._crds()+(API.ent.get.velocity(funcs.ME._ped())*0.2269)
end

function g.tbl.punish_traffic.should_punish(_veh,_cllsn)
	if g.tbl.punish_traffic.veh_time[_veh]==nil then
		g.tbl.punish_traffic.veh_time[_veh]={TIME_MS(),TIME_MS(),TIME_MS(),TIME_MS(),TIME_MS()}
	end
	if g.tbl.punish_traffic.veh_time[_veh][g.tbl.punish_traffic.feat.value+1] > TIME_MS() then
		return false
	elseif _veh == funcs.ME._veh() or _veh == API.plyr.pers_veh() or _veh == g.tbl.PID_INFO.veh[funcs.ME._id()+1] then
		return false
	elseif not g.tbl.punish_traffic.plyrs.on and (API.veh.get.been_owned(_veh) or g.tbl.punish_traffic.pid_net_hash[decorator.decor_get_int(_veh, "Player_Vehicle")]) then
		return false
	elseif _cllsn and g.tbl.punish_traffic.feat.value == 3 then
		return false
	end
	for pid=0,31 do
		if g.tbl.punish_traffic.frnd_net_hash[pid]==decorator.decor_get_int(_veh, "Player_Vehicle") or
		g.tbl.punish_traffic.mddr_net_hash[pid]==decorator.decor_get_int(_veh, "Player_Vehicle") or
		g.tbl.punish_traffic.org_net_hash[pid]==decorator.decor_get_int(_veh, "Player_Vehicle") then
			return false
		end
	end
	for seat = 1,funcs.get.veh_seats(_veh) do
		if funcs.is.ent(API.veh.get.ped_in_seat(_veh, seat-2)) and API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, seat-2)) then
			local plyr = API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(_veh, seat-2))
			if g.tbl.punish_traffic.frnd_net_hash[plyr]~=nil or
			g.tbl.punish_traffic.mddr_net_hash[plyr]~=nil or
			g.tbl.punish_traffic.org_net_hash[plyr]~=nil then
				return false
			end
		end
	end
	if _cllsn then
		return true
	end
	local my_pos,vel_pos = g.tbl.punish_traffic.get_my_pos()
	local check_pos = nil
	local bubble,safe = g.tbl.punish_traffic.bubl.value+g.tbl.punish_traffic.veh_dmnsns+g.tbl.punish_traffic.get_veh_size_ofst(_veh),g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns-g.tbl.punish_traffic.get_veh_size_ofst(_veh)
	local ent_pos = API.ent.get.coords(_veh)
	if g.tbl.punish_traffic.below.on or g.tbl.punish_traffic.above.on then
		if funcs.get.dist_pospos_v3(funcs.vec(my_pos.x,my_pos.y),funcs.vec(ent_pos.x,ent_pos.y)) <= bubble then
			check_pos = my_pos
		elseif funcs.get.dist_pospos_v3(funcs.vec(vel_pos.x,vel_pos.y),funcs.vec(ent_pos.x,ent_pos.y)) <= bubble then
			check_pos = vel_pos
		end
		if check_pos == nil then
			return false
		else
			if g.tbl.punish_traffic.below.on and g.tbl.punish_traffic.above.on then
				if g.tbl.punish_traffic.feat.value == 3 then
					return (funcs.get.dist_pospos_v3(check_pos,ent_pos) >= safe)
				end
				return true
			else
				local v3dist = funcs.get.dist_pospos_v3(check_pos,ent_pos)
				if g.tbl.punish_traffic.below.on then
					if g.tbl.punish_traffic.feat.value == 3 then
						if v3dist >= safe then
							return ((ent_pos.z <= check_pos.z) or (v3dist <= bubble))
						end
						return false
					else
						return ((ent_pos.z <= check_pos.z) or (v3dist <= bubble))
					end
				else
					if g.tbl.punish_traffic.feat.value == 3 then
						if v3dist >=safe then
							return ((ent_pos.z >= check_pos.z) or (v3dist <= bubble))
						end
						return false
					else
						return ((ent_pos.z >= check_pos.z) or (v3dist <= bubble))
					end
				end
			end
		end
	else
		if funcs.get.dist_pospos_v3(my_pos,ent_pos) <= bubble then
			check_pos = my_pos
		elseif funcs.get.dist_pospos_v3(vel_pos,ent_pos) then
			check_pos = vel_pos
		end
		if check_pos == nil then
			return false
		else
			local v3dist = funcs.get.dist_pospos_v3(check_pos,ent_pos)
			if g.tbl.punish_traffic.feat.value == 3 then
				if v3dist >= safe then
					return (v3dist <= bubble)
				end
				return false
			else
				return (v3dist <= bubble)
			end
		end
	end
end

function g.tbl.punish_traffic.when_to_punish()
	local foot_or_veh = g.tbl.punish_traffic.foot_or_veh.value
	if foot_or_veh == 0 then
		return true
	elseif foot_or_veh == 1 then
		return funcs.ME._in_veh()
	end
	return (not funcs.ME._in_veh())
end

function g.tbl.punish_traffic.record_exclusions_thread()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		while g.tbl.punish_traffic.feat.on do
			for pid=0,31 do
				if funcs.is.valid_pid(pid) then
					if not g.tbl.punish_traffic.frnds.on and API.plyr.is.friend(pid) then
						g.tbl.punish_traffic.frnd_net_hash[pid]=network.network_hash_from_player(pid)
					else
						g.tbl.punish_traffic.frnd_net_hash[pid]=nil
					end
					if not g.tbl.punish_traffic.mddrs.on and API.plyr.is.modder(pid,-1) then
						g.tbl.punish_traffic.mddr_net_hash[pid]=network.network_hash_from_player(pid)
					else
						g.tbl.punish_traffic.mddr_net_hash[pid]=nil
					end
					if not g.tbl.punish_traffic.orgmc.on and funcs.is.same_orgmc(pid,API.plyr.my_id()) then
						g.tbl.punish_traffic.org_net_hash[pid]=network.network_hash_from_player(pid)
					else
						g.tbl.punish_traffic.org_net_hash[pid]=nil
					end
				else
					g.tbl.punish_traffic.frnd_net_hash[pid]=nil
					g.tbl.punish_traffic.mddr_net_hash[pid]=nil
					g.tbl.punish_traffic.org_net_hash[pid]=nil
				end
			end
			YIELD(1000)
		end
	end, nil)
end

g.tbl.punish_traffic.feat=menu_add_feature("Punish vehicles nearby", "value_str", g.prnt.utils_trffc.id, function(f)
	if f.on then
		g.tbl.punish_traffic.frnd_net_hash={}
		g.tbl.punish_traffic.mddr_net_hash={}
		g.tbl.punish_traffic.org_net_hash={}
		g.tbl.punish_traffic.veh_dmnsns=0
		g.tbl.punish_traffic.veh_active={}
		g.tbl.punish_traffic.veh_time={}
		g.tbl.punish_traffic.pid_net_hash={}
		g.tbl.punish_traffic.record_exclusions_thread()
		g.tbl.punish_traffic.collision_thread()
		if not g.tbl.punish_traffic.cllsn.on then
			g.tbl.punish_traffic.start_debug(true,true)
		end
	end
	local time,all_veh = TIME_MS()
    while f.on do
		--g.tbl.punish_traffic.start_debug(true,false)
		YIELD(0)
		if not g.tbl.punish_traffic.cllsn.on and g.tbl.punish_traffic.when_to_punish() then
			g.tbl.punish_traffic.get_my_veh_size()
			all_veh = API.veh.get.all()
			for i=1,#all_veh do
				if g.tbl.punish_traffic.should_punish(all_veh[i],false) then
					g.tbl.punish_traffic.func2(all_veh[i])
				end
			end
		end
    end
end)
new_set_str_data(g.tbl.punish_traffic.feat,{"TP away","Damage","Launch","EMP","Push away"})
funcs.add_to_S_L(g.tbl.punish_traffic.feat,"g.tbl.punish_traffic.feat")

g.tbl.punish_traffic.foot_or_veh=menu_add_feature("When to punish", "action_value_str", g.prnt.utils_trffc.id)
new_set_str_data(g.tbl.punish_traffic.foot_or_veh,{"Both","In vehicle", "On foot"})
funcs.add_to_S_L(g.tbl.punish_traffic.foot_or_veh,"g.tbl.punish_traffic.foot_or_veh")

function g.tbl.punish_traffic.hide(_bool)
	g.tbl.punish_traffic.frnds.hidden=_bool
	g.tbl.punish_traffic.orgmc.hidden=_bool
	g.tbl.punish_traffic.mddrs.hidden=_bool
end

g.tbl.punish_traffic.push_h=menu_add_feature("Push force horizontally", "action_value_i", g.prnt.utils_trffc.id)
funcs.set_feat_i_f(g.tbl.punish_traffic.push_h,1,10,1,5,"g.tbl.punish_traffic.push_h")

g.tbl.punish_traffic.push_v=menu_add_feature("Push force vertically", "action_value_i", g.prnt.utils_trffc.id)
funcs.set_feat_i_f(g.tbl.punish_traffic.push_v,1,10,1,7,"g.tbl.punish_traffic.push_v")

g.tbl.punish_traffic.launch=menu_add_feature("Launch force", "action_value_i", g.prnt.utils_trffc.id)
funcs.set_feat_i_f(g.tbl.punish_traffic.launch,1,10,1,5,"g.tbl.punish_traffic.launch")

g.tbl.punish_traffic.plyrs=menu_add_feature("Include player vehicles", "toggle", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.hide(not f.on)
end)
funcs.add_to_S_L(g.tbl.punish_traffic.plyrs,"g.tbl.punish_traffic.plyrs")

g.tbl.punish_traffic.frnds=menu_add_feature("Include friends", "toggle", g.prnt.utils_trffc.id)
funcs.add_to_S_L(g.tbl.punish_traffic.frnds,"g.tbl.punish_traffic.frnds")

g.tbl.punish_traffic.orgmc=menu_add_feature("Include my ORG/MC", "toggle", g.prnt.utils_trffc.id)
funcs.add_to_S_L(g.tbl.punish_traffic.orgmc,"g.tbl.punish_traffic.orgmc")

g.tbl.punish_traffic.mddrs=menu_add_feature("Include modders", "toggle", g.prnt.utils_trffc.id)
funcs.add_to_S_L(g.tbl.punish_traffic.mddrs,"g.tbl.punish_traffic.mddrs")

g.tbl.punish_traffic.cllsn=menu_add_feature("Only punish vehicles that touch me", "toggle", g.prnt.utils_trffc.id)
funcs.add_to_S_L(g.tbl.punish_traffic.cllsn,"g.tbl.punish_traffic.cllsn")

g.tbl.punish_traffic.below=menu_add_feature("Include vehicles below my bubble", "toggle", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.start_debug(true,false)
end)
funcs.add_to_S_L(g.tbl.punish_traffic.below,"g.tbl.punish_traffic.below")

g.tbl.punish_traffic.above=menu_add_feature("Include vehicles above my bubble", "toggle", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.start_debug(true,false)
end)
funcs.add_to_S_L(g.tbl.punish_traffic.above,"g.tbl.punish_traffic.above")

g.tbl.punish_traffic.show_bubl=false
g.tbl.punish_traffic.bubl=menu_add_feature("Bubble size", "autoaction_value_i", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.start_debug(true,false)
end)
funcs.set_feat_i_f(g.tbl.punish_traffic.bubl,5,1000,5,15,"g.tbl.punish_traffic.bubl")

g.tbl.punish_traffic.show_safe=false
g.tbl.punish_traffic.safe=menu_add_feature("Safe zone for EMP", "autoaction_value_i", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.start_debug(false,true)
end)
funcs.set_feat_i_f(g.tbl.punish_traffic.safe,5,25,1,7,"g.tbl.punish_traffic.safe")

g.tbl.punish_traffic.veh_size=menu_add_feature("Increase bubble size in vehicle", "value_i", g.prnt.utils_trffc.id,function(f)
	g.tbl.punish_traffic.start_debug(true,true)
end)
funcs.set_feat_i_f(g.tbl.punish_traffic.veh_size,1,10,1,2,"g.tbl.punish_traffic.veh_size")

g.tbl.punish_traffic.veh_size_hist={}
function g.tbl.punish_traffic.get_my_veh_size()
	if g.tbl.punish_traffic.veh_size.on and funcs.ME._in_veh() then
		if g.tbl.punish_traffic.veh_size_hist[API.ent.get.model_hash(funcs.ME._veh())] == nil then
			local _min,_max = API.ent.get.dimensions(funcs.ME._veh())
			if _min ~= nil and _max ~= nil then
				g.tbl.punish_traffic.veh_size_hist[API.ent.get.model_hash(funcs.ME._veh())]=_max.y+mth.abs(_min.y)
				g.tbl.punish_traffic.veh_dmnsns = (_max.y+mth.abs(_min.y)+1)/6.9+((_max.y+mth.abs(_min.y)+1)*g.tbl.punish_traffic.veh_size.value/10)
			end
		else
			g.tbl.punish_traffic.veh_dmnsns = (g.tbl.punish_traffic.veh_size_hist[API.ent.get.model_hash(funcs.ME._veh())]+1)/6.9+((g.tbl.punish_traffic.veh_size_hist[API.ent.get.model_hash(funcs.ME._veh())]+1)*g.tbl.punish_traffic.veh_size.value/10)
		end
	else
		g.tbl.punish_traffic.veh_dmnsns=0
	end
end

g.tbl.punish_traffic.veh_size_ofst={}
function g.tbl.punish_traffic.get_veh_size_ofst(_veh)
	if g.tbl.punish_traffic.veh_size_ofst[API.ent.get.model_hash(_veh)] == nil then
		local _min,_max = API.ent.get.dimensions(_veh)
		if _min ~= nil and _max ~= nil then
			g.tbl.punish_traffic.veh_size_ofst[API.ent.get.model_hash(_veh)]=(_max.y+mth.abs(_min.y))/3
			return g.tbl.punish_traffic.veh_size_ofst[API.ent.get.model_hash(_veh)]
		end
		return 1
	end
	return g.tbl.punish_traffic.veh_size_ofst[API.ent.get.model_hash(_veh)]
end

function g.tbl.punish_traffic.start_debug(_bubl,_safe)
	g.tbl.punish_traffic.show_debug.on=true
	g.tbl.punish_traffic.show_bubl=_bubl
	g.tbl.punish_traffic.show_safe=_safe
end

g.tbl.punish_traffic.show_debug=og_menu_add_feature("Show  debugs HIDDEN", "toggle", g.prnt.utils_trffc.id,function(f)
	local time,red_time,green_time,my_pos,vel_pos,red_size = TIME_MS() + 5000,TIME_MS(),TIME_MS()
	while time > TIME_MS() do
		YIELD(5)
		g.tbl.punish_traffic.get_my_veh_size()
		my_pos,vel_pos = g.tbl.punish_traffic.get_my_pos()
		if g.tbl.punish_traffic.show_bubl then
			red_time = TIME_MS()+5000
			time = TIME_MS() + 5000
			g.tbl.punish_traffic.show_bubl=false
		end
		if g.tbl.punish_traffic.show_safe then
			green_time = TIME_MS()+5000
			time = TIME_MS() + 5000
			g.tbl.punish_traffic.show_safe=false
		end
		if red_time > TIME_MS() then
			red_size = v3(
			g.tbl.punish_traffic.bubl.value+g.tbl.punish_traffic.veh_dmnsns,
			g.tbl.punish_traffic.bubl.value+g.tbl.punish_traffic.veh_dmnsns,
			g.tbl.punish_traffic.bubl.value+g.tbl.punish_traffic.veh_dmnsns)
			if g.tbl.punish_traffic.below.on then
				graphics.draw_marker(1, v3(my_pos.x,my_pos.y,my_pos.z-(0.01169*g.tbl.punish_traffic.bubl.value)), funcs.vec(0, -180, 0), funcs.vec(0, -180, 0),red_size*1.97099+funcs.vec(0,0,red_size.z*10),255,0, 0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeVerticalCylinder", false)
				graphics.draw_marker(1, v3(vel_pos.x,vel_pos.y,vel_pos.z-(0.01169*g.tbl.punish_traffic.bubl.value)), funcs.vec(0, -180, 0), funcs.vec(0, -180, 0),red_size*1.97099+funcs.vec(0,0,red_size.z*10),255,0, 0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeVerticalCylinder", false)
			end
			if g.tbl.punish_traffic.above.on then
				graphics.draw_marker(1, v3(my_pos.x,my_pos.y,my_pos.z+(0.01169*g.tbl.punish_traffic.bubl.value)), funcs.vec(0, 0, 0), funcs.vec(0, 0, 0),red_size*1.97099+funcs.vec(0,0,red_size.z*10),255,0,0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeVerticalCylinder", false)
				graphics.draw_marker(1, v3(vel_pos.x,vel_pos.y,vel_pos.z+(0.01169*g.tbl.punish_traffic.bubl.value)), funcs.vec(0, 0, 0), funcs.vec(0, 0, 0),red_size*1.97099+funcs.vec(0,0,red_size.z*10),255,0,0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeVerticalCylinder", false)
			end
			if not g.tbl.punish_traffic.below.on or not g.tbl.punish_traffic.above.on then
				graphics.draw_marker(28, my_pos, funcs.vec(0, 90, 0), funcs.vec(0, 90, 0),red_size,255, 0, 0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
				graphics.draw_marker(28, vel_pos, funcs.vec(0, 90, 0), funcs.vec(0, 90, 0),red_size,255, 0, 0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
			end
		end
		if green_time > TIME_MS() then
			graphics.draw_marker(28, my_pos, funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), v3(g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns, g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns, g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns), 0, 255, 0, mth.flr((green_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
			graphics.draw_marker(28, vel_pos, funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), v3(g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns, g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns, g.tbl.punish_traffic.safe.value+g.tbl.punish_traffic.veh_dmnsns), 0, 255, 0, mth.flr((green_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
		end
	end
	f.on=false
end)
g.tbl.punish_traffic.show_debug.hidden=true
g.tbl.punish_traffic.hide(true)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp = {}
g.tbl.veh_esp.loaded=false

g.tbl.veh_esp.png_true = {}
g.tbl.veh_esp.png_int = {}
g.tbl.veh_esp.png_rot_true = {}
g.tbl.veh_esp.veh_table = {}

g.tbl.veh_esp.file_paths = {
"\\scripts\\GeeSkid_v2\\Images\\Vehicle ESP\\veh_rotate",
"\\scripts\\GeeSkid_v2\\Images\\Vehicle ESP\\veh_rotate\\generic",
"\\scripts\\GeeSkid_v2\\Images\\Vehicle ESP\\veh_no_rotate",
"\\scripts\\GeeSkid_v2\\Images\\Vehicle ESP\\veh_no_rotate\\generic"
}

function g.tbl.veh_esp.line_color_get(is_me,frnd,dist)
	if is_me then
		return g.tbl.veh_esp.line_self_r.value,g.tbl.veh_esp.line_self_g.value,g.tbl.veh_esp.line_self_b.value,g.tbl.veh_esp.line_self_a.value
	elseif frnd then
		return g.tbl.veh_esp.line_frnd_r.value,g.tbl.veh_esp.line_frnd_g.value,g.tbl.veh_esp.line_frnd_b.value,g.tbl.veh_esp.line_frnd_a.value
	elseif dist < g.tbl.veh_esp.line_near_dist.value then
		return g.tbl.veh_esp.line_near_r.value,g.tbl.veh_esp.line_near_g.value,g.tbl.veh_esp.line_near_b.value,g.tbl.veh_esp.line_near_a.value
	end
	return g.tbl.veh_esp.line_far_r.value,g.tbl.veh_esp.line_far_g.value,g.tbl.veh_esp.line_far_b.value,g.tbl.veh_esp.line_far_a.value
end


g.tbl.veh_esp.feat=menu_add_feature("Vehicle ESP 2.0", "toggle", g.prnt.utils_info_esp.id, function(f)
	while not g.var.GS_has_loaded or not g.tbl.veh_esp.loaded or not g.feat.map_tp do
		YIELD(1000)
	end
	local dist,spin_z,bool,screen_x,screen_y,screen_pos,size,blip,_r,_g,_b,all_veh,veh,name,rot,name_pos_y,name_pos_y_G,name_pos_y_temp,text_size,text_x,text_y,text_x_offst,text_y_offst,_flags  = 0,0
	local show_name,show_veh,show_health,show_pssngr,show_dist,my_bool,_my_screen_pos,my_screen_x,my_screen_y,cam_pos_final
	local do_g_blink_now,blink_time,all_veh_time,veh_name,plyr_name,pssngr_count,show_p,tr,tg,tb,lr,lg,lb,la,show_g,do_g_blink = false,TIME_MS()+669,TIME_MS()-2000
	local vehT,x_pos_mult,show_line_value,text_from_top_value,show_veh_god_value,show_veh_god_on,text_size_value,text_space_value,veh_esp_dist_max,blip_size_dist_value,show_plyr_name_value,show_veh_name_value,show_veh_health_value,show_veh_pssngr_value
	local show_veh_dist_value,show_plyr_name_on,show_veh_name_on,show_veh_dist_on,show_veh_prsnl_on,show_veh_health_type_value,dist_type_str,text_vis_value,veh_esp_vis_value,my_pos,veh_esp_line_feat_value,veh_coords,veh_esp_line_feat_on,cam_rot_z,show_veh_health_on,show_veh_pssngr_on
	local get_text_sort = {}
	local function show_line()
		if show_line_value == 2 then
			return true
		elseif show_line_value == 1 then
			return (g.tbl.veh_esp.veh_table[veh].PID_CNT==0)
		end
		return (g.tbl.veh_esp.veh_table[veh].PID_CNT>0)
	end
	local function get_text_sort(_valt,_vals)
		if text_from_top_value == 0 then
			return _valt,_vals
		elseif text_from_top_value == 1 then
			get_text_sort[1]=show_name
			get_text_sort[2]=show_veh
			get_text_sort[3]=show_pssngr
			get_text_sort[4]=show_dist
			local count = 0
			for i=1, #get_text_sort do
				if get_text_sort[i] then
					count=count+1
				end
			end
			return _valt,(_vals+(_valt *count*.5))
		else
			return _valt*-1,_vals
		end
	end
	local script_size = funcs.get.SD_size(f.on)
	if f.on then
		funcs.doo.veh_esp_info_thread()
	end
	while f.on do

		YIELD(5)
		if not g.feat.map_tp.on then
			if all_veh_time+500 < TIME_MS() then
				all_veh_time = TIME_MS()
				all_veh=API.veh.get.all()
			end
			if blink_time < TIME_MS() then
				do_g_blink_now=funcs.get.opp_bool(do_g_blink_now)
				if do_g_blink_now then blink_time = TIME_MS()+250 else blink_time = TIME_MS()+750 end
			end
			if spin_z >= 360 then spin_z = 0 else spin_z = spin_z + 1.875 end
			_flags=(1<<1)--shadow
			x_pos_mult=1
			if g.tbl.veh_esp.text_jstfctn.value == 1 then
				_flags=_flags+(1<<0)
				x_pos_mult=(2/3)
			elseif g.tbl.veh_esp.text_jstfctn.value == 2 then
				_flags=_flags+(1<<4)
			end
			show_line_value = g.tbl.veh_esp.line_show_for.value
			text_from_top_value = g.tbl.veh_esp.text_from_top.value
			show_veh_god_value = g.tbl.veh_esp.show_veh_god.value
			show_veh_god_on = g.tbl.veh_esp.show_veh_god.on
			text_size_value = g.tbl.veh_esp.text_size.value
			text_space_value = g.tbl.veh_esp.text_space.value
			blip_size_dist_value = g.tbl.veh_esp.blip_size_dist.value
			show_plyr_name_value = g.tbl.veh_esp.show_plyr_name.value
			show_veh_name_value = g.tbl.veh_esp.show_veh_name.value
			tr,tg,tb = g.tbl.veh_esp.text_r.value,g.tbl.veh_esp.text_g.value,g.tbl.veh_esp.text_b.value
			veh_esp_dist_max = g.tbl.veh_esp.dist.max
			size = (((veh_esp_dist_max-dist)/veh_esp_dist_max*3)+1.25)*.3*g.tbl.veh_esp.blip_size.value*g.RES
			text_x_offst = g.tbl.veh_esp.text_x.value*.01
			text_y_offst = g.tbl.veh_esp.text_y.value*.01
			show_veh_health_value = g.tbl.veh_esp.show_veh_health.value
			show_veh_health_on = g.tbl.veh_esp.show_veh_health.on
			show_veh_pssngr_value = g.tbl.veh_esp.show_veh_pssngr.value
			show_veh_pssngr_on = g.tbl.veh_esp.show_veh_pssngr.on
			show_veh_dist_value = g.tbl.veh_esp.show_veh_dist.value
			show_plyr_name_on = g.tbl.veh_esp.show_plyr_name.on
			show_veh_name_on = g.tbl.veh_esp.show_veh_name.on
			show_veh_dist_on = g.tbl.veh_esp.show_veh_dist.on
			show_veh_prsnl_on = g.tbl.veh_esp.show_veh_prsnl.on
			show_veh_health_type_value = g.tbl.veh_esp.show_veh_health_type.value
			dist_type_str = g.tbl.dist_type_str[g.tbl.veh_esp.dist_type.value]
			text_vis_value = g.tbl.veh_esp.text_vis.value
			veh_esp_vis_value = g.tbl.veh_esp.vis.value
			veh_esp_line_feat_on = g.tbl.veh_esp.line_feat.on
			my_pos = API.plyr.get.coords(API.plyr.my_id())
			_my_screen_pos = funcs.get.screen_pos_3d(my_pos)
			veh_esp_line_feat_value = g.tbl.veh_esp.line_feat.value
			cam_rot_z = API.cam.get.rot_final().z*-1
			for i=1,#all_veh do
				veh = all_veh[i]
				vehT = g.tbl.veh_esp.veh_table[veh]
				if vehT ~= nil and vehT.SHOW and API.ent.is.ent(veh) then
					veh_coords = API.ent.get.coords(veh)
					screen_pos = funcs.get.screen_pos_3d(veh_coords)
					if screen_pos then
						if vehT.SPIN then
							rot = funcs.get.sprt_rot_calc(spin_z)
						elseif vehT.ROT then
							rot = funcs.get.sprt_rot_calc(API.ent.get.rotation(veh).z-funcs.get.vctr_to_pos_z(funcs.vec(0,100000,0),veh).z+cam_rot_z)
						else
							rot = 0
						end
						show_g,do_g_blink=false,false
						if show_veh_god_on and vehT.GOD then
							if show_veh_god_value == 2 then show_g = true do_g_blink = true elseif  show_veh_god_value == 0 then show_g = true else do_g_blink = true end
						end
						show_p = false
						dist = vehT.DISTC
						if do_g_blink and do_g_blink_now then
							_r,_g,_b = 255,0,0
						else
							_r,_g,_b = vehT.R,vehT.G,vehT.B
						end


						for i=1, mth.flr(dist/(veh_esp_dist_max*0.0125)) do
							if i > blip_size_dist_value then break else size=size*.95	end
						end
						name_pos_y = (0.01169*size*text_size_value*text_space_value)*1.05*(2160/API.gfx.get_h())

						name_pos_y_G = (0.01169*size*text_size_value*text_space_value)*1.05*1.5
						show_name = (show_plyr_name_on and dist < show_plyr_name_value)
						show_veh = (show_veh_name_on and dist < show_veh_name_value)
						show_health = (show_veh_health_on and dist < show_veh_health_value)
						show_pssngr = (show_veh_pssngr_on and dist < show_veh_pssngr_value)
						show_dist = (show_veh_dist_on and dist < show_veh_dist_value)
						name_pos_y,text_y = get_text_sort(name_pos_y,screen_pos.y)
						text_size = .1*(size*1.1)*text_size_value
						name_pos_y_temp=name_pos_y
						if veh_esp_line_feat_on and show_line() then
							lr,lg,lb,la = g.tbl.veh_esp.line_color_get(vehT.ME,vehT.FRND,dist)
							if veh_esp_line_feat_value == 0 then
								API.SD.draw_line(_my_screen_pos or funcs.vec(0,-1),screen_pos, mth.flr(size), funcs.get.rgba_to_int(lr,lg,lb,la))
							else
								ui.draw_line(my_pos, veh_coords, lr,lg,lb,la)
							end
						end
						if text_size < 0.09 then text_size = 0.09 end
						text_size=text_size*script_size
						text_x = screen_pos.x*x_pos_mult

						if show_name then
							if show_veh_prsnl_on and vehT.PERS ~= nil and (vehT.PERS_DRVR or vehT.PID_CNT==0) then
								plyr_name = "*P* "
								show_p=true
							else
								plyr_name = ""
							end
							plyr_name = plyr_name..vehT.NAME
							API.SD.draw_text(plyr_name,funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							name_pos_y_temp = name_pos_y_temp + (name_pos_y)
						end
						if show_veh then
							if not show_p and show_veh_prsnl_on and (vehT.PERS ~= nil) then
								veh_name = "*P* "
							else
								veh_name = ""
							end
							veh_name = veh_name..funcs.get.veh_model_name(veh)
							API.SD.draw_text(veh_name,funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							name_pos_y_temp = name_pos_y_temp + (name_pos_y)
						end
						if show_health then
							if show_veh_health_type_value == 0 then
								API.SD.draw_text("Engine: "..funcs.get._1_dec(ntv.get.veh_engine_health(veh,true)).."%",funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							elseif show_veh_health_type_value == 1 then
								API.SD.draw_text("Body: "..funcs.get._1_dec(ntv.get.veh_body_health(veh,true)).."%",funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							else
								API.SD.draw_text("Health: "..funcs.get._1_dec(funcs.get.veh_cmbnd_health_prcnt(veh,true)).."%",funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							end
							name_pos_y_temp = name_pos_y_temp + (name_pos_y)
						end
						if show_pssngr then
							if vehT.PID_CNT == 0 and vehT.NPC_CNT == 0 then
								pssngr_count="<Empty>"
							elseif vehT.PID_CNT == 1 then
								pssngr_count="<1 player>"
							elseif vehT.PID_CNT > 1 then
								pssngr_count="<"..vehT.PID_CNT.." players>"
							elseif vehT.NPC_CNT == 1 then
								pssngr_count="<1 ped>"
							else
								pssngr_count="<"..vehT.NPC_CNT.." peds>"
							end
							API.SD.draw_text(pssngr_count,funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
							name_pos_y_temp = name_pos_y_temp + (name_pos_y)
						end
						if show_dist then
							API.SD.draw_text(funcs.get.dist_to_str(vehT.DISTM,dist_type_str),funcs.vec(text_x+text_x_offst,text_y-name_pos_y_temp+text_y_offst),funcs.vec(text_x,screen_pos.y),text_size*6,funcs.get.rgba_to_int(tr,tg,tb,mth.flr(255*text_vis_value)),_flags,nil)
						end
						API.SD.draw_sprt(vehT.BLIP,screen_pos,size,rot,funcs.get.rgba_to_int(_r,_g,_b,mth.flr(255*veh_esp_vis_value)))
						if show_g then
							API.SD.draw_text("G",funcs.vec(screen_pos.x*(2/3)+(g.tbl.veh_esp.god_x.value*0.01),screen_pos.y*2+(name_pos_y_G)+(g.tbl.veh_esp.god_y.value*0.01)),funcs.vec(screen_pos.x*(2/3),screen_pos.y*2),size,funcs.get.rgba_to_int(255,0,0,mth.flr(255*text_vis_value)),((1<<0)+(1<<2)+(1<<1)),nil)
						end


					end
				end
			end
		end
	end
end)
funcs.add_to_S_L(g.tbl.veh_esp.feat,"g.tbl.veh_esp.feat")
g.tbl.veh_esp.feat.on=true


function funcs.doo.veh_esp_info_thread()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local all_veh,veh_pos
		local pids,npcs,R,G,B,name,frnd,class,hash,pers_name,pers_driver,spcfc,gnrc,weap,blip,rot,spin,show,been_owned
		local my_veh,my_pos,distm,distc
		local veh_is_pid,hash_is_name,pers_vehs={},{},{}
		local Buzzard,Savage = API.get_hash_key("buzzard"),API.get_hash_key("savage")
		local pid_once
		local this_ped
		local function show_non_plyr(_veh)
			if g.tbl.veh_esp.show_veh_non_plyr.on then
				if g.tbl.veh_esp.show_veh_non_plyr.value == 1 then
					return ntv.is.veh_have_weap(_veh)
				end
				return true
			end
			return false
		end
		while  g.tbl.veh_esp.feat.on do
			all_veh=API.veh.get.all()
			my_veh = funcs.ME._in_veh() and funcs.ME._veh() or nil
			funcs.doo.wipe_tbl(veh_is_pid)
			funcs.doo.wipe_tbl(hash_is_name)
			funcs.doo.wipe_tbl(pers_vehs)
			for i=0,31 do
				if API.plyr.is.valid(i) then
					local this_name  = funcs.get.pid_name(i)
					veh_is_pid[g.tbl.PID_INFO.veh[i+1]]=i
					hash_is_name[network.network_hash_from_player(i)]=this_name
					local temp_veh = glbls.get_pid_pers_veh(i)
					if temp_veh then
						pers_vehs[temp_veh]=this_name
					end
				end
			end
			my_pos=API.cam.get.pos_final()
			distc=g.tbl.veh_esp.math[g.tbl.veh_esp.dist_type.value+1]
			veh_esp_dist_value = g.tbl.veh_esp.dist.value
			for k,veh in pairs(all_veh) do
				if not g.tbl.veh_esp.feat.on then
					break
				else
					show=false
					if API.ent.is.veh(veh) and not API.ent.is.dead(veh) and (g.tbl.veh_esp.show_veh_crrnt.on or veh~=my_veh) then
						veh_pos=API.ent.get.coords(veh)
						class = API.veh.get.class_name(veh)
						hash = API.ent.get.model_hash(veh)
						if veh_pos.z>-51 and (g.tbl.veh_esp.png_true[hash] or g.tbl.veh_esp.png_true[class]) then
							distm=funcs.get.dist_pospos_v3(my_pos,veh_pos)
							if distm*distc <= veh_esp_dist_value then
								pid_once=false
								pids,npcs,name,frnd=0,0,"",false
								R,G,B=255,255,255
								for s = 1, funcs.get.veh_seats(veh) do
									this_ped = API.veh.get.ped_in_seat(veh, s-2)
									if API.ent.is.ped(this_ped) then
										if API.Ped.is.plyr(this_ped) then
											if not pid_once then
												pid_once=API.plyr.get.plyr_from_ped(this_ped)
												rgbs = funcs.get.rgba_from_pid(pid_once)
												R,G,B=g.tbl.PID_OSD.plyr_rgb(pid_once+1,nil)
												name=funcs.get.pid_name(pid_once)
												frnd=API.plyr.is.friend(pid_once)
											end
											pids=pids+1
										else
											npcs=npcs+1
										end
									end
								end
								if not pid_once and veh_is_pid[veh] then
									R,G,B=g.tbl.PID_OSD.plyr_rgb(veh_is_pid[veh]+1,nil)
									name=funcs.get.pid_name(veh_is_pid[veh])
									frnd=API.plyr.is.friend(veh_is_pid[veh])
								end
								if name == "" and npcs > 0 then
									name="NPC"
								end
								pers_name=pers_vehs[veh]
								pers_driver = (pers_name==name)
								if g.tbl.veh_esp.png_true[hash] then
									if API.veh.get.been_owned(veh) or show_non_plyr(veh) then
										show=true
										blip = g.tbl.veh_esp.png_int[hash]
										rot = g.tbl.veh_esp.png_rot_true[hash]
										spin = (hash == Buzzard or hash == Savage) and pids+npcs > 0
									end
								elseif show_non_plyr(veh) or pids>0 or pers_name or (name ~= "" and name ~= "NPC") then
									show=true
									blip = g.tbl.veh_esp.png_int[class]
									rot = g.tbl.veh_esp.png_rot_true[class]
									spin = class == "Helicopters" and pids+npcs > 0
								end
							end
						end
					end
					g.tbl.veh_esp.veh_table[veh] = g.tbl.veh_esp.veh_table[veh] or {}
					if show then
						g.tbl.veh_esp.veh_table[veh].SHOW = true
						g.tbl.veh_esp.veh_table[veh].DISTM = distm
						g.tbl.veh_esp.veh_table[veh].DISTC = distc
						g.tbl.veh_esp.veh_table[veh].SPCFC = spcfc
						g.tbl.veh_esp.veh_table[veh].GNRC = gnrc
						g.tbl.veh_esp.veh_table[veh].R = R
						g.tbl.veh_esp.veh_table[veh].G = G
						g.tbl.veh_esp.veh_table[veh].B = B
						g.tbl.veh_esp.veh_table[veh].NAME = name
						g.tbl.veh_esp.veh_table[veh].BLIP = blip
						g.tbl.veh_esp.veh_table[veh].ROT = rot
						g.tbl.veh_esp.veh_table[veh].SPIN = spin
						g.tbl.veh_esp.veh_table[veh].PERS = pers_name
						g.tbl.veh_esp.veh_table[veh].PERS_DRVR = pers_driver
						g.tbl.veh_esp.veh_table[veh].INVEH = pids>0
						g.tbl.veh_esp.veh_table[veh].PID_CNT = pids
						g.tbl.veh_esp.veh_table[veh].GOD = API.ent.get.god(veh)
						g.tbl.veh_esp.veh_table[veh].FRND = frnd
						g.tbl.veh_esp.veh_table[veh].ME = (veh==my_veh)
						g.tbl.veh_esp.veh_table[veh].NPC_CNT = npcs
					else
						g.tbl.veh_esp.veh_table[veh].SHOW=false
					end
				end
				if k%10==0 then
					YIELD(0)
				end
			end
			YIELD(69)
		end
	end)
end


function g.tbl.veh_esp.math_do()
	local function get_and_set_val(_feat)
		local _max = (g.tbl.veh_esp.math_max[g.tbl.veh_esp.dist_type.value+1])
		local _min = (_max*0.05)
		local _mod = (_max*0.05)
		local _val = (_max*(_feat.value/_feat.max))
		funcs.set_feat_i_f(_feat,_min,_max,_mod,_val)
	end
	get_and_set_val(g.tbl.veh_esp.dist)
	get_and_set_val(g.tbl.veh_esp.show_plyr_name)
	get_and_set_val(g.tbl.veh_esp.show_veh_name)
	get_and_set_val(g.tbl.veh_esp.show_veh_pssngr)
	get_and_set_val(g.tbl.veh_esp.show_veh_dist)
	get_and_set_val(g.tbl.veh_esp.line_near_dist)
	get_and_set_val(g.tbl.veh_esp.show_veh_health)
end

g.tbl.veh_esp.math = {
1, 				-- meter
0.001,			-- km
3.28084,		-- ft
1.09361,		-- yard
0.003645367,	-- footbal field
0.000621371,	-- mile
7.874016,		-- asian dick
3.937008		-- bbc
}

g.tbl.veh_esp.math_max ={}
for i=1,8 do
	g.tbl.veh_esp.math_max[i] = g.tbl.veh_esp.math[i]*2000
end

g.tbl.veh_esp.dist_type=menu_add_feature("Distance measurement","autoaction_value_str", g.prnt.utils_info_esp.id, function(f)
	g.tbl.veh_esp.math_do()
end)
new_set_str_data(g.tbl.veh_esp.dist_type,{"Meters","Kilometers","Feet","Yards","Football fields","Miles","Tiny dick","BBC"})
funcs.add_to_S_L(g.tbl.veh_esp.dist_type,"g.tbl.veh_esp.dist_type")

g.tbl.veh_esp.vis = menu_add_feature("Blip visibility","autoaction_value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.vis,.1,1,.05,1,"g.tbl.veh_esp.vis")

g.tbl.veh_esp.dist = menu_add_feature("Blip max distance","autoaction_value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.dist,0.0001,100000,0.0001,1000,"g.tbl.veh_esp.dist")

g.tbl.veh_esp.blip_size = menu_add_feature("Blip size","autoaction_value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.blip_size,.25,2,.05,1,"g.tbl.veh_esp.blip_size")

g.tbl.veh_esp.blip_size_dist = menu_add_feature("Blip size/distance impact","autoaction_value_i",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.blip_size_dist,1,10,1,1,"g.tbl.veh_esp.blip_size_dist")

g.tbl.veh_esp.show_plyr_name = menu_add_feature("Show player name|Max dist:","value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.show_plyr_name,0.0001,100000,0.0001,2000,"g.tbl.veh_esp.show_plyr_name")
g.tbl.veh_esp.show_plyr_name.on=true

g.tbl.veh_esp.show_veh_name = menu_add_feature("Show vehicle name|Max dist:","value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.show_veh_name,0.0001,100000,0.0001,700,"g.tbl.veh_esp.show_veh_name")
g.tbl.veh_esp.show_veh_name.on=true

g.tbl.veh_esp.show_veh_health = menu_add_feature("Show health|Max dist:","value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.show_veh_health,0.0001,100000,0.0001,700,"g.tbl.veh_esp.show_veh_health")
g.tbl.veh_esp.show_veh_health.on=true

g.tbl.veh_esp.show_veh_health_type=menu_add_feature("Vehicle health","action_value_str", g.prnt.utils_info_esp.id)
new_set_str_data(g.tbl.veh_esp.show_veh_health_type,{"Engine","Body","Enhanced total"})
funcs.add_to_S_L(g.tbl.veh_esp.show_veh_health_type,"g.tbl.veh_esp.show_veh_health_type")
g.tbl.veh_esp.show_veh_health_type.value=2

g.tbl.veh_esp.show_veh_pssngr = menu_add_feature("Show passenger count|Max dist:","value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.show_veh_pssngr,0.0001,100000,0.0001,700,"g.tbl.veh_esp.show_veh_pssngr")
g.tbl.veh_esp.show_veh_pssngr.on=true

g.tbl.veh_esp.show_veh_dist = menu_add_feature("Show distance|Max dist:","value_f",g.prnt.utils_info_esp.id)
funcs.set_feat_i_f(g.tbl.veh_esp.show_veh_dist,0.0001,100000,0.0001,700,"g.tbl.veh_esp.show_veh_dist")
g.tbl.veh_esp.show_veh_dist.on=true

g.tbl.veh_esp.show_veh_prsnl = menu_add_feature("Show if personal vehicle (*P*)","toggle",g.prnt.utils_info_esp.id)
funcs.add_to_S_L(g.tbl.veh_esp.show_veh_prsnl,"g.tbl.veh_esp.show_veh_prsnl")
g.tbl.veh_esp.show_veh_prsnl.on=true

g.tbl.veh_esp.show_veh_crrnt = menu_add_feature("Show current vehicle","toggle",g.prnt.utils_info_esp.id)
funcs.add_to_S_L(g.tbl.veh_esp.show_veh_crrnt,"g.tbl.veh_esp.show_veh_crrnt")
g.tbl.veh_esp.show_veh_crrnt.on=true

g.tbl.veh_esp.show_veh_non_plyr = menu_add_feature("Show non-player vehicles","value_str",g.prnt.utils_info_esp.id)
new_set_str_data(g.tbl.veh_esp.show_veh_non_plyr,{"Always","If has weapons"})
funcs.add_to_S_L(g.tbl.veh_esp.show_veh_non_plyr,"g.tbl.veh_esp.show_veh_non_plyr")
g.tbl.veh_esp.show_veh_non_plyr.on=true
g.tbl.veh_esp.show_veh_non_plyr.value=1
-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.god_prnt = menu_add_feature("Vehicle god","parent",g.prnt.utils_info_esp.id)

g.tbl.veh_esp.show_veh_god = menu_add_feature("Show vehicle god","value_str",g.tbl.veh_esp.god_prnt.id)
new_set_str_data(g.tbl.veh_esp.show_veh_god,{"Red 'G'","Blink red","Both"})
funcs.add_to_S_L(g.tbl.veh_esp.show_veh_god,"g.tbl.veh_esp.show_veh_god")
g.tbl.veh_esp.show_veh_god.on=true

g.tbl.veh_esp.god_x = menu_add_feature("X Pos Offset", "action_value_f",g.tbl.veh_esp.god_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.god_x,-10,10,0.1,0,"g.tbl.veh_esp.god_x")

g.tbl.veh_esp.god_y = menu_add_feature("Y Pos Offset", "action_value_f",g.tbl.veh_esp.god_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.god_y,-10,10,0.1,0,"g.tbl.veh_esp.god_y")

-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.text_prnt = menu_add_feature("ESP Text","parent",g.prnt.utils_info_esp.id)

g.tbl.veh_esp.text_vis = menu_add_feature("Visibility","autoaction_value_f",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_vis,.1,1,.05,1,"g.tbl.veh_esp.text_vis")

g.tbl.veh_esp.text_size = menu_add_feature("Size","autoaction_value_f",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_size,.1,2,.05,1,"g.tbl.veh_esp.text_size")

g.tbl.veh_esp.text_space = menu_add_feature("Spacing","action_value_f",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_space,.1,10,.05,1,"g.tbl.veh_esp.text_space")

g.tbl.veh_esp.text_jstfctn = menu_add_feature("Justification", "action_value_str",g.tbl.veh_esp.text_prnt.id)
new_set_str_data(g.tbl.veh_esp.text_jstfctn,{"Left","Center","Right"})
funcs.add_to_S_L(g.tbl.veh_esp.text_jstfctn,"g.tbl.veh_esp.text_jstfctn")
g.tbl.veh_esp.text_jstfctn.value=1

g.tbl.veh_esp.text_from_top = menu_add_feature("Display info stack","action_value_str",g.tbl.veh_esp.text_prnt.id)
new_set_str_data(g.tbl.veh_esp.text_from_top,{"From top","Center","From bottom"})
funcs.add_to_S_L(g.tbl.veh_esp.text_from_top,"g.tbl.veh_esp.text_from_top")

g.tbl.veh_esp.text_x = menu_add_feature("X Pos Offset", "action_value_f",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_x,-10,10,0.1,0,"g.tbl.veh_esp.text_x")
g.tbl.veh_esp.text_y = menu_add_feature("Y Pos Offset", "action_value_f",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_y,-10,10,0.1,0,"g.tbl.veh_esp.text_y")

g.tbl.veh_esp.text_r = menu_add_feature("Text R", "action_value_i",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_r,0,255,5,255,"g.tbl.veh_esp.text_r")

g.tbl.veh_esp.text_g = menu_add_feature("Text G", "action_value_i",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_g,0,255,5,255,"g.tbl.veh_esp.text_g")

g.tbl.veh_esp.text_b = menu_add_feature("Text B", "action_value_i",g.tbl.veh_esp.text_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.text_b,0,255,5,255,"g.tbl.veh_esp.text_b")

-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.line_prnt = menu_add_feature("ESP Lines","parent",g.prnt.utils_info_esp.id)

g.tbl.veh_esp.line_feat=menu_add_feature("Show ESP Lines","value_str", g.tbl.veh_esp.line_prnt.id)
new_set_str_data(g.tbl.veh_esp.line_feat,{"Type 1","Type 2"})
funcs.add_to_S_L(g.tbl.veh_esp.line_feat,"g.tbl.veh_esp.line_feat")
g.tbl.veh_esp.line_feat.on=true

g.tbl.veh_esp.line_show_for=menu_add_feature("Vehicle selection","action_value_str", g.tbl.veh_esp.line_prnt.id)
new_set_str_data(g.tbl.veh_esp.line_show_for,{"Has player","No player","Both"})
funcs.add_to_S_L(g.tbl.veh_esp.line_show_for,"g.tbl.veh_esp.line_show_for")

g.tbl.veh_esp.line_near_dist = menu_add_feature("Near distance", "action_value_f",g.tbl.veh_esp.line_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_near_dist,0.0001,100000,0.0001,300,"g.tbl.veh_esp.line_near_dist")

g.tbl.veh_esp.line_near_prnt = menu_add_feature("Near color","parent",g.tbl.veh_esp.line_prnt.id)
g.tbl.veh_esp.line_far_prnt = menu_add_feature("Far color","parent",g.tbl.veh_esp.line_prnt.id)
g.tbl.veh_esp.line_friend_prnt = menu_add_feature("Friend color","parent",g.tbl.veh_esp.line_prnt.id)
g.tbl.veh_esp.line_self_prnt = menu_add_feature("Self color","parent",g.tbl.veh_esp.line_prnt.id)
-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.line_near_r = menu_add_feature("Red", "action_value_i",g.tbl.veh_esp.line_near_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_near_r,0,255,5,255,"g.tbl.veh_esp.line_near_r")
g.tbl.veh_esp.line_near_g = menu_add_feature("Green", "action_value_i",g.tbl.veh_esp.line_near_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_near_g,0,255,5,0,"g.tbl.veh_esp.line_near_g")
g.tbl.veh_esp.line_near_b = menu_add_feature("Blue", "action_value_i",g.tbl.veh_esp.line_near_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_near_b,0,255,5,0,"g.tbl.veh_esp.line_near_b")
g.tbl.veh_esp.line_near_a = menu_add_feature("Alpha", "action_value_i",g.tbl.veh_esp.line_near_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_near_a,0,255,5,255,"g.tbl.veh_esp.line_near_a")
-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.line_far_r = menu_add_feature("Red", "action_value_i",g.tbl.veh_esp.line_far_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_far_r,0,255,5,255,"g.tbl.veh_esp.line_far_r")
g.tbl.veh_esp.line_far_g = menu_add_feature("Green", "action_value_i",g.tbl.veh_esp.line_far_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_far_g,0,255,5,160,"g.tbl.veh_esp.line_far_g")
g.tbl.veh_esp.line_far_b = menu_add_feature("Blue", "action_value_i",g.tbl.veh_esp.line_far_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_far_b,0,255,5,0,"g.tbl.veh_esp.line_far_b")
g.tbl.veh_esp.line_far_a = menu_add_feature("Alpha", "action_value_i",g.tbl.veh_esp.line_far_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_far_a,0,255,5,150,"g.tbl.veh_esp.line_far_a")
-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.line_frnd_r = menu_add_feature("Red", "action_value_i",g.tbl.veh_esp.line_friend_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_frnd_r,0,255,5,93,"g.tbl.veh_esp.line_frnd_r")
g.tbl.veh_esp.line_frnd_g = menu_add_feature("Green", "action_value_i",g.tbl.veh_esp.line_friend_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_frnd_g,0,255,5,182,"g.tbl.veh_esp.line_frnd_g")
g.tbl.veh_esp.line_frnd_b = menu_add_feature("Blue", "action_value_i",g.tbl.veh_esp.line_friend_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_frnd_b,0,255,5,229,"g.tbl.veh_esp.line_frnd_b")
g.tbl.veh_esp.line_frnd_a = menu_add_feature("Alpha", "action_value_i",g.tbl.veh_esp.line_friend_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_frnd_a,0,255,5,150,"g.tbl.veh_esp.line_frnd_a")
-------------------------------------------------------------------------------------------------------------------------------
g.tbl.veh_esp.line_self_r = menu_add_feature("Red", "action_value_i",g.tbl.veh_esp.line_self_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_self_r,0,255,5,0,"g.tbl.veh_esp.line_self_r")
g.tbl.veh_esp.line_self_g = menu_add_feature("Green", "action_value_i",g.tbl.veh_esp.line_self_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_self_g,0,255,5,255,"g.tbl.veh_esp.line_self_g")
g.tbl.veh_esp.line_self_b = menu_add_feature("Blue", "action_value_i",g.tbl.veh_esp.line_self_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_self_b,0,255,5,0,"g.tbl.veh_esp.line_self_b")
g.tbl.veh_esp.line_self_a = menu_add_feature("Alpha", "action_value_i",g.tbl.veh_esp.line_self_prnt.id)
funcs.set_feat_i_f(g.tbl.veh_esp.line_self_a,0,255,5,150,"g.tbl.veh_esp.line_self_a")

g.print_load_info("Vehicle ESP",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Kicks/Crashes"
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
g.tbl.plate_rpr_upgr={}
g.tbl.plate_rpr_upgr.text="Gee-Skid"

function g.tbl.plate_rpr_upgr.file_check()
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.tbl.plate_anim.directory)
	if not utils.file_exists(g.tbl.plate_anim.directory.."Repair or Upgrade.txt") then
		local file = io.open(g.tbl.plate_anim.directory.."Repair or Upgrade.txt", "a")
		file:write("Gee-Skid")
		file:close()
	end
end

function g.tbl.plate_rpr_upgr.file_get()
	g.tbl.plate_rpr_upgr.file_check()
	local file = io.open(g.tbl.plate_anim.directory.."Repair or Upgrade.txt", "r")
	local plate = "Gee-Skid"
	for line in file:lines() do
		if line ~= nil and string.len(tostring(line)) < 9 then
			plate = tostring(line)
			break
		end
	end
	file:close()
	return plate
end

function funcs.plate_t_or_nil()
	if g.tbl.plate_rpr_upgr.tog.on then
		return g.tbl.plate_rpr_upgr.text
	end
	return nil
end

function funcs.plate_i_or_nil()
	if g.tbl.plate_rpr_upgr.style_tog.on then
		return g.tbl.plate_rpr_upgr.style_tog.value
	end
	return nil
end

g.tbl.plate_rpr_upgr.tog=menu_add_feature("Use custom text", "toggle", g.prnt.optns_plate.id, function(f)
	if f.on then
		local plate = g.tbl.plate_rpr_upgr.file_get()
		f.name = "Use custom text: "..plate
		g.tbl.plate_rpr_upgr.text=plate
	end
end)
funcs.add_to_S_L(g.tbl.plate_rpr_upgr.tog,"g.tbl.plate_rpr_upgr.tog")
g.tbl.plate_rpr_upgr.tog.on=true

g.tbl.plate_rpr_upgr.set=menu_add_feature("Set custom license plate", "action_value_str", g.prnt.optns_plate.id, function(f)
	if f.value == 0 then
		g.tbl.plate_rpr_upgr.tog.name="Use custom text: Gee-Skid"
		g.tbl.plate_rpr_upgr.text="Gee-Skid"
	else
		local status,str = 1
		status,str = funcs.get.text_input("Non alpha-numeric characters act as blank space","Gee-Skid",8,0)
		if status == 0 then
			g.tbl.plate_rpr_upgr.file_check()
			local file = io.open(g.tbl.plate_anim.directory.."Repair or Upgrade.txt", "w")
			file:write(str)
			file:close()
			g.tbl.plate_rpr_upgr.tog.name="Use custom text: "..str
			g.tbl.plate_rpr_upgr.text=str
		end
	end
end)
new_set_str_data(g.tbl.plate_rpr_upgr.set,{"Gee-Skid","Custom"})
funcs.add_to_S_L(g.tbl.plate_rpr_upgr.set,"g.tbl.plate_rpr_upgr.set")

g.tbl.plate_rpr_upgr.style_tog=menu_add_feature("Use plate style", "value_str", g.prnt.optns_plate.id)
new_set_str_data(g.tbl.plate_rpr_upgr.style_tog,{"Blue/White","Yellow/black","Yellow/Blue","Blue/White2","Blue/White3","Yankton"})
funcs.add_to_S_L(g.tbl.plate_rpr_upgr.style_tog,"g.tbl.plate_rpr_upgr.style_tog")
g.tbl.plate_rpr_upgr.style_tog.value=1
g.tbl.plate_rpr_upgr.style_tog.on=true
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

g.var.ent_removal_count1=0
g.var.ent_removal_count2=0
menu_add_feature("Remove all spawned entities", "action", g.prnt.optns.id,function()
	g.var.ent_removal_count1 = #g.tbl.entities+#g.tbl.spwn.history
	if count == 0 then
		g.N_P(2,"You have not spawned any entities.",__GV__,5,"Yellow")
	else
		for i=1,#g.tbl.entities do
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local ent,I = g.tbl.entities[i],i
				if funcs.is.ent(ent) then
					if funcs.doo.remove_ent(ent,5000) then
						g.tbl.entities[I]=nil
						g.var.ent_removal_count2=g.var.ent_removal_count2+1
					end
				else
					g.tbl.entities[I]=nil
					g.var.ent_removal_count2=g.var.ent_removal_count2+1
				end
			end)
		end
		for i=1,#g.tbl.spwn.history do
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local ent,I = g.tbl.spwn.history[i],i
				if funcs.is.ent(ent) then
					if funcs.is.veh(ent) then
						for ii=1,funcs.get.veh_seats(ent) do
							if funcs.is.ent(API.veh.get.ped_in_seat(ent,ii-2)) then
								API.Ped.clear_tasks(API.veh.get.ped_in_seat(ent, ii-2))
							end
						end
					end
					if funcs.doo.remove_ent(ent,5000) then
						g.tbl.spwn.history[I]=nil
						g.var.ent_removal_count2=g.var.ent_removal_count2+1
					end
				else
					g.tbl.spwn.history[I]=nil
					g.var.ent_removal_count2=g.var.ent_removal_count2+1
				end
			end)
		end
		local time = TIME_MS()+5000
		while time > TIME_MS() and g.var.ent_removal_count1 ~= g.var.ent_removal_count2 do
			YIELD(0)
		end
		g.N_P(2,g.var.ent_removal_count2 .."/"..g.var.ent_removal_count1 .." Entities removed.",__GV__,5,"Blue")
	end
end)

g.feat.plyr_JL_notif=menu_add_feature("Show player info notification", "value_str", g.prnt.optns.id)
new_set_str_data(g.feat.plyr_JL_notif,{"Joining/Leaving","Joining","Leaving"})
funcs.add_to_S_L(g.feat.plyr_JL_notif,"g.feat.plyr_JL_notif")

g.feat.plyr_JL_print=menu_add_feature("Print player info to console", "value_str", g.prnt.optns.id)
new_set_str_data(g.feat.plyr_JL_print,{"Joining/Leaving","Joining","Leaving"})
funcs.add_to_S_L(g.feat.plyr_JL_print,"g.feat.plyr_JL_print")

g.feat.ff_auto_kick=menu_add_feature("Auto-Kick fake friends with join timeout enabled", "toggle", g.prnt.optns.id, function(f)
	local file_path,file,contents,_start,_end,_last,scid_table,pid_table,_scid,_pid,_ff_sett,_ff_name
	file_path = "scid"
	while f.on do
		funcs.doo.yield_while_true(not g.var.check_fake_friends,2000)
		if g.var.check_fake_friends then
			YIELD(1000)
			g.var.check_fake_friends=false
		end
		scid_table,pid_table = funcs.get.scid_pid_tables()
		if not utils.file_exists(g.paths._cfg..file_path..".cfg") then
			file = io.open(g.paths._cfg..file_path..".cfg", "a")
			file:write("[SCID]")
			file:close()
		end
		file = io.open(g.paths._cfg..file_path..".cfg", "r")
		for line in file:lines() do
			if line == nil then
				break
			else
				_start,_end = string.find(line, ":")
				if _start ~= nil and _end ~= nil then
					--print(string.sub(line,1,_end-1))
					_ff_name = string.sub(line,1,_end-1)
					_last = _end+1
					_start,_end = string.find(line, ":",_last)
					if _start ~= nil and _end ~= nil then
						--print(string.sub(line,_last,_end-1))
						if scid_table[tonumber(string.sub(line,_last,_end-1),16)] then
							_scid = tonumber(string.sub(line,_last,_end-1),16)
							_pid = pid_table[_scid]
							print("Match found "..string.sub(line,_last,_end-1).." ".._scid.." name "..funcs.get.pid_name(_pid).." PID ".._pid)
						else
							_scid = -1
							_pid = -1
						end
						if _scid ~= -1 then
							_last = _end+1
							if string.sub(line,_last,string.len(line)) ~= nil then
								--print(string.sub(line,_last,string.len(line)))
								_ff_sett = string.sub(line,_last,string.len(line))
								if g.tbl.fake_friend_timeout_list[_ff_sett] then
									print("Join timeout enabled "..string.sub(line,_last,_end-1).." ".._scid.." FF name ".._ff_name.." name "..funcs.get.pid_name(_pid).." PID ".._pid)
									funcs.doo.kick_plyr(_pid,true,"Fake friend",_ff_name)
									YIELD(250)
								end
							end
						end
					end
				end
			end
		end
		io.close(file)
		YIELD(0)
	end
end)
funcs.add_to_S_L(g.feat.ff_auto_kick,"g.feat.ff_auto_kick")

g.feat.auto_re_kick=menu_add_feature("Auto-Re-Kick", "value_str", g.prnt.optns.id, function(f)
	local scid_table,pid_table,file,_start,_end,_last,_scid,_pid,_prev_name
	while f.on do
		if g.var.check_re_kick then
			YIELD(1000)
			g.var.check_re_kick=false
			scid_table,pid_table = funcs.get.scid_pid_tables()
			if f.value ~= 2 then
				for i=1, #g.tbl.pid_kicked_mem do
					if scid_table[g.tbl.pid_kicked_mem[i]] then
						funcs.doo.kick_plyr(pid_table[g.tbl.pid_kicked_mem[i]])
						YIELD(250)
						break
					end
				end
			else
				if utils.dir_exists(g.paths._user.."Logs\\") then
					if utils.file_exists(g.paths._user.."Logs\\Player Kicks History.csv") then
						file = io.open(g.paths._user.."Logs\\Player Kicks History.csv", "r")
						for line in file:lines() do
							if line == nil then
								break
							else
								_start,_end = string.find(line, ",")
								if _start ~= nil and _end ~= nil then
									_date = string.sub(line,1,_end-1)
									_last = _end+1
									_start,_end = string.find(line, ",",_last)
									if _start ~= nil and _end ~= nil then
										if scid_table[tonumber(string.sub(line,_last,_end-1))] then
											_scid = tonumber(string.sub(line,_last,_end-1))
											_pid = pid_table[_scid]
										else
											_scid = -1
											_pid = -1
										end
										if _scid ~= -1 then
											_last = _end+1
											_prev_name = "Unknown"
											if string.sub(line,_last,string.len(line)) ~= nil then
												_prev_name = string.sub(line,_last,string.len(line))
											end
											print("Previously kicked player "..string.sub(line,_last,_end-1).." ".._scid.." Previous name ".._prev_name.." Current name "..funcs.get.pid_name(_pid).." PID ".._pid)
											funcs.doo.kick_plyr(_pid,true,"Previously kicked",_prev_name)
											YIELD(250)
											break
										end
									end
								end
							end
						end
						io.close(file)
					end
				end
			end
		end
		YIELD(0)
	end
end)
new_set_str_data(g.feat.auto_re_kick,{"This session", "Until Lua reset","All kick history"})
funcs.add_to_S_L(g.feat.auto_re_kick,"g.feat.auto_re_kick")
g.feat.auto_re_kick.value=1



	g.o.tbl.crashes = {}
	g.o.tbl.spectate = {}
	g.o.tbl.kicks = {}
	g.o.tbl.added_kicks = {}
	g.o.tbl.original_kicks = {}
	g.tbl.kicks_str = {}
	g.tbl.kicks_str_true = {}
	for i=0,31 do
		g.o.tbl.crashes[i]={}
		g.o.tbl.kicks[i] = {}
		g.o.tbl.spectate[i]=menu.get_feature_by_hierarchy_key("online.online_players.player_"..i..".spectate_player")
	end

function funcs.doo.record_hierachy(crashes)
	for pid = 0,31 do
		for k, v in pairs(menu.get_feature_by_hierarchy_key("online.online_players.player_"..pid).children) do
			if not v.hidden then
				if crashes and v.type == 33280 then --action
					if string.find(string.lower(tostring(v)), "crash") then
						g.o.tbl.crashes[pid][#g.o.tbl.crashes[pid]+1]=v
					end
				end
				if string.find(string.lower(tostring(v)), "kick") then
					if v.type == 33280 then --action
						local original_feat=v																			--record current feat
						g.o.tbl.original_kicks[#g.o.tbl.original_kicks+1]=original_feat
						original_feat.hidden=true 																		--hide it
						local new_feat=menu.add_integrated_feature_after(v.name, "action", original_feat, function(f)	--create new feat
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								funcs.doo.kick_plyr(pid,nil,nil,nil,true)
							end)
							YIELD(0)																				--record kick
							original_feat:toggle()																	--use original feat
						end)
						g.o.tbl.added_kicks[#g.o.tbl.added_kicks+1] = new_feat
						local temp= v.name:gsub(" Kick","")
						temp=temp ~= "" and temp or v.name
						g.o.tbl.kicks[pid][temp]=function()
							new_feat:toggle()
						end
						if not g.tbl.kicks_str_true[temp] then
							g.tbl.kicks_str_true[temp]=true
							g.tbl.kicks_str[#g.tbl.kicks_str+1]=temp
						end
					elseif v.type == 33298 then --action_value_str
						local original_feat=v
						g.o.tbl.original_kicks[#g.o.tbl.original_kicks+1]=original_feat
						original_feat.hidden=true
						local new_feat=menu.add_integrated_feature_after(v.name, "action_value_str", original_feat, function(f)
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								funcs.doo.kick_plyr(pid,nil,nil,nil,true)
							end)
							YIELD(0)
							original_feat.value=f.value
							original_feat:toggle()
						end)
						new_feat:set_str_data(v.str_data)
						local temp= v.name:gsub(" Kick","")
						temp=temp ~= "" and temp or v.name
						g.o.tbl.added_kicks[#g.o.tbl.added_kicks+1] = new_feat
						for t=1,4 do
							if v.str_data[t] then
								local temp2 = temp.."|"..v.str_data[t]
								g.o.tbl.kicks[pid][temp2]=function()
									new_feat.value=t-1
									new_feat:toggle()
								end
								if not g.tbl.kicks_str_true[temp2] then
									g.tbl.kicks_str_true[temp2]=true
									g.tbl.kicks_str[#g.tbl.kicks_str+1]=temp2
								end
							end
						end
					end
				end
			end
		end
		--g.load_break()
	end
end

funcs.doo.record_hierachy(true)
if #g.tbl.kicks_str==0 then
	for pid = 0,31 do
		for k, v in pairs(menu.get_feature_by_hierarchy_key("online.online_players.player_"..pid).children) do
			v.hidden=false
		end
		--YIELD(0)
	end
	funcs.doo.record_hierachy(false)
end




g.feat.kick_type2=menu_add_feature("Select type of kick", "action_value_str", g.prnt.optns.id,nil,"Affects all kicks used in this script")--.hint
new_set_str_data(g.feat.kick_type2,g.tbl.kicks_str)
funcs.add_to_S_L(g.feat.kick_type2,"g.feat.kick_type2")

for  i=1,#g.tbl.kicks_str do
	if string.find(g.tbl.kicks_str[i],"360") then
		g.feat.kick_type2.value=i-1
		break
	end
end

g.feat.kick_if_host=menu_add_feature("Use host-kick if host", "toggle", g.prnt.optns.id,nil,"Affects all kicks used in this script")--.hint
funcs.add_to_S_L(g.feat.kick_if_host,"g.feat.kick_if_host")

g.print_load_info("Kicks/Crashes",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Gee-Watch"

function funcs.doo.wp_obj_tp_type(_pos)
	local Z = _pos.z
	funcs.get.ground_z(_pos,false)
	if Z > _pos.z+2 then
		_pos.z=Z
	else
		local temp=funcs.get.pos_nearby2(_pos,10,false,true)
		if funcs.get.dist_pospos_v2(_pos,temp) < 69 then
			_pos=temp
		end
	end
end

g.feat.tp_type=menu_add_feature("Vehicle WP/OBJ TP location", "action_value_str", g.prnt.optns.id,nil,"If teleporting a vehicle it will go to the nearest spawn point or exact location") --.hint
new_set_str_data(g.feat.tp_type,{"Spawn point","Exact location"})
funcs.add_to_S_L(g.feat.tp_type,"g.feat.tp_type")




g.feat.plyr_join = event.add_event_listener("player_join", function(f)
	g.var.check_re_kick=true
	g.var.check_fake_friends=true
	if f.player == API.plyr.my_id() then
		g.var.claim_ins=true
	end
end)

function funcs.get.scid_pid_tables()
	local scid_table = {}
	local pid_table = {}
	for i=0,31 do
		if funcs.is.valid_pid(i) and i ~= API.plyr.my_id() and not API.plyr.is.friend(i) then
			scid_table[API.plyr.get.scid(i)] = true
			pid_table[API.plyr.get.scid(i)] = i
		end
	end
	return scid_table,pid_table
end

g.tbl.fake_friend_timeout_list = {
["4"] = true, -- 	timeout
["14"] = true, -- 	timeout	friend
["1c"] = true, -- 	timeout	friend	hide
["1d"] = true, -- 	timeout	friend	hide	stalk
["d"] = true,  -- 	timeout			hide	stalk
["15"] = true,  -- 	timeout	friend			stalk
["c"] = true,  --	timeout			hide
["5"] = true, --    timeout					stalk
}

g.feat.set_wnt_self=menu_add_feature("Set wanted level", "value_i", g.prnt.self.id, function(f)
	while f.on do
		YIELD(50)
		funcs.doo.wntd_all_psngrs(API.plyr.my_id(),f.value)
	end
end)
funcs.set_feat_i_f(g.feat.set_wnt_self,0,5,1,0,"g.feat.set_wnt_self")

g.feat.show_alt=menu_add_feature("Enable", "value_str", g.prnt.altitude.id, function(f)
	while not g.var.GS_has_loaded do
		YIELD(0)
	end
	local pos = v2()
	local my_veh,my_ped,me,height,ground,my_pos,my_z,elevation,show_alt_ele,str
	local X,Y,S,R,G,B,A,T,list = g.feat.show_alt_x,g.feat.show_alt_y,g.feat.show_alt_s,g.feat.show_alt_cr,g.feat.show_alt_cg,g.feat.show_alt_cb,g.feat.show_alt_a,g.feat.show_alt_t,g.tbl.dist_type_str
	while f.on do
		pos.x=X.value
		pos.y=Y.value
		me = API.plyr.my_id()
		my_veh = API.plyr.is.in_veh(me) and API.plyr.get.veh(me) or nil
		my_ped = not my_veh and API.plyr.get.ped(me) or nil
		show_alt_ele = g.feat.show_alt_ele.value
		height = my_veh and veh_stuff.info[API.ent.get.model_hash(my_veh)].Z_HEIGHT-0.05 or 0.98
		elevation = my_veh and API.ent.get.coords(my_veh).z or API.plyr.get.coords(API.plyr.my_id()).z
		if T.value == 1 then
			height = ntv.get.ent_height(my_veh or my_ped)-height
		else
			my_pos = API.ent.get.coords(my_veh or my_ped)
			my_z = my_pos.z
			--my_pos.z=900
			ground = ntv.get.ground_z(my_pos,1,0) or 0
			height = my_z - ground - height
		end
		if show_alt_ele == 0 then
			str = "Altitude: "..funcs.get.dist_to_str(height,list[f.value]).." | Elevation: "..funcs.get.dist_to_str(elevation,list[f.value])
		elseif show_alt_ele == 1 then
			str = "Elevation: "..funcs.get.dist_to_str(elevation,list[f.value]).." | Altitude: "..funcs.get.dist_to_str(height,list[f.value])
		elseif show_alt_ele == 2 then
			str = "Altitude: "..funcs.get.dist_to_str(height,list[f.value])
		else
			str = "Elevation: "..funcs.get.dist_to_str(elevation,list[f.value])
		end
		API.SD.draw_text(
		str,
		funcs.vec(pos.x+(0.01*(g.RES_H+(1-g.RES_H))),pos.y*2),
		funcs.vec(pos.x+(0.01*(g.RES_H+(1-g.RES_H))),pos.y*2),S.value*g.RES_H,
		funcs.get.rgba_to_int(R.value,G.value,B.value,A.value),
		(1 << 1)+(1<<2),nil)
		YIELD(0)
	end
end)
new_set_str_data(g.feat.show_alt,{"Meters","Kilometers","Feet","Yards","Football fields","Miles","Tiny dick","BBC"})
funcs.add_to_S_L(g.feat.show_alt,"g.feat.show_alt")
g.feat.show_alt.on=true

g.feat.show_alt_ele=menu_add_feature("Display", "action_value_str", g.prnt.altitude.id)
new_set_str_data(g.feat.show_alt_ele,{"Altitude/Elevation","Elevation/Altitude","Altitude","Elevation"})
funcs.add_to_S_L(g.feat.show_alt_ele,"g.feat.show_alt_ele")
g.feat.show_alt_ele.value=2

g.feat.show_alt_x = menu_add_feature("X Pos", "action_value_f", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_x,-1,1,0.002,-0.9,"g.feat.show_alt_x")

g.feat.show_alt_y = menu_add_feature("Y Pos", "action_value_f", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_y,-1,1,0.002,-0.985,"g.feat.show_alt_y")

g.feat.show_alt_s = menu_add_feature("Size", "action_value_f", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_s,0.25,5,0.05,1,"g.feat.show_alt_s")

g.feat.show_alt_cr = menu_add_feature("Red", "action_value_i", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_cr,0,255,1,0,"g.feat.show_alt_cr")

g.feat.show_alt_cg = menu_add_feature("Green", "action_value_i", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_cg,0,255,1,255,"g.feat.show_alt_cg")

g.feat.show_alt_cb = menu_add_feature("Blue", "action_value_i", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_cb,0,255,1,0,"g.feat.show_alt_cb")

g.feat.show_alt_a = menu_add_feature("Alpha", "action_value_i", g.prnt.altitude.id)
funcs.set_feat_i_f(g.feat.show_alt_a,30,255,1,200,"g.feat.show_alt_a")

g.feat.show_alt_t=menu_add_feature("Altitude ground level", "action_value_str", g.prnt.altitude.id)
new_set_str_data(g.feat.show_alt_t,{"Highest point","Lowest point"})
funcs.add_to_S_L(g.feat.show_alt_t,"g.feat.show_alt_t")

g.feat.fake_passive=menu_add_feature("Fake passive", "toggle", g.prnt.self.id, function(f)
	local my_veh,my_ped
	while f.on do
		my_ped = funcs.ME._ped()
		API.ent.set.alpha(my_ped, 153, false)
		if funcs.ME._in_veh() then
			my_veh = funcs.ME._veh()
			API.ent.set.alpha(my_veh, 153, false)
			for k,v in pairs(API.veh.get.all()) do
				if funcs.is.plyr_driving(v) and v ~= my_veh then
					API.ent.set.collision_ent(v,my_veh, true)
					API.ent.set.collision_ent(my_veh,v, true)
				end
			end
			for k,v in pairs(API.Ped.get.all()) do
				if API.Ped.is.plyr(v)  and v ~= my_ped then
					API.ent.set.collision_ent(v,my_veh, true)
					API.ent.set.collision_ent(my_veh,v, true)
				end
			end
		elseif funcs.is.veh(my_veh) then
			API.ent.set.collision(my_veh,true,true)
			API.ent.set.alpha(my_veh, 255, true)
			my_veh = -1
		else
			my_veh = -1
			for k,v in pairs(API.veh.get.all()) do
				if funcs.is.plyr_driving(v)  and v ~= my_veh then
					API.ent.set.collision_ent(v,my_ped, true)
					API.ent.set.collision_ent(my_ped,v, true)
				end
			end
			for k,v in pairs(API.Ped.get.all()) do
				if API.Ped.is.plyr(v) and v ~= my_ped then
					API.ent.set.collision_ent(v,my_ped, true)
					API.ent.set.collision_ent(my_ped,v, true)
				end
			end
		end
		YIELD(0)
	end
	API.ent.set.collision(my_ped,true,true)
	API.ent.set.alpha(my_ped, 255, false)
	if funcs.ME._in_veh() then
		API.ent.set.collision(API.plyr.get.veh(API.plyr.my_id()),true,true)
		API.ent.set.alpha(API.plyr.get.veh(API.plyr.my_id()), 255, true)
	elseif funcs.is.veh(my_veh) then
		API.ent.set.collision(my_veh,true,true)
		API.ent.set.alpha(my_veh, 255, true)
		my_veh = -1
	end
end)
funcs.add_to_S_L(g.feat.fake_passive,"g.feat.fake_passive")

g.feat.veh_collision=menu_add_feature("No vehicle collision", "toggle", g.prnt.self.id, function(f)
	local my_ent,my_veh,my_ped
	while f.on do
		my_veh = funcs.ME._in_veh() and funcs.ME._veh() or nil
		my_ped = funcs.ME._ped()
		my_ent = my_veh or my_ped
		for k,v in pairs(API.veh.get.all()) do
			if v~=my_veh then
				API.ent.set.collision_ent(v,my_ent, true)
				API.ent.set.collision_ent(my_ent,v, true)
			end
		end
		YIELD(0)
	end
end)
funcs.add_to_S_L(g.feat.veh_collision,"g.feat.veh_collision")

g.feat.obj_collision=menu_add_feature("No object collision", "toggle", g.prnt.self.id, function(f)
	local my_ent
	while f.on do
		my_ent = funcs.ME._in_veh() and funcs.ME._veh() or funcs.ME._ped()
		for k,v in pairs(object.get_all_objects()) do
			API.ent.set.collision_ent(v,my_ent, true)
			API.ent.set.collision_ent(my_ent,v, true)
		end
		YIELD(0)
	end
end)
funcs.add_to_S_L(g.feat.obj_collision,"g.feat.obj_collision")

g.feat.cam_pitch=menu_add_feature("Unlock cam pitch", "toggle", g.prnt.self.id, function(f)
    while f.on do
		YIELD(0)
		native.call(0xA516C198B7DCA1E1,-90.0,90.0)
	end
end)
funcs.add_to_S_L(g.feat.cam_pitch,"g.feat.cam_pitch")

g.feat.cam_yaw=menu_add_feature("Unlock cam yaw", "toggle", g.prnt.self.id, function(f)
    while f.on do
		YIELD(0)
		native.call(0x8F993D26E0CA5E8E,-180.0,180.0)
	end
end)
funcs.add_to_S_L(g.feat.cam_yaw,"g.feat.cam_yaw")

function funcs.doo.remove_ent_in_thread(_ent,_time)
	if funcs.is.ent(_ent) then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			funcs.doo.remove_ent(_ent,_time)
		end)
	end
end



-----------------------------------------------------------------------------------------------------------------------------

g.feat.ped_never_on_fire=menu_add_feature("Never on fire","toggle",g.prnt.self_ped.id,function(f)
	while f.on do
		YIELD(0)
		funcs.doo.ent_repair_fire(API.plyr.get.ped(API.plyr.my_id()))
	end
end)
funcs.add_to_S_L(g.feat.ped_never_on_fire,"g.feat.ped_never_on_fire")

g.feat.lock_cam_foot=menu_add_feature("Lock body/cam on foot", "value_str", g.prnt.self_ped.id, function(f)
	local time,my_ped,my_rot,rot=TIME_MS()
    while f.on do
		YIELD(0)
		if not funcs.ME._in_veh() then
			my_ped = API.plyr.get.ped(API.plyr.my_id())
			if not API.Ped.is.swimming(my_ped) and not API.Ped.is.ragdoll(my_ped) and not API.ent.is.in_air(my_ped) then
				if funcs.is.key_active(32,1) then
					time=TIME_MS()+3000
				end
				my_rot = API.ent.get.rotation(my_ped)
				rot = API.cam.get.rot()
				my_rot.z = rot.z
				if f.value == 0 and funcs.is.key_active(32,1) and funcs.is.key_active(21,0) then --While Walking
					if funcs.is.key_active(34,1) and funcs.is.key_active(35,0) then
						my_rot.z=my_rot.z+50
					elseif funcs.is.key_active(35,1) and funcs.is.key_active(34,0) then
						my_rot.z=my_rot.z-50
					end
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 1 and funcs.is.key_active(32,1) and funcs.is.key_active(21,1) then --While Running
					if funcs.is.key_active(34,1) and funcs.is.key_active(35,0) then
						my_rot.z=my_rot.z+50
					elseif funcs.is.key_active(35,1) and funcs.is.key_active(34,0) then
						my_rot.z=my_rot.z-50
					end
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 2 and funcs.is.key_active(32,1) then --Walking & Running
					if funcs.is.key_active(34,1) and funcs.is.key_active(35,0) then
						my_rot.z=my_rot.z+50
					elseif funcs.is.key_active(35,1) and funcs.is.key_active(34,0) then
						my_rot.z=my_rot.z-50
					end
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 3 and funcs.is.key_active(33,0) then --While on foot
					if time > TIME_MS() then
						if funcs.is.key_active(34,1) and funcs.is.key_active(35,0) then
							my_rot.z=my_rot.z+50
						elseif funcs.is.key_active(35,1) and funcs.is.key_active(34,0) then
							my_rot.z=my_rot.z-50
						end
						API.ent.set.rotation(my_ped,my_rot)
					end
				elseif f.value == 4 and funcs.is.key_active(32,0) and funcs.is.key_active(21,0) and funcs.is.key_active(33,0) and funcs.is.key_active(34,0) and funcs.is.key_active(35,0) then --Not running/walking
					if time > TIME_MS() then
						API.ent.set.rotation(my_ped,my_rot)
					end
				end
			end
		end
	end
end)
new_set_str_data(g.feat.lock_cam_foot,{"While Walking", "While Running","Walking & Running","While on foot","Not running/walking"})
funcs.add_to_S_L(g.feat.lock_cam_foot,"g.feat.lock_cam_foot")

g.feat.lock_cam_water=menu_add_feature("Lock body/cam in water", "value_str", g.prnt.self_ped.id, function(f)
    local my_ped,my_rot,rot
	while f.on do
		YIELD(0)
		if not funcs.ME._in_veh() then
			my_ped = API.plyr.get.ped(API.plyr.my_id())
			if API.Ped.is.swimming(my_ped) and not API.Ped.is.ragdoll(my_ped) then
				my_rot = API.ent.get.rotation(my_ped)
				rot = API.cam.get.rot()
				my_rot.z = rot.z
				if f.value == 0 and API.Ped.is.swimming_underwater(my_ped) then
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 1 and not API.Ped.is.swimming_underwater(my_ped) then
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 2 then
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 3 and funcs.is.key_active(21,1) then
					API.ent.set.rotation(my_ped,my_rot)
				elseif f.value == 4 then
					if not API.Ped.is.swimming_underwater(my_ped) then
						if funcs.is.key_active(21,0) and funcs.is.key_active(32,0) then
							API.ent.set.rotation(my_ped,my_rot)
						end
					elseif funcs.is.key_active(21,0) then
						API.ent.set.rotation(my_ped,my_rot)
					end
				end
			end
		end
	end
end)
new_set_str_data(g.feat.lock_cam_water,{"While underwater", "While above water","While in water", "While swimming","Not swimming"})
funcs.add_to_S_L(g.feat.lock_cam_water,"g.feat.lock_cam_water")

g.feat.lock_cam_air=menu_add_feature("Lock body/cam in air (not parachute)", "toggle", g.prnt.self_ped.id, function(f)
    local my_ped,my_rot,rot
    while f.on do
		YIELD(0)
		if not funcs.ME._in_veh() then
			my_ped = API.plyr.get.ped(API.plyr.my_id())
			if not API.Ped.is.swimming(my_ped) and not API.Ped.is.ragdoll(my_ped) and API.ent.is.in_air(my_ped) then
				my_rot = API.ent.get.rotation(my_ped)
				rot = API.cam.get.rot()
				my_rot.z = rot.z
				API.ent.set.rotation(my_ped,my_rot)
			end
		end
	end
end)
funcs.add_to_S_L(g.feat.lock_cam_air,"g.feat.lock_cam_air")

g.feat.auto_parachute=menu_add_feature("Auto-get parachute", "toggle", g.prnt.self_ped.id, function(f)
    while f.on do
		if not API.wpn.ped_has(API.plyr.get.ped(API.plyr.my_id()), API.get_hash_key("gadget_parachute")) then
			API.wpn.ped_give(API.plyr.get.ped(API.plyr.my_id()), API.get_hash_key("gadget_parachute"), 100, true)
		end
		YIELD(500)
	end
end)
funcs.add_to_S_L(g.feat.auto_parachute,"g.feat.auto_parachute")

g.feat.slow_fall=menu_add_feature("Limit speed while free-falling", "value_i", g.prnt.self_ped.id, function(f)
	local my_ped,velocity,fall_speed,val
    while f.on do
		YIELD(0)
		if not funcs.ME._in_veh() then
			my_ped = API.plyr.get.ped(API.plyr.my_id())
			if API.ent.is.in_air(my_ped) and funcs.is.key_active(32,0) then
				velocity = API.ent.get.velocity(my_ped)
				fall_speed = velocity.z
				fall_speed = fall_speed * 2.236936
				val = f.value*-1
				if val > fall_speed then
					velocity.z=val
					API.ent.set.velocity(my_ped,velocity)
				end
			end
		end
	end
end)
funcs.set_feat_i_f(g.feat.slow_fall,0,70,5,40,"g.feat.slow_fall")


----------------------------------------------------------------------------------------Gee-Watch
----------------------------------------------------------------------------AKA-Universe Watchdog
-------------------------------------several improvements and corrections - so much fuckin better

function funcs.doo.gw_plyr_info(_pid)
	if funcs.is.valid_pid(_pid) then
		local plyr_name=""
		if API.plyr.is.host(_pid) or (script.get_host_of_this_script()==_pid) or API.plyr.is.modder(_pid,-1) or API.plyr.is.friend(_pid) then
			if API.plyr.is.host(_pid) then plyr_name=plyr_name.."[H]" end
			if script.get_host_of_this_script()==_pid then plyr_name=plyr_name.."[S]" end
			if API.plyr.is.modder(_pid,-1) then	plyr_name=plyr_name.."[M]" end
			if API.plyr.is.friend(_pid) then plyr_name=plyr_name.."[F]"	end
			plyr_name = plyr_name.." "
		end
		plyr_name = plyr_name..funcs.get.pid_name(_pid).."\nPID:".._pid.."   Host Priority:"..g.tbl.PID_INFO.host_priority_str[_pid+1]
		if API.plyr.is.in_veh(_pid) then
			plyr_name = plyr_name.."\n"..funcs.get.veh_model_name(API.plyr.get.veh(_pid)).."   ".."Seats:"..funcs.get.num_empty_seats(API.plyr.get.veh(_pid)).."/"..funcs.get.veh_seats(API.plyr.get.veh(_pid))
			if API.plyr.is.god(_pid) and API.plyr.is.veh_god(_pid) then	plyr_name = plyr_name.."\nPlayer-GOD & Vehicle-GOD"
			elseif API.plyr.is.veh_god(_pid) then plyr_name = plyr_name.."\nVehicle-GOD"
			end
		elseif API.plyr.is.god(_pid) then plyr_name=plyr_name.."\nPlayer-GOD"
		end
		plyr_name=plyr_name.."\nRank:"..glbls.get_pid_rank(_pid).."   K/D: "..funcs.get._2_dec(glbls.get_pid_kd(_pid)) --i just split these up so they fit on the screen
		plyr_name=plyr_name.."\nMoney: $"..funcs.get.add_commas(glbls.get_pid_total_money(_pid))
		plyr_name=plyr_name.."\nHealth: "..mth.flr(API.plyr.get.health(_pid)).."/"..mth.flr(API.plyr.get.max_health(_pid)).."   Armor:"..mth.flr(API.plyr.get.armor(_pid)).."/50"
		plyr_name=plyr_name.."\nWanted: "..API.plyr.get.wanted(_pid).."/5"
		g.N_P(2,plyr_name,__GV__,14,"Blue")
		return true
	end
	return false
end

function funcs.get.translation_extras(tbl,str)
	local FEAT_EXTRAS = tbl and tbl.FEAT_EXTRAS
	return FEAT_EXTRAS and FEAT_EXTRAS[str] or str
end

function funcs.doo.GW_overlay_text(aim_ent,is_ped,is_player,in_veh,is_veh,veh,pid,has_ped,ent_pos)
	if g._Watch_display.on or g._Watch_display_on_ent.on then
		local lang_tbl = lang[selected_lang][g.var.gee_watch_dynamic_translation_str]
		local get_translation = funcs.get.translation_extras
		local vk_list = inputs.vk_list
		local char_check = funcs.is.char_check
		local text = {}
		text[#text+1]=char_check(vk_list[g.feat.gw_expld_key.value+1]).." | "..get_translation(lang_tbl,"Explode")
		if in_veh or is_veh then
			text[#text+1] = char_check(vk_list[g.feat.gw_damdes_key.value+1]).. " | "..get_translation(lang_tbl,g._gee_watch_destroy.on and "Destroy" or "Damage")
			text[#text+1] = char_check(vk_list[g.feat.gw_clone_key.value+1]).. " | "..get_translation(lang_tbl,"Clone")
		end
		if pid then
			text[#text+1]=char_check(vk_list[g.feat.gw_kick_key.value+1]).." | "..get_translation(lang_tbl,"Kick Player")
			text[#text+1]=char_check(vk_list[g.feat.gw_plyr_tab_key.value+1]).." | "..get_translation(lang_tbl,"Open Player Tab")
		end
		text[#text+1]=char_check(vk_list[g.feat.gw_burn_key.value+1]).." | "..get_translation(lang_tbl,"Burn")
		text[#text+1]=char_check(vk_list[g.feat.gw_black_hole_key.value+1]).." | "..get_translation(lang_tbl,"Black Hole")
		if in_veh or is_veh then
			text[#text+1]=char_check(vk_list[g.feat.gw_board_key.value+1]).." | "..get_translation(lang_tbl,"Boarding")
			text[#text+1]=char_check(vk_list[g.feat.gw_accel_key.value+1]).." | "..get_translation(lang_tbl,"Accel")
			text[#text+1]=char_check(vk_list[g.feat.gw_rvrs_key.value+1]).." | "..get_translation(lang_tbl,"Reverse")
			text[#text+1]=char_check(vk_list[g.feat.gw_rpr_key.value+1]).." | "..get_translation(lang_tbl,"Repair")
			text[#text+1]=char_check(vk_list[g.feat.gw_upgr_key.value+1]).." | "..get_translation(lang_tbl,"Upgrade")
			text[#text+1]=char_check(vk_list[g.feat.gw_ele_key.value+1]).." | "..get_translation(lang_tbl,"Up")

		end
		if in_veh or is_veh or (is_ped and not is_player) then
			text[#text+1]=char_check(vk_list[g.feat.gw_invis_key.value+1]).." | "..get_translation(lang_tbl,"Visibility")
			text[#text+1]=char_check(vk_list[g.feat.gw_god_key.value+1]).." | "..get_translation(lang_tbl,"God")
			text[#text+1]=char_check(vk_list[g.feat.gw_delete_key.value+1]).. " | "..get_translation(lang_tbl,"Delete")
		end
		text[#text+1]=char_check(vk_list[g.feat.gw_ntr_key.value+1]).." | "..get_translation(lang_tbl,"Neuter")
		if in_veh or is_veh then
			text[#text+1]=char_check(vk_list[g.feat.gw_d_ele_key.value+1]).." | "..get_translation(lang_tbl,"Down")
		elseif is_ped and not is_player then
			text[#text+1]=char_check(vk_list[g.feat.gw_d_ele_key.value+1]).." | "..get_translation(lang_tbl,"Ragdoll")
		end
		text[#text+1]=char_check(vk_list[g.feat.gw_mark_key.value+1]).." | "..get_translation(lang_tbl,"Mark")
		if ent_pos and g._Watch_display_on_ent.on then
			local ped_type
			local veh_type
			if pid then
				ped_type =  ""
				if API.plyr.is.god(pid) then
					ped_type = ped_type.."#FF0000FF#[G]#DEFAULT# "
				end
				ped_type = ped_type..funcs.get.pid_name(pid)
			elseif is_ped or has_ped then
				local this_ped = is_ped and aim_ent or has_ped
				ped_type =  ""
				if funcs.is.ent(this_ped) and API.ent.get.god(this_ped) then
					ped_type = ped_type.."#FF0000FF#[G]#DEFAULT# "
				end
				if g._Watch_display_NPC_name.on then
					ped_type = ped_type..(ped_models.hash_is_name[API.ent.get.model_hash(this_ped)] or "Ped")
				else
					ped_type = ped_type.."Ped"
				end
			end
			local x_pos = ent_pos.x
			local y_pos = ent_pos.y
			local size = 1
			local y_val = 0.04*size
			local top_len = 0
			if ped_type then
				top_len=top_len+1
			end
			if veh then
				veh_type = ""
				if funcs.is.ent(veh) and API.ent.get.god(veh) then
					veh_type = veh_type.."#FF0000FF#[VG]#DEFAULT# "
				end
				veh_type = veh_type..funcs.get.veh_model_name(veh)
				top_len=top_len+1
			end
			local box_color = funcs.get.rgba_to_int(0,0,0,g._W_B_ca_on_b.value)
			if g._Watch_display_list.on then
				local list_len = #text+top_len
				API.SD.draw_rect(funcs.vec(x_pos+(size*0.169*0.3801),y_pos-y_val*list_len*.5),	funcs.vec(size*0.69*0.2,0.040*size*list_len),	box_color)
			end
			API.SD.draw_rect(funcs.vec(x_pos+(size*0.169*0.3801),y_pos-y_val*top_len*.5),	funcs.vec(size*0.69*0.2,0.040*size*top_len),		box_color) --top
			local text_pos = v2(x_pos,(y_pos-(y_val*.5))*2)
			local text_size = size*1.069*funcs.get.SD_size(true)*g.RES


			if ped_type then
				API.SD.draw_text(ped_type,text_pos,text_pos,text_size,funcs.get.rgba_to_int(255,255,255,255),((1<<1)+(1<<2)),nil)
			end
			if veh_type then
				if ped_type  then
					text_pos=text_pos-funcs.vec(0,y_val*2)
				end
				API.SD.draw_text(veh_type,text_pos,text_pos,text_size,funcs.get.rgba_to_int(255,255,255,255),((1<<1)+(1<<2)),nil)
			end
			if g._Watch_display_list.on then
				local text_color = funcs.get.rgba_to_int(g._W_B_cr_on.value,g._W_B_cg_on.value,g._W_B_cb_on.value,g._W_B_ca_on_t.value)
				for i = 1,#text do
					text_pos=text_pos-funcs.vec(0,y_val*2)
					API.SD.draw_text(text[i]:gsub("\\~","~"),text_pos,text_pos,text_size,text_color,((1<<1)+(1<<2)),nil)
				end
			end
		end
		if g._Watch_display.on then
			text=table_concat(text,"  ")
			funcs.doo.overlay(text,g._W_B_cr.value,g._W_B_cg.value,g._W_B_cb.value,g._W_B_a.value,g._W_B_s.value/300,g._W_B_f.value,g._W_B_x.value/300,g._W_B_y.value/300)
		end
	end
end


g.tbl.GW_ent_history={}
function funcs.doo.GW_action_list(_key,_ent,_action)
	if g.tbl.GW_ent_history[_ent]==nil then
		g.tbl.GW_ent_history[_ent]={}
	end
	if not g.tbl.GW_ent_history[_ent][_action] then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local __key,__ent,__action = inputs.vk_list[_key.value+1],_ent,_action
			g.tbl.GW_ent_history[__ent][__action]=true

			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local time=TIME_MS()+30000
				local ___ent,___action = __ent,__action
				local stop=false
				while time>TIME_MS() and funcs.is.ent(___ent) and not stop do
					if not g.tbl.GW_ent_history[___ent][___action] then
						stop=true
					else
						if API.ent.is.veh(___ent) then
							funcs.doo.GW_highlight(___ent,true)
						elseif API.ent.is.ped(___ent) then
							if API.Ped.is.in_veh(___ent) then
								funcs.doo.GW_highlight(API.Ped.get.veh(___ent),true)
							else
								funcs.doo.GW_highlight(___ent,true)
							end
						end
					end
					YIELD(5)
				end
				if not stop then
					g.tbl.GW_ent_history[___ent][___action]=false
				end
			end)

			if __action == "board" then
				funcs.doo.GW_board(__key,__ent)
			elseif __action == "dam_des" then
				if g._gee_watch_destroy.on then
					funcs.doo.veh_destroy(__ent, 1000)
				else
					funcs.doo.veh_damage(__ent, 1000)
				end
			elseif __action == "veh_boost" then
				if funcs.ntwrk.ask_long(__ent,1000) then
					API.veh.set.forward_speed(__ent,g._ped_veh_accel.value)
				end
			elseif __action == "veh_rvrs" then
				if funcs.ntwrk.ask_long(__ent,1000) then
					API.veh.set.forward_speed(__ent,(g._ped_veh_revers.value*-1))
				end
			elseif __action == "repair" then
				funcs.doo.veh_repair_all(__ent, 1000,nil,false,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
			elseif __action == "veh_up" then
				if funcs.ntwrk.ask_long(__ent,1000) then
					API.ent.set.velocity(__ent,funcs.vec(0,0,g._ped_veh_up.value))
				end
			elseif __action == "veh_and_ped_upgr" then
				if API.ent.is.dead(__ent) then
					funcs.doo.veh_action_list(__ent,1000,"repair",nil)
				end
				funcs.doo.veh_action_list(__ent,1000,"upgrades",nil)
				local veh_peds = funcs.get.all_peds_in_veh(__ent,false,nil)
				for i=1, #veh_peds do
					fire.stop_entity_fire(veh_peds[i])
					funcs.doo.ped_combat_attrib(veh_peds[i],true,100,true)
					funcs.doo.set_ped_health(veh_peds[i],2500,100)
					funcs.doo.give_ped_weap(veh_peds[i],API.get_hash_key("weapon_machinepistol"))
					funcs.doo.give_ped_weap(veh_peds[i],API.get_hash_key("weapon_combatmg_mk2"))
				end
			elseif __action == "ped_veh_down" then
				if funcs.ntwrk.ask_long(__ent,1000) then
					API.ent.set.velocity(__ent,funcs.vec(0,0,-g._ped_veh_down.value))
				end
			elseif __action == "burn" or __action == "explode" then
				local boom = 0
				if __action == "burn" then
					boom = 3
				end
				local ents={}
				if funcs.is.veh(__ent) then
					ents = funcs.get.all_peds_in_veh(__ent,nil,false)
				elseif funcs.is.ped(__ent) and API.Ped.is.in_veh(__ent) then
					ents = funcs.get.all_peds_in_veh(API.Ped.get.veh(__ent),nil,false)
				end
				if not funcs.is.dead(__ent) then
					ents[#ents+1]=__ent
				end
				for i=1, #ents do
					local blame = g._gee_watch_explo_blame.value == 0 and ents[i] or funcs.ME._ped()
					if __action == "explode" and g._gee_watch_explo_type.value==1 then
						funcs.doo.orb_explo_ptfx_n_audio(funcs.get.ent_vel_pos(ents[i],0.1),blame)
					else
						fire.add_explosion(funcs.get.ent_vel_pos(ents[i],0.1), boom, true, false, 0, blame)
					end
					fire.start_entity_fire(ents[i])

				end
			elseif __action == "ped_veh_god" then
				local god = API.ent.get.god(__ent)
				funcs.doo.ent_god_tog(__ent,1000,(not god))
				local veh_peds = funcs.get.all_peds_in_veh(__ent,false,false)
				for i=1, #veh_peds do
					funcs.doo.ent_god_tog(veh_peds[i],100,(not god))
				end
				YIELD(150)
			elseif __action == "ped_veh_ntr" then
				funcs.doo.GW_neuter(__ent,1000)
				local veh_peds = funcs.get.all_peds_in_veh(__ent,false,false)
				for i=1, #veh_peds do
					funcs.doo.GW_neuter(veh_peds[i],250)
				end
				YIELD(150)
			--npc peds
			elseif __action == "delete" then
				funcs.doo.remove_ent(__ent,1000)
			elseif __action == "ped_forward" then
				funcs.doo.ped_force(__ent, 1000,"forward",g._ped_veh_accel.value)
			elseif __action == "ped_up" then
				funcs.doo.ped_force(__ent, 1000,"up",g._ped_veh_accel.value)
			elseif __action == "ped_ragdoll" then
				funcs.doo.ped_ragdoll(__ent,true,1000)
				for i=1,10 do
					if funcs.is.ent(__ent) then
						API.Ped.set.ragdoll(__ent,1000,1000,0)
					end
					YIELD(500)
				end
			elseif __action == "ped_upgrade" then
				funcs.doo.ped_combat_attrib(__ent,true,1000,true)
				funcs.doo.set_ped_health(__ent,2500,1000)
				ntv.set.ped_critical_dmg(__ent,0)
				funcs.doo.give_ped_weap(__ent,API.get_hash_key("weapon_machinepistol"))
				funcs.doo.give_ped_weap(__ent,API.get_hash_key("weapon_combatmg_mk2"))
			elseif __action == "ped_god" then
				funcs.doo.ent_god_tog(__ent,1000,nil)
				YIELD(150)
			elseif __action == "ent_ntr" then
				funcs.doo.GW_neuter(__ent,1000)
				YIELD(150)
			-- vehicles
			elseif __action == "veh_upgrade" then
				funcs.doo.veh_action_list(__ent,1000,"upgrades",nil)
			elseif __action == "god_tog" then
				 funcs.doo.ent_god_tog(__ent,1000,nil)
				 YIELD(150)
			elseif __action == "kick_pids_in_veh" then
				funcs.doo.kick_plyrs_in_veh(__ent)
				YIELD(500)
			elseif __action == "invisible" then
				if funcs.ntwrk.ask_long(__ent,1000) then
					API.ent.set.visible(__ent,(not API.ent.is.visible(__ent)))
					YIELD(150)
				end
			elseif __action == "black_hole" then
				local time=TIME_MS()
				local all_veh,all_peds,all_obj
				local ent_pos = API.ent.get.coords(__ent)
				local temp_pos,trgt_crds_do,vec_to_trgt,dist,speed,range,los_not_required,movement_type
				local my_veh,pers_veh
				local exclude = {}
				if g._gee_watch_black_hole_sphere.on then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local range,range2  = g._gee_watch_black_hole_range.value
						local duration = g._gee_watch_black_hole_duration.value*1000
						local time=TIME_MS()+duration
						local time2=TIME_MS()+duration
						local __ent = __ent
						while time>TIME_MS() and funcs.is.ent(__ent) do
							range2 = range*(time2-TIME_MS())/duration
							time2=time2*0.999999
							if g._gee_watch_black_hole_sphere.value ==  0 then
								if time2>TIME_MS() then
									graphics.draw_marker(28, API.ent.get.coords(__ent),
									funcs.vec(0,90,0),funcs.vec(0,90,0),funcs.vec(range2,range2,range2),
									mth.rndm(0,50), mth.rndm(0,50), mth.rndm(0,50), mth.flr(255*(time2-TIME_MS())/duration),
									false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
								end
							else
								graphics.draw_marker(28, API.ent.get.coords(__ent),
								funcs.vec(0,90,0),funcs.vec(0,90,0),funcs.vec(range,range,range),
								mth.rndm(0,50), mth.rndm(0,50), mth.rndm(0,50), mth.flr(255*0.69),
								false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
							end
							YIELD(0)
						end
					end)
				end

				while (time+(g._gee_watch_black_hole_duration.value*1000))>TIME_MS() and funcs.is.ent(__ent) do
					all_veh = API.veh.get.all()
					if g._gee_watch_black_hole_type.value == 0 then
						ent_pos = API.ent.get.coords(__ent)
					end
					exclude[funcs.ME._veh()]=true
					exclude[API.plyr.pers_veh()]=true
					exclude[__ent]=g._gee_watch_black_hole_type.value == 0
					movement_type = g._gee_watch_black_hole_movement.value
					speed = movement_type == 0 and g._gee_watch_black_hole_power.value or g._gee_watch_black_hole_power.value*0.2
					range  = g._gee_watch_black_hole_range.value
					los_not_required = g._gee_watch_black_hole_los.value == 0
					for k,v in pairs(all_veh) do
						if not exclude[v] then
							temp_pos = API.ent.get.coords(v)
							if (los_not_required or ntv.is.ents_in_los(__ent,v,17,false)) and funcs.is.in_grid_xy(ent_pos,temp_pos,range) then
								dist = temp_pos:magnitude(ent_pos)
								if dist <= range and funcs.ntwrk.ask_quick(v) then
									funcs.doo.id_migrate(v,0)
									trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(ent_pos,temp_pos,(range-dist)/range*0.25*speed)
									if movement_type == 0 then
										API.ent.set.velocity(v,trgt_crds_do)
									else
										entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
									end
								end
							end
						end
					end
					YIELD(0)
					if funcs.is.ent(__ent) then
						all_peds = API.Ped.get.all()
						for k,v in pairs(all_peds) do
							if not exclude[v] and not API.Ped.is.plyr(v) then
								temp_pos = API.ent.get.coords(v)
								if (los_not_required or ntv.is.ents_in_los(__ent,v,17,false)) and funcs.is.in_grid_xy(ent_pos,temp_pos,range) then
									dist = temp_pos:magnitude(ent_pos)
									if dist <= range and funcs.ntwrk.ask_quick(v) then
										funcs.doo.id_migrate(v,0)
										trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(ent_pos,temp_pos,(range-dist)/range*0.25*speed)
										if movement_type == 0 then
											API.ent.set.velocity(v,trgt_crds_do)
										else
											entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
										end
									end
								end
							end
						end
					end
					YIELD(0)
					if funcs.is.ent(__ent) then
						all_obj = object.get_all_objects()
						for k,v in pairs(all_obj) do
							temp_pos = API.ent.get.coords(v)
							if (los_not_required or ntv.is.ents_in_los(__ent,v,17,false)) and funcs.is.in_grid_xy(ent_pos,temp_pos,range) then
								dist = temp_pos:magnitude(ent_pos)
								if dist <= range and funcs.ntwrk.ask_quick(v) then
									funcs.doo.id_migrate(v,0)
									trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(ent_pos,temp_pos,(range-dist)/range*0.25*speed)
									if movement_type == 0 then
										API.ent.set.velocity(v,trgt_crds_do)
									else
										entity.apply_force_to_entity(v,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
									end
								end
							end
						end
					end
					YIELD(0)
				end
			end
			g.tbl.GW_ent_history[__ent][__action]=false
		end)
		YIELD(50)
	end
end

function funcs.is.GW_key_press(_feat)
	return funcs.is.vk_key_down(inputs.vk_list[_feat.value+1])
end

g.tbl.veh_flight_inputs={
[2] = -90, 		--A
[3] = -45, 		--WA
[6] = -135, 	--SA
[8] = 90, 		--D
[9] = 45, 		--WD
[12] = 135, 	--SD
[14] = -180, 	--SAD
}

function funcs.doo.veh_flight(veh,boost,mult,move)
	local W = funcs.is.key_active(32,1) and 1 or 0
	local A = funcs.is.key_active(34,1) and 2 or 0
	local S = funcs.is.key_active(33,1) and 4 or 0
	local D = funcs.is.key_active(35,1) and 8 or 0
	local SHFT = funcs.is.key_active(209,1)
	local CNTRL = funcs.is.key_active(210,1)
	local SPC = funcs.is.key_active(143,1)
	local ASD = A+S+D
	local WASD = W+ASD
	local camrot = API.cam.get.rot()
	local GO,Z
	move.x = 0
	move.y = 0
	move.z = 0
	API.ent.set.rotation(veh,camrot)
	if W>0 and ASD==0 and not CNTRL and not SPC then
		GO = SHFT and boost * mult or mult
		API.ent.set.max_speed(veh, 45000)
		API.veh.set.forward_speed(veh, GO)
		return true
	elseif WASD>0 or CNTRL or SPC then
		GO = SHFT and boost or 1
		Z = g.tbl.veh_flight_inputs[WASD] or 0
		Z = Z + (camrot.z*-1)
		if Z < -180 then
			Z=(mth.abs(Z)-360)*-1
		elseif Z > 180 then
			Z=mth.abs(Z)-360
		end

		if WASD>0 then
			move.y = (90-math.abs(Z))/90*mult*GO
			move.x = (Z < 0 and (90-mth.abs(Z+90))/-90*mult*GO) or (90-mth.abs(Z-90))/90*mult*GO
		end
		if SPC then
			move.z = mult*GO
		elseif CNTRL then
			move.z = -mult*GO
		elseif S>0 then
			move.z = (camrot.x*-1)/90*mult*GO
		elseif W>0 then
			move.z = camrot.x/90*mult*GO
		end

		API.ent.set.max_speed(veh, 45000)
		API.ent.set.velocity(veh,move)
		return true
	end
	API.ent.set.max_speed(veh, 0)
	return false
end

g.var.gw_cam = nil
function funcs.doo.GW_cam()
	ntv.cam.doo.destroy_all()
	g.var.gw_cam = ntv.cam.doo.create_w_params("DEFAULT_SCRIPTED_CAMERA", funcs.vec(0,0,0),funcs.vec(0,0,0), 90.0, 1, 2)
	funcs.doo.req_model(API.get_hash_key("bmx"))
	local ent = vehicle.create_vehicle(API.get_hash_key("bmx"),API.cam.get.pos()+funcs.vec(0,0,25), 0.0,false,false) --add to clear exclusions
	--API.ent.freeze(ent,true)
	API.ent.set.collision(ent,false,false)
	API.ent.set.visible(ent,false)
	ntv.cam.doo.attach_to_ent(g.var.gw_cam, ent,funcs.vec(0,0,-25),1)
	ntv.cam.set.active(g.var.gw_cam,1)
	ntv.cam.set.render_script(1, 0, 0, 0, 0)
	local move = v3()
	while g.feat.gw_main.on and ntv.cam.is.exist(g.var.gw_cam) and funcs.is.ent(ent) and not funcs.is.vk_key_down("ESCAPE") and not funcs.is.vk_key_down("F6") do
		ntv.cam.set.rot(g.var.gw_cam,API.cam.get.rot(),2)
		funcs.doo.veh_flight(ent,3,5,move)
		coords = API.ent.get.coords(ent)
		ntv.map.lock_mini_pos(coords)
		ntv.cam.set.focus_pos(coords)
		YIELD(0)
	end
	ntv.cam.set.render_script(0, 0, 0, 0, 0)
	ntv.cam.set.active(g.var.gw_cam,0)
	ntv.cam.doo.destroy_all()
	ntv.cam.set.no_focus_pos()
	ntv.map.unlock_mini_pos()
	while funcs.is.vk_key_down("F6") do
		YIELD(25)
	end
end



g.var.gw_aim_ent=nil
g.var.gw_aim_rot=0
g.feat.gw_main=menu_add_feature("Gee-Watch mode", "toggle", g.prnt.gee_watch.id, function(f)
	local plyr_name_count=0
	local aim_ent,aim_veh,force,veh_peds,good,target_pos
	local ray_hit,dist,ray_start,tp_extra
	local temp_veh
	g.var.gw_aim_pos=nil
	g.var.gw_aim_active=false
	g.var.gw_aim_tp_show=false
	g.var.gw_aim_clone_veh=nil
	g.tbl.GW_ent_mark={}
	if f.on then
		if funcs.is.GS_loaded() then
			g.N_P(2,"Gee-Watch Enabled\nRight click to use",__GV__,10,"Blue")
		end
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function() --Mark
			local pos,veh,size
			while g.feat.gw_main.on do
				for k,v in pairs(g.tbl.GW_ent_mark) do
					size=nil
					if funcs.is.num(v) then
						if v<=31 then
							if API.plyr.is.valid(v) then
								size=1.25
								pos = API.plyr.get.coords(v)
								if API.plyr.is.in_veh(v) then
									pos = API.ent.get.coords(API.plyr.get.veh(v))
									size=funcs.get.basic_veh_dimensions(true,API.plyr.get.veh(v),1.5,3)
								end
							end
						elseif funcs.is.ent(v) then
							size=1.25
							if API.ent.is.veh(v) then
								pos = API.ent.get.coords(v)
								size=funcs.get.basic_veh_dimensions(true,v,1.5,3)
							elseif API.ent.is.ped(v) and API.Ped.is.in_veh(v) then
								pos = API.ent.get.coords(API.Ped.get.veh(v))
								size=funcs.get.basic_veh_dimensions(true,API.Ped.get.veh(v),1.5,3)
							else
								pos = API.ent.get.coords(v)
							end
						end
					end
					if size then
						pos.z=pos.z+size
						graphics.draw_marker(2,pos, funcs.vec(0, 90, 0), v3(0, 180, g.var.gw_aim_rot),funcs.vec(size*0.5,size*0.5,size*0.5),255, math.random(0,50), math.random(0,50), 69, false, false, 2, false, nil, "MarkerTypeThickChevronUp", false)
					else
						k=nil
					end
				end
				YIELD(0)
			end
		end)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function() --clone
			local retain,aim=TIME_MS()
			local clone,TP_POS,bool,screen_pos,temp_veh,all_veh,all_peds,list,temp_pos,ent_pos,los_ent,my_ped,my_veh,temp_ent,assist_size,one_yield
			local function remove_clone()
				if funcs.is.ent(clone) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local ENT = clone
						funcs.doo.remove_ent(ENT,1000)
					end)
				end
			end
			while g.feat.gw_main.on do
				TP_POS=g.var.gw_aim_pos
				temp_veh=g.var.gw_aim_clone_veh
				if g.var.gw_aim_tp_show and TP_POS then
					if g.var.gw_aim_active then
						graphics.draw_marker(28, (TP_POS or g.var.gw_aim_pos), funcs.vec(0,90,0),funcs.vec(0,90,0),funcs.vec(1,1,1),255, math.random(0,50), math.random(0,50), 69, false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
						remove_clone()
					elseif funcs.is.veh(temp_veh) then
						if not funcs.is.veh(clone) then
							funcs.doo.record_clone_veh(g.tbl.veh_clone,temp_veh)
							clone = funcs.doo.create_clone_veh(g.tbl.veh_clone[temp_veh],g.var.gw_aim_pos,0,true,false,true)
							API.ent.freeze(clone,true)
							API.ent.set.god(clone,true)
						else
							if g._W_B_highlight_show.on then
								ntv.doo.spotlight(TP_POS+funcs.vec(0,0,10),funcs.get.normalize_v3(TP_POS,TP_POS+funcs.vec(0,0,2)), 0, 255, 0, 20.0, g.tbl.GW_light_bright[time.get_clock_hours()]*g._W_B_highlight_bright.value, 6.0, 6.25*funcs.get.basic_veh_dimensions(true,temp_veh,2), 20.0)
							end
							API.ent.set.coords(clone,TP_POS)
							API.ent.set.rotation(clone,funcs.vec(0,0,API.ent.get.heading(temp_veh)))
						end
					elseif funcs.ME._in_veh() then
						if temp_veh ~= nil then
							remove_clone()
							temp_veh=nil
						end
						if not funcs.is.veh(clone) then
							funcs.doo.record_clone_veh(g.tbl.veh_clone,funcs.ME._veh())
							clone = funcs.doo.create_clone_veh(g.tbl.veh_clone[funcs.ME._veh()],g.var.gw_aim_pos,0,true,false,true)
							API.ent.freeze(clone,true)
						else
							if g._W_B_highlight_show.on then
								ntv.doo.spotlight(TP_POS+funcs.vec(0,0,10),funcs.get.normalize_v3(TP_POS,TP_POS+funcs.vec(0,0,2)), 0, 255, 0, 20.0, g.tbl.GW_light_bright[time.get_clock_hours()]*g._W_B_highlight_bright.value, 6.0, 6.25*funcs.get.basic_veh_dimensions(true,funcs.ME._veh(),2), 20.0)
							end
							API.ent.set.coords(clone,TP_POS)
							API.ent.set.rotation(clone,funcs.vec(0,0,API.ent.get.heading(funcs.ME._veh())))
						end
					else
						remove_clone()
						temp_veh=nil
						graphics.draw_marker(28, TP_POS, funcs.vec(0,90,0),funcs.vec(0,90,0),funcs.vec(1,1,1),math.random(0,50), 255, math.random(0,50), 69, false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
					end
					screen_pos = funcs.get.screen_pos_3d(TP_POS)
					if screen_pos then
						API.SD.draw_text(math.floor(funcs.get.dist_pospos_v3(funcs.ME._veh_or_me_crds(),TP_POS)),
						screen_pos,screen_pos,API.gfx.get_h()/1300,funcs.get.rgba_to_int(255,255,255,255),((1<<1)+(1<<2)+(1<<0)),nil)
					end
				else
					remove_clone()
					if funcs.ME._aim() then
						if g._gee_watch_aim_assist.value == 0 then
							aim=API.plyr.get.aim_at(API.plyr.my_id())
							if not funcs.is.ped(aim) and not funcs.is.veh(aim) then
								aim = funcs.get.ray_vctr_all(nil,true)
							end
							if funcs.is.ped(aim) or funcs.is.veh(aim)  then
								if funcs.is.ped(aim) and API.Ped.is.in_veh(aim) then
									g.var.gw_aim_ent = API.Ped.get.veh(aim)
								else
									g.var.gw_aim_ent=aim
								end
								ent_pos = funcs.get.screen_pos_3d(API.ent.get.coords(g.var.gw_aim_ent))
								retain=TIME_MS()+g._gee_watch_trgt_swtch.value
							end
						else
							assist_size = g._gee_watch_aim_assist.value * 25 * 0.01
							ent_pos = nil
							temp_ent=API.plyr.get.aim_at(API.plyr.my_id())
							if not funcs.is.ped(temp_ent) and not funcs.is.veh(temp_ent) then
								temp_ent = funcs.get.ray_vctr_all(nil,true)
							end
							if funcs.is.ped(temp_ent) or funcs.is.veh(temp_ent) then
								if funcs.is.ped(temp_ent) and API.Ped.is.in_veh(temp_ent) then
									temp_ent = API.Ped.get.veh(temp_ent)
								end
								ent_pos = funcs.get.screen_pos_3d(API.ent.get.coords(temp_ent))
							end
							if ent_pos then
								retain=TIME_MS()+g._gee_watch_trgt_swtch.value
							else
								all_veh = API.veh.get.all()
								all_peds = API.Ped.get.all()
								list = {}
								my_ped = funcs.ME._ped()
								my_veh = funcs.ME._in_veh() and funcs.ME._veh() or nil
								if not funcs.is.ent(los_ent) then
									funcs.doo.req_model(-1707997257)
									los_ent = object.create_object(-1707997257,API.cam.get.pos_final(), false,false)
									API.ent.freeze(los_ent,true)
									API.ent.set.collision(los_ent,false,false)
									API.ent.set.alpha(los_ent, 0, false)
								else
									API.ent.set.coords(los_ent,API.cam.get.pos_final())
								end
								for k,v in pairs(all_veh) do
									temp_pos = funcs.get.screen_pos_3d(API.ent.get.coords(v))
									if temp_pos and mth.abs(temp_pos.x) <= assist_size and mth.abs(temp_pos.y) <= assist_size and  v ~= my_veh and ntv.is.ents_in_los(los_ent,v,17,false) then
										list[#list+1] = {ent = v, pos = temp_pos}
									end
								end
								for k,v in pairs(all_peds) do
									temp_pos = funcs.get.screen_pos_3d(API.ent.get.coords(v))
									if temp_pos and mth.abs(temp_pos.x) <= assist_size and mth.abs(temp_pos.y) <= assist_size and v ~= my_ped and ntv.is.ents_in_los(los_ent,v,17,false) then
										if not API.Ped.is.in_veh(v) or API.Ped.get.veh(v) ~= my_veh then
											list[#list+1] = {ent = v, pos = temp_pos}
										end
									end
								end
								if #list >0 then
									table.sort(list, function(a, b) return (mth.abs(a.pos.x)+mth.abs(a.pos.y)) <  (mth.abs(b.pos.x)+mth.abs(b.pos.y)) end)
									temp_ent=list[1].ent
									if funcs.is.ped(temp_ent) and API.Ped.is.in_veh(temp_ent) then
										ent_pos = funcs.get.screen_pos_3d(API.ent.get.coords(API.Ped.get.veh(temp_ent))) or list[1].pos
									else
										ent_pos = list[1].pos
									end
									retain=TIME_MS()+g._gee_watch_trgt_swtch.value
								end
							end
							if funcs.is.ent(temp_ent) and ent_pos and retain>TIME_MS() then
								if funcs.is.ped(temp_ent) and API.Ped.is.in_veh(temp_ent) then
									temp_ent=API.Ped.get.veh(temp_ent)
								end
								g.var.gw_aim_ent=temp_ent
								one_yield=true
								while funcs.is.ent(temp_ent) and ent_pos and retain>TIME_MS() do
									if g._W_B_line_show.on then
										API.SD.draw_line(funcs.vec(0,0),ent_pos, 1, funcs.get.rgba_to_int(math.random(0,50), 255, math.random(0,50),255))
									end
									funcs.doo.GW_overlay_start(temp_ent,ent_pos)
									ent_pos = funcs.get.screen_pos_3d(API.ent.get.coords(temp_ent))
									if g.var.gw_aim_rot-0.25<-180 then
										g.var.gw_aim_rot = 180
									else
										g.var.gw_aim_rot=g.var.gw_aim_rot-0.25
									end
									YIELD(0)
								end
							end
							g.var.gw_aim_ent=nil
							retain=TIME_MS()
						end
					else
						g.var.gw_aim_ent=nil
						retain=TIME_MS()
					end


					-- if funcs.ME._aim() then
						-- aim = funcs.get.ray_vctr_all(nil,true)
						-- if not funcs.is.ent(aim) then
							-- aim=API.plyr.get.aim_at(API.plyr.my_id())
						-- end
						-- if funcs.is.ent(aim) then
							-- g.var.gw_aim_ent=aim
							-- retain=TIME_MS()+100
						-- end
					-- end
				end
				if g._gee_watch_aim_assist.value == 0 then
					if funcs.is.ent(g.var.gw_aim_ent) and retain>TIME_MS() then
						funcs.doo.GW_overlay_start(g.var.gw_aim_ent,ent_pos)
					else
						g.var.gw_aim_ent=nil
						retain=TIME_MS()
					end
				end
				if g.var.gw_aim_rot-0.25<-180 then
					g.var.gw_aim_rot = 180
				else
					g.var.gw_aim_rot=g.var.gw_aim_rot-0.25
				end
				if one_yield then
					one_yield=false
				else
					YIELD(0)
				end
			end
			funcs.doo.remove_ent(los_ent,100)
		end)
	end
	local function clone_veh(_VEH)
		g.var.gw_aim_tp_show=true
		g.var.gw_aim_clone_veh=_VEH
		while funcs.ME._aim() and funcs.is.vk_key_down(inputs.vk_list[g.feat.gw_clone_key.value+1]) and funcs.is.veh(_VEH) do
			ray_start = funcs.get.front_of_dir(nil,nil,funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos())*1.25)
			ray_hit,g.var.gw_aim_pos = funcs.get.ray_vctr_all(nil,nil,ray_start,nil,0.5,funcs.vec(0,0,1))
			if not ray_hit then
				ray_hit = true
				g.var.gw_aim_pos = funcs.get.front_of_dir(ray_start,nil,(dist or 100))
			elseif g.var.gw_aim_pos then
				dist = funcs.get.dist_pospos_v3(funcs.ME._crds(),g.var.gw_aim_pos)+4
			else
				dist = 100
			end
			YIELD(0)
		end
		if ray_hit and funcs.is.veh(_VEH) then
			g.var.gw_aim_active=true
			funcs.doo.record_clone_veh(g.tbl.veh_clone,_VEH)
			local clone_veh = funcs.doo.create_clone_veh(g.tbl.veh_clone[_VEH],g.var.gw_aim_pos,API.ent.get.heading(_VEH),false,true)
			g.var.gw_aim_active=false
		end
		g.var.gw_aim_pos=nil
		g.var.gw_aim_tp_show=false
		g.var.gw_aim_clone_veh=nil
		funcs.doo.yield_while_true((funcs.ME._aim() or funcs.is.vk_key_down(inputs.vk_list[g.feat.gw_clone_key.value+1])),250)
	end


	-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function() --i was never happy with how it worked
		-- while g.feat.gw_main.on do
			-- if funcs.is.vk_key_down("F6") then
				-- while funcs.is.vk_key_down("F6") do
					-- YIELD(25)
				-- end
				-- funcs.doo.GW_cam()
			-- end
			-- YIELD(25)
		-- end
	-- end)


	while f.on do
		YIELD(0)
		if funcs.ME._aim() and funcs.is.GW_key_press(g.feat.gw_tp_key) and not g.var.gw_aim_active then --teleport
			g.var.gw_aim_tp_show=true
			while funcs.ME._aim() and funcs.is.vk_key_down(inputs.vk_list[g.feat.gw_tp_key.value+1]) do
				local use_cam = (g.var.gw_cam and ntv.cam.is.exist(g.var.gw_cam))
				if funcs.ME._in_veh() then
					temp_veh=funcs.ME._veh()
					tp_extra=2
					if use_cam then
						ray_start = cam.get_final_rendered_cam_pos()
					else
						ray_start = funcs.get.front_of_dir(nil,nil,funcs.get.dist_pospos_v3(funcs.ME._veh_crds(),API.cam.get.pos())*1.25)
					end
					ray_hit,g.var.gw_aim_pos = funcs.get.ray_vctr_all(nil,nil,ray_start,nil,2)
				else
					tp_extra=0.5
					if use_cam then
						ray_start = cam.get_final_rendered_cam_pos()
					else
						ray_start = funcs.get.front_of_dir(nil,nil,funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos())*1.25)
					end
					ray_hit,g.var.gw_aim_pos = funcs.get.ray_vctr_all(nil,nil,ray_start,nil,0.5)
				end
				if not ray_hit then
					ray_hit = true
					g.var.gw_aim_pos = funcs.get.front_of_dir(ray_start,nil,(dist or 100))
				elseif g.var.gw_aim_pos then
					dist = funcs.get.dist_pospos_v3(funcs.ME._crds(),g.var.gw_aim_pos)+tp_extra+2
				else
					dist = 100
				end
				YIELD(0)
			end
			if ray_hit then
				g.var.gw_aim_active=true
				if funcs.ME._in_veh() then
					if funcs.ntwrk.ask_long(funcs.ME._veh(),1000) then
						local speed = API.ent.get.velocity(funcs.ME._veh())
						if g._gee_watch_tp_speed.on then
							funcs.doo.id_migrate(funcs.ME._veh(),0)
						end
						API.ent.set.coords(funcs.ME._veh(),g.var.gw_aim_pos+funcs.vec(0,0,100))
						API.ent.set.rotation(funcs.ME._veh(),funcs.vec(0,0,API.ent.get.heading(funcs.ME._veh())))
						API.ent.set.coords(funcs.ME._veh(),g.var.gw_aim_pos)
						if g._gee_watch_tp_speed.on then
							YIELD(50)
							API.ent.set.velocity(funcs.ME._veh(),speed)
							API.veh.set.engine_on(funcs.ME._veh(), true, true, false)
							funcs.doo.id_migrate(funcs.ME._veh(),1)
						end
					end
				else
					API.ent.set.coords(funcs.ME._ped(),g.var.gw_aim_pos)
				end
				g.var.gw_aim_active=false
			end
			g.var.gw_aim_pos=nil
			g.var.gw_aim_tp_show=false
			funcs.doo.yield_while_true((funcs.ME._aim() or funcs.is.vk_key_down(inputs.vk_list[g.feat.gw_tp_key.value+1])),250)
		elseif funcs.is.ent(g.var.gw_aim_ent) then
			aim_ent=g.var.gw_aim_ent
			-- if funcs.is.veh(aim_ent) then
				-- local msg=""
				-- msg = msg.."MPBitset "..tostring(decorator.decor_get_int(aim_ent, "MPBitset"))
				-- msg = msg.."\nPlayer_Submarine "..tostring(decorator.decor_get_int(aim_ent, "Player_Submarine"))
				-- msg = msg.."\nPlayer_Avenger "..tostring(decorator.decor_get_int(aim_ent, "Player_Avenger"))--2176659152
				-- msg = msg.."\nPlayer_Truck "..tostring(decorator.decor_get_int(aim_ent, "Player_Truck")) --1502869817
				-- msg = msg.."\nPV_Slot "..tostring(decorator.decor_get_int(aim_ent, "PV_Slot"))
				-- msg = msg.."\nPlayer_Support_Bike_Vehicle "..tostring(decorator.decor_get_int(aim_ent, "Player_Support_Bike_Vehicle"))
				-- msg = msg.."\nPlayer_Hacker_Truck "..tostring(decorator.decor_get_int(aim_ent, "Player_Hacker_Truck"))
				-- msg = msg.."\nCompany_SUV "..tostring(decorator.decor_get_int(aim_ent, "Company_SUV"))
				-- msg = msg.."\nPlayer_Moon_Pool "..tostring(decorator.decor_get_int(aim_ent, "Player_Moon_Pool"))
				-- msg = msg.."\nPlayer_Acid_Lab "..tostring(decorator.decor_get_int(aim_ent, "Player_Acid_Lab"))
				-- msg = msg.."\nPlayer_Vehicle "..tostring(decorator.decor_get_int(aim_ent, "Player_Vehicle"))
				-- msg = msg.."\nVeh_Modded_By_Player "..tostring(decorator.decor_get_int(aim_ent, "Veh_Modded_By_Player"))
				-- msg = msg.."\nNot_Allow_As_Saved_Veh "..tostring(decorator.decor_get_int(aim_ent, "Not_Allow_As_Saved_Veh"))
				-- msg = msg.."\nPrevious_Owner "..tostring(decorator.decor_get_int(aim_ent, "Previous_Owner"))
				-- msg = msg.."\nOwned "..tostring(vehicle.get_vehicle_has_been_owned_by_player(aim_ent))
				-- msg = msg.."\nStolen "..tostring(native.call(0x4AF9BD80EEBEB453,aim_ent):__tointeger() == 1)
				-- msg = msg.."\nMy hash: "..tostring(network.network_hash_from_player(player.player_id()))
				-- menu.notify(msg)
				-- --CreatedByPegasus
				-- --Creator_Trailer
				-- --ContrabandOwner
			-- end
			--menu.notify(entity.get_entity_model_hash(aim_ent))
			local is_ped,is_player,pid,in_veh,is_veh,has_ped,veh = funcs.doo.GW_veh_ped_info(aim_ent)
			--for all ped/veh/player\
			if is_ped or is_veh then
				if funcs.is.GW_key_press(g.feat.gw_mark_key) then --------------------------------------------------M:Mark
					if g.tbl.GW_ent_mark[aim_ent] then
						g.tbl.GW_ent_mark[aim_ent]=nil
					elseif API.ent.is.ped(aim_ent) and API.Ped.is.plyr(aim_ent) then
						g.tbl.GW_ent_mark[aim_ent]=API.plyr.get.plyr_from_ped(aim_ent)
					else
						g.tbl.GW_ent_mark[aim_ent]=aim_ent
					end
					funcs.doo.yield_while_true(funcs.is.vk_key_down(inputs.vk_list[g.feat.gw_mark_key.value+1]),500)
				elseif funcs.is.GW_key_press(g.feat.gw_burn_key) then ----------------------------------------------V:burn
					funcs.doo.GW_action_list(g.feat.gw_burn_key,aim_ent,"burn")
				elseif funcs.is.GW_key_press(g.feat.gw_expld_key) then ---------------------------------------------X:explode
					funcs.doo.GW_action_list(g.feat.gw_expld_key,aim_ent,"explode")
				elseif funcs.is.GW_key_press(g.feat.gw_ntr_key) then -----------------------------------------------N: Neuter
					funcs.doo.GW_action_list(g.feat.gw_ntr_key,aim_ent,"ped_veh_ntr")
				elseif funcs.is.GW_key_press(g.feat.gw_black_hole_key) then ----------------------------------------B: black_hole
					funcs.doo.GW_action_list(g.feat.gw_black_hole_key,aim_ent,"black_hole")
				elseif is_veh or not is_player then
					if funcs.is.GW_key_press(g.feat.gw_invis_key) then ---------------------------------------------I:Invisible
						funcs.doo.GW_action_list(g.feat.gw_invis_key,aim_ent,"invisible")
					elseif funcs.is.GW_key_press(g.feat.gw_god_key) then -------------------------------------------H: God toggle
						funcs.doo.GW_action_list(g.feat.gw_god_key,aim_ent,"ped_veh_god")
					end
				end
				if is_veh then
					if funcs.is.GW_key_press(g.feat.gw_delete_key) then ---------------------------------------------- ~:delete
						funcs.doo.GW_action_list(g.feat.gw_delete_key,aim_ent,"delete")
					elseif funcs.is.GW_key_press(g.feat.gw_board_key) then  -------------------------------------------F:boarding
						funcs.doo.GW_action_list(g.feat.gw_board_key,aim_ent,"board")
					elseif funcs.is.GW_key_press(g.feat.gw_damdes_key) and not funcs.is.dead(aim_ent) then --------~:damage/destroy
						funcs.doo.GW_action_list(g.feat.gw_damdes_key,aim_ent,"dam_des")
					elseif funcs.is.GW_key_press(g.feat.gw_accel_key) then --------------------------------------- E:accelerate
						funcs.doo.GW_action_list(g.feat.gw_accel_key,aim_ent,"veh_boost")
					elseif funcs.is.GW_key_press(g.feat.gw_rvrs_key) then -----------------------------------------C:Reversing
						funcs.doo.GW_action_list(g.feat.gw_rvrs_key,aim_ent,"veh_rvrs")
					elseif funcs.is.GW_key_press(g.feat.gw_rpr_key) then ------------------------------------------R:Repair
						funcs.doo.GW_action_list(g.feat.gw_rpr_key,aim_ent,"repair")
					elseif funcs.is.GW_key_press(g.feat.gw_ele_key) then ------------------------------------------Q for elevate
						funcs.doo.GW_action_list(g.feat.gw_ele_key,aim_ent,"veh_up")
					elseif funcs.is.GW_key_press(g.feat.gw_upgr_key) then -----------------------------------------U for upgrade
						funcs.doo.GW_action_list(g.feat.gw_upgr_key,aim_ent,"veh_and_ped_upgr")
					elseif funcs.is.GW_key_press(g.feat.gw_d_ele_key) then  ---------------------------------------z for de-elevate
						funcs.doo.GW_action_list(g.feat.gw_d_ele_key,aim_ent,"ped_veh_down")
					elseif funcs.is.GW_key_press(g.feat.gw_clone_key) and not g.var.gw_aim_active then
						clone_veh(aim_ent)
					end
				elseif not is_player then
					if funcs.is.GW_key_press(g.feat.gw_delete_key) then ---------------------------------------------- ~:delete
						funcs.doo.GW_action_list(g.feat.gw_delete_key,aim_ent,"delete")
					elseif funcs.is.GW_key_press(g.feat.gw_accel_key) then ------------------------------------------- E:accelerate
						funcs.doo.GW_action_list(g.feat.gw_accel_key,aim_ent,"ped_forward")
					elseif funcs.is.GW_key_press(g.feat.gw_ele_key) then-----------------------------------------------Q for elevate
						funcs.doo.GW_action_list(g.feat.gw_ele_key,aim_ent,"ped_up")
					elseif funcs.is.GW_key_press(g.feat.gw_d_ele_key) then  -------------------------------------------z for ragdoll
						funcs.doo.GW_action_list(g.feat.gw_d_ele_key,aim_ent,"ped_ragdoll")
					elseif funcs.is.GW_key_press(g.feat.gw_upgr_key) then ---------------------------------------------U for upgrade
						funcs.doo.GW_action_list(g.feat.gw_upgr_key,aim_ent,"ped_upgrade")
					end
				end
				if pid then
					if g._gee_watch_player_info.on and plyr_name_count==0 and funcs.doo.gw_plyr_info(pid) then
						plyr_name_count=1
					end
					if funcs.is.GW_key_press(g.feat.gw_kick_key) then	-----------------------------------------------K: Kick
						funcs.doo.GW_action_list(g.feat.gw_kick_key,pid,"kick_pids_in_veh")
					end

					if funcs.is.GW_key_press(g.feat.gw_plyr_tab_key) then	-------------------------------------------O: Plyr tab
						menu.get_feature_by_hierarchy_key("online.online_players.player_"..pid):toggle()
						YIELD(250)
					end
				end
			end
		else
			plyr_name_count=0
		end
	end
end)
funcs.add_to_S_L(g.feat.gw_main,"g.feat.gw_main")


g.var.gee_watch_dynamic_translation_str = get_all_parents_and_name(g.feat.gw_main,false) --    debug_translation_list
dynamic_translation[g.var.gee_watch_dynamic_translation_str].FEAT_EXTRAS = {
"Explode",
"Destroy",
"Damage",
"Kick Player",
"Open Player Tab",
"Burn",
"Black Hole",
"Hijack",
"Boarding",
"Accel",
"Reverse",
"Repair",
"Upgrade",
"Up",
"Visibility",
"God",
"Delete",
"Neuter",
"Down",
"Ragdoll",
"Clone",
"Mark",
"Set key for Explode",
"Set key for Damage/Destroy",
"Set key for Delete",
"Set key for Boarding",
"Set key for Accel",
"Set key for Stop/Reverse",
"Set key for Repair",
"Set key for Elevate/Up",
"Set key for De-Elevate/Down/Ragdoll",
"Set key for Upgrade",
"Set key for Burn",
"Set key for Kick",
"Set key for God-Toggle",
"Set key for Neuter",
"Set key for Teleport",
"Set key for Clone",
"Set key for Mark",
"Set key for Visibility",
"Set key for Black Hole",
"Set key for Open Player Tab",
}

function funcs.doo.apply_gee_watch_feat_name_translation()
	local lang_table = lang[selected_lang][g.var.gee_watch_dynamic_translation_str]
	g.feat.gw_expld_set.name = funcs.get.translation_extras(lang_table,"Set key for Explode").." ("..inputs.vk_list[g.feat.gw_expld_key.value+1]..")"
	g.feat.gw_damdes_set.name = funcs.get.translation_extras(lang_table,"Set key for Damage/Destroy").." ("..inputs.vk_list[g.feat.gw_damdes_key.value+1]..")"
	g.feat.gw_delete_set.name = funcs.get.translation_extras(lang_table,"Set key for Delete").." ("..inputs.vk_list[g.feat.gw_delete_key.value+1]..")"
	g.feat.gw_board_set.name = funcs.get.translation_extras(lang_table,"Set key for Boarding").." ("..inputs.vk_list[g.feat.gw_board_key.value+1]..")"
	g.feat.gw_accel_set.name = funcs.get.translation_extras(lang_table,"Set key for Accel").." ("..inputs.vk_list[g.feat.gw_accel_key.value+1]..")"
	g.feat.gw_rvrs_set.name = funcs.get.translation_extras(lang_table,"Set key for Stop/Reverse").." ("..inputs.vk_list[g.feat.gw_rvrs_key.value+1]..")"
	g.feat.gw_rpr_set.name = funcs.get.translation_extras(lang_table,"Set key for Repair").." ("..inputs.vk_list[g.feat.gw_rpr_key.value+1]..")"
	g.feat.gw_ele_set.name = funcs.get.translation_extras(lang_table,"Set key for Elevate/Up").." ("..inputs.vk_list[g.feat.gw_ele_key.value+1]..")"
	g.feat.gw_d_ele_set.name = funcs.get.translation_extras(lang_table,"Set key for De-Elevate/Down/Ragdoll").." ("..inputs.vk_list[g.feat.gw_d_ele_key.value+1]..")"
	g.feat.gw_upgr_set.name = funcs.get.translation_extras(lang_table,"Set key for Upgrade").." ("..inputs.vk_list[g.feat.gw_upgr_key.value+1]..")"
	g.feat.gw_burn_set.name = funcs.get.translation_extras(lang_table,"Set key for Burn").." ("..inputs.vk_list[g.feat.gw_burn_key.value+1]..")"
	g.feat.gw_kick_set.name = funcs.get.translation_extras(lang_table,"Set key for Kick").." ("..inputs.vk_list[g.feat.gw_kick_key.value+1]..")"
	g.feat.gw_god_set.name = funcs.get.translation_extras(lang_table,"Set key for God-Toggle").." ("..inputs.vk_list[g.feat.gw_god_key.value+1]..")"
	g.feat.gw_ntr_set.name = funcs.get.translation_extras(lang_table,"Set key for Neuter").." ("..inputs.vk_list[g.feat.gw_ntr_key.value+1]..")"
	g.feat.gw_tp_set.name = funcs.get.translation_extras(lang_table,"Set key for Teleport").." ("..inputs.vk_list[g.feat.gw_tp_key.value+1]..")"
	g.feat.gw_clone_set.name = funcs.get.translation_extras(lang_table,"Set key for Clone").." ("..inputs.vk_list[g.feat.gw_clone_key.value+1]..")"
	g.feat.gw_mark_set.name = funcs.get.translation_extras(lang_table,"Set key for Mark").." ("..inputs.vk_list[g.feat.gw_mark_key.value+1]..")"
	g.feat.gw_invis_set.name = funcs.get.translation_extras(lang_table,"Set key for Visibility").." ("..inputs.vk_list[g.feat.gw_invis_key.value+1]..")"
	g.feat.gw_black_hole_set.name = funcs.get.translation_extras(lang_table,"Set key for Black Hole").." ("..inputs.vk_list[g.feat.gw_black_hole_key.value+1]..")"
	g.feat.gw_plyr_tab_set.name = funcs.get.translation_extras(lang_table,"Set key for Player Tab").." ("..inputs.vk_list[g.feat.gw_plyr_tab_key.value+1]..")"
end














function funcs.doo.GW_board(_vk_key,_veh)
	for i=1,3 do
		if funcs.is.vk_key_down(_vk_key) or funcs.ME._aim() then --delay added to reduce chance of firing missiles in the vehicle when you enter
			YIELD(50)
		else
			break
		end
	end
	local plyr_tp = g._gee_watch_passenger.value --"Only empty seat","Prefer empty seat","Always hijack"
	local npc_tp = g._gee_watch_passenger_npc.value
	local veh_seats = funcs.get.veh_seats(_veh)
	local success,in_veh,my_seat
	local my_ped =  funcs.ME._ped()
	for i=1, veh_seats do
		if not funcs.is.ent(API.veh.get.ped_in_seat(_veh, i-2)) then
			API.Ped.set.into_veh(my_ped,_veh,i-2)
			my_seat = i
			YIELD(50)
			break
		end
	end
	local delay = my_seat and 2 or 1
	for i=1,3 do
		for ii=1, veh_seats do
			if not my_seat or ii < my_seat then
				if not funcs.is.ent(_veh) then
					break
				else
					local PED = API.veh.get.ped_in_seat(_veh, ii-2)
					if funcs.is.ent(PED) then
						if API.ent.is.dead(PED) then
							API.Ped.clear_tasks(PED)
							YIELD(200*delay)
						elseif API.Ped.is.plyr(PED) then
							if plyr_tp == 2 or (plyr_tp == 1 and my_seat == nil) then
								glbls.kick_from_veh(API.plyr.get.plyr_from_ped(PED))
								API.Ped.clear_tasks(PED)
								YIELD(500*delay)
							end
						elseif npc_tp == 2 or (npc_tp == 1 and my_seat == nil) then
							API.Ped.clear_tasks(PED)
							YIELD(200*delay)
						end
					end
				end
				if funcs.is.ent(_veh) and not funcs.is.ent(API.veh.get.ped_in_seat(_veh, ii-2)) then
					API.Ped.set.into_veh(my_ped,_veh,ii-2)
					YIELD(200*delay)
				end
				if funcs.is.ent(_veh) and API.veh.get.ped_in_seat(_veh, ii-2) == my_ped then
					success=true
					break
				end
			end
		end
		if success or not funcs.is.ent(_veh) then break end
	end
	if funcs.ME._veh() ~= _veh then
		funcs.N_P(2,"Could not board vehicle :(",funcs.ver_text,4,"Red")
	end
end

g.tbl.GW_light_bright={
	[0]=20.0,
	[1]=20.0,
	[2]=20.0,
	[3]=20.0,
	[4]=20.0,
	[5]=40.0,
	[6]=80.0,
	[7]=100.0,
	[8]=110.0,
	[9]=120.0,
	[10]=130.0,
	[11]=140.0,
	[12]=170.0,
	[13]=180.0,
	[14]=170.0,
	[15]=160.0,
	[16]=140.0,
	[17]=130.0,
	[18]=100.0,
	[19]=60.0,
	[20]=45.0,
	[21]=30.0,
	[22]=20.0,
	[23]=20.0,
	[24]=20.0,
}



function funcs.doo.GW_highlight(aim_ent,bypass)
	local pos = API.ent.get.coords(aim_ent)
	local size = funcs.get.basic_veh_dimensions(true,aim_ent,1)
	local show = true
	if not bypass and g.tbl.GW_ent_history[aim_ent] then
		for k,v in pairs(g.tbl.GW_ent_history[aim_ent]) do
			if v then
				show=false
				break
			end
		end
	end
	if show then
		local bright = g.tbl.GW_light_bright[time.get_clock_hours()]*g._W_B_highlight_bright.value
		if bypass then
			if g._W_B_highlight_show.on then
				ntv.doo.spotlight(pos+funcs.vec(0,0,10),funcs.get.normalize_v3(pos,pos+funcs.vec(0,0,2)), 255, 0, 0, 20.0,bright, 6.0, 6.25*size, 20.0)
			end
			if g._W_B_ring_show.on then
				graphics.draw_marker(27, pos, funcs.vec(0, -180, 0), funcs.vec(0, 180, g.var.gw_aim_rot),funcs.vec(2*size,2*size,2*size),255,0, 0, math.floor(125*g._W_B_ring_bright.value), false, false, 2, false, nil, "MarkerTypeHorizontalSplitArrowCircle", false)
			end
		else
			if g._W_B_highlight_show.on then
				ntv.doo.spotlight(pos+funcs.vec(0,0,10),funcs.get.normalize_v3(pos,pos+funcs.vec(0,0,2)), 0, 255, 0, 20.0, bright, 6.0, 6.25*size, 20.0)
			end
			if g._W_B_ring_show.on then
				graphics.draw_marker(27, pos, funcs.vec(0, -180, 0), funcs.vec(0, 180, g.var.gw_aim_rot),funcs.vec(2*size,2*size,2*size),0,255, 0, math.floor(125*g._W_B_ring_bright.value), false, false, 2, false, nil, "MarkerTypeHorizontalSplitArrowCircle", false)
			end
		end
	end
end

function funcs.doo.GW_veh_ped_info(aim_ent)
	local is_ped,is_player,pid,in_veh,is_veh,has_ped,veh
	is_ped = API.ent.is.ped(aim_ent)
	is_veh = API.ent.is.veh(aim_ent)
	if is_ped then
		is_player = API.Ped.is.plyr(aim_ent)
		if is_player then
			pid = API.plyr.get.plyr_from_ped(aim_ent)
		end
		in_veh = API.Ped.is.in_veh(aim_ent)
	end
	if is_veh then
		veh = aim_ent
	elseif in_veh then
		veh = API.Ped.get.veh(aim_ent)
	end
	if veh then
		for i=1,funcs.get.veh_seats(veh) do
			local PED = API.veh.get.ped_in_seat(veh, i-2)
			if funcs.is.ent(PED) then
				if not has_ped then
					has_ped = PED
				end
				if API.Ped.is.plyr(PED) then
					has_ped = PED
					pid = API.plyr.get.plyr_from_ped(PED)
					break
				end
			end
		end
	end
	return is_ped,is_player,pid,in_veh,is_veh,has_ped,veh
end

function funcs.doo.GW_overlay_start(aim_ent,ent_pos)
	local is_ped,is_player,pid,in_veh,is_veh,has_ped,veh = funcs.doo.GW_veh_ped_info(aim_ent)
	if is_ped or is_veh then
		funcs.doo.GW_overlay_text(aim_ent,is_ped,is_player,in_veh,is_veh,veh,pid,has_ped,ent_pos)
		if is_ped then
			if in_veh then
				funcs.doo.GW_highlight(API.Ped.get.veh(aim_ent))
			else
				funcs.doo.GW_highlight(aim_ent)
			end
			if is_player  then
				if API.plyr.is.god(pid) then
					funcs.doo.GW_god_show()
				elseif in_veh and API.plyr.is.veh_god(pid) then
					funcs.doo.GW_god_show()
				end
			elseif API.ent.get.god(aim_ent) then
				funcs.doo.GW_god_show()
			elseif in_veh and API.ent.get.god(API.Ped.get.veh(aim_ent)) then
				funcs.doo.GW_god_show()
			end
		elseif is_veh then
			funcs.doo.GW_highlight(aim_ent)
			if API.ent.get.god(aim_ent) then
				funcs.doo.GW_god_show()
			end
		end
	end
end

function funcs.doo.GW_god_show()
	if g._W_B_god_show.on then
		funcs.doo.overlay("God",mth.abs(mth.rndm(g._W_B_cr.value-100,g._W_B_cr.value)),mth.abs(mth.rndm(g._W_B_cg.value-100,g._W_B_cg.value)),mth.abs(mth.rndm(g._W_B_cb.value-100,g._W_B_cb.value)),mth.abs(mth.rndm(g._W_B_a.value-100,g._W_B_a.value)),g._W_B_god_s.value/300,g._W_B_f.value,g._W_B_god_x.value/300,g._W_B_god_y.value/300)
	end
end

menu_add_feature("Apply recommended hotkeys?","action",g.prnt.optns_gw_b_htky.id,function()
funcs.doo.gw_keys_set_recc()
end)

g.feat.gw_expld_key=og_menu_add_feature("Key1 for GW vk_xpld","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_expld_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_expld_key,"g.feat.gw_expld_key")
g.feat.gw_expld_key.hidden=true

g.feat.gw_expld_set=menu_add_feature("Set key for Explode","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Explode"),g.feat.gw_expld_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Explode").." ("..inputs.vk_list[g.feat.gw_expld_key.value+1]..")"
end)

-------------------------------------------------------------------------------------------------------------
g.feat.gw_damdes_key=og_menu_add_feature("Key1 for GW vk_dmg","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_damdes_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_damdes_key,"g.feat.gw_damdes_key")
g.feat.gw_damdes_key.hidden=true

g.feat.gw_damdes_set=menu_add_feature("Set key for Damage/Destroy","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Damage/Destroy"),g.feat.gw_damdes_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Damage/Destroy").." ("..inputs.vk_list[g.feat.gw_damdes_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_delete_key=og_menu_add_feature("Key1 for GW vk_delete","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_delete_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_delete_key,"g.feat.gw_delete_key")
g.feat.gw_delete_key.hidden=true

g.feat.gw_delete_set=menu_add_feature("Set key for Delete","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Delete"),g.feat.gw_delete_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Delete").." ("..inputs.vk_list[g.feat.gw_delete_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_board_key=og_menu_add_feature("Key1 for GW vk_brd","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_board_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_board_key,"g.feat.gw_board_key")
g.feat.gw_board_key.hidden=true

g.feat.gw_board_set=menu_add_feature("Set key for Boarding","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Boarding"),g.feat.gw_board_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Boarding").." ("..inputs.vk_list[g.feat.gw_board_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_accel_key=og_menu_add_feature("Key1 for GW vk_accl","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_accel_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_accel_key,"g.feat.gw_accel_key")
g.feat.gw_accel_key.hidden=true

g.feat.gw_accel_set=menu_add_feature("Set key for Accel","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Accel"),g.feat.gw_accel_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Accel").." ("..inputs.vk_list[g.feat.gw_accel_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_rvrs_key=og_menu_add_feature("Key1 for GW vk_rvrs","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_rvrs_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_rvrs_key,"g.feat.gw_rvrs_key")
g.feat.gw_rvrs_key.hidden=true

g.feat.gw_rvrs_set=menu_add_feature("Set key for Stop/Reverse","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Stop/Reverse"),g.feat.gw_rvrs_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Stop/Reverse").." ("..inputs.vk_list[g.feat.gw_rvrs_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_rpr_key=og_menu_add_feature("Key1 for GW vk_rpr","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_rpr_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_rpr_key,"g.feat.gw_rpr_key")
g.feat.gw_rpr_key.hidden=true

g.feat.gw_rpr_set=menu_add_feature("Set key for Repair","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Repair"),g.feat.gw_rpr_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Repair").." ("..inputs.vk_list[g.feat.gw_rpr_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_ele_key=og_menu_add_feature("Key1 for GW vk_ele","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_ele_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_ele_key,"g.feat.gw_ele_key")
g.feat.gw_ele_key.hidden=true

g.feat.gw_ele_set=menu_add_feature("Set key for Elevate/Up","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Elevate/Up"),g.feat.gw_ele_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Elevate/Up").." ("..inputs.vk_list[g.feat.gw_ele_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_d_ele_key=og_menu_add_feature("Key1 for GW vk_de_ele_rag","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_d_ele_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_d_ele_key,"g.feat.gw_d_ele_key")
g.feat.gw_d_ele_key.hidden=true

g.feat.gw_d_ele_set=menu_add_feature("Set key for De-Elevate/Down/Ragdoll","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"De-Elevate/Down/Ragdoll"),g.feat.gw_d_ele_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for De-Elevate/Down/Ragdoll").." ("..inputs.vk_list[g.feat.gw_d_ele_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_upgr_key=og_menu_add_feature("Key1 for GW vk_upgr","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_upgr_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_upgr_key,"g.feat.gw_upgr_key")
g.feat.gw_upgr_key.hidden=true

g.feat.gw_upgr_set=menu_add_feature("Set key for Upgrade","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Upgrade"),g.feat.gw_upgr_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Upgrade").." ("..inputs.vk_list[g.feat.gw_upgr_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_burn_key=og_menu_add_feature("Key1 for GW vk_brn","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_burn_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_burn_key,"g.feat.gw_burn_key")
g.feat.gw_burn_key.hidden=true

g.feat.gw_burn_set=menu_add_feature("Set key for Burn","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Burn"),g.feat.gw_burn_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Burn").." ("..inputs.vk_list[g.feat.gw_burn_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_kick_key=og_menu_add_feature("Key1 for GW vk_kck","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_kick_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_kick_key,"g.feat.gw_kick_key")
g.feat.gw_kick_key.hidden=true

g.feat.gw_kick_set=menu_add_feature("Set key for Kick","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Kick"),g.feat.gw_kick_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Kick").." ("..inputs.vk_list[g.feat.gw_kick_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_god_key=og_menu_add_feature("Key1 for GW vk_god","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_god_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_god_key,"g.feat.gw_god_key")
g.feat.gw_god_key.hidden=true

g.feat.gw_god_set=menu_add_feature("Set key for God-Toggle","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"God-Toggle"),g.feat.gw_god_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for God-Toggle").." ("..inputs.vk_list[g.feat.gw_god_key.value+1]..")"
end)

-------------------------------------------------------------------------------------------------------------
g.feat.gw_ntr_key=og_menu_add_feature("Key1 for GW vk_ntr","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_ntr_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_ntr_key,"g.feat.gw_ntr_key")
g.feat.gw_ntr_key.hidden=true

g.feat.gw_ntr_set=menu_add_feature("Set key for Neuter","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Neuter"),g.feat.gw_ntr_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Neuter").." ("..inputs.vk_list[g.feat.gw_ntr_key.value+1]..")"
end)

-------------------------------------------------------------------------------------------------------------
g.feat.gw_tp_key=og_menu_add_feature("Key1 for GW vk_tp","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_tp_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_tp_key,"g.feat.gw_tp_key")
g.feat.gw_tp_key.hidden=true

g.feat.gw_tp_set=menu_add_feature("Set key for Teleport","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Teleport"),g.feat.gw_tp_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Teleport").." ("..inputs.vk_list[g.feat.gw_tp_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_clone_key=og_menu_add_feature("Key1 for GW vk_clone","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_clone_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_clone_key,"g.feat.gw_clone_key")
g.feat.gw_clone_key.hidden=true

g.feat.gw_clone_set=menu_add_feature("Set key for Clone","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Clone"),g.feat.gw_clone_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Clone").." ("..inputs.vk_list[g.feat.gw_clone_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_mark_key=og_menu_add_feature("Key1 for GW vk_mark","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_mark_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_mark_key,"g.feat.gw_mark_key")
g.feat.gw_mark_key.hidden=true

g.feat.gw_mark_set=menu_add_feature("Set key for Mark","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Mark"),g.feat.gw_mark_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Mark").." ("..inputs.vk_list[g.feat.gw_mark_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_invis_key=og_menu_add_feature("Key1 for GW vk_invis","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_invis_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_invis_key,"g.feat.gw_invis_key")
g.feat.gw_invis_key.hidden=true

g.feat.gw_invis_set=menu_add_feature("Set key for Visibility","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Visibility"),g.feat.gw_invis_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Visibility").." ("..inputs.vk_list[g.feat.gw_invis_key.value+1]..")"
end)
-------------------------------------------------------------------------------------------------------------
g.feat.gw_black_hole_key=og_menu_add_feature("Key1 for GW vk_black_hole","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_black_hole_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_black_hole_key,"g.feat.gw_black_hole_key")
g.feat.gw_black_hole_key.hidden=true

g.feat.gw_black_hole_set=menu_add_feature("Set key for Black Hole","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Black Hole"),g.feat.gw_black_hole_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Black Hole").." ("..inputs.vk_list[g.feat.gw_black_hole_key.value+1]..")"
end)

-------------------------------------------------------------------------------------------------------------
g.feat.gw_plyr_tab_key=og_menu_add_feature("Key1 for GW vk_player_tab","action_value_str",g.prnt.optns_gw_b_htky.id)
g.feat.gw_plyr_tab_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.gw_plyr_tab_key,"g.feat.gw_plyr_tab_key")
g.feat.gw_plyr_tab_key.hidden=true

g.feat.gw_plyr_tab_set=menu_add_feature("Set key for Open Player Tab","action",g.prnt.optns_gw_b_htky.id,function(f)
	funcs.doo.set_keybinds(1,"Gee-Watch "..funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Player Tab"),g.feat.gw_plyr_tab_key)
	f.name = funcs.get.translation_extras(lang[selected_lang][g.var.gee_watch_dynamic_translation_str],"Set key for Player Tab").." ("..inputs.vk_list[g.feat.gw_plyr_tab_key.value+1]..")"
end)

function funcs.doo.gw_keys_set_recc()
g.feat.gw_expld_key.value=23
g.feat.gw_damdes_key.value=63
g.feat.gw_board_key.value=5
g.feat.gw_accel_key.value=4
g.feat.gw_rvrs_key.value=2
g.feat.gw_rpr_key.value=17
g.feat.gw_ele_key.value=16
g.feat.gw_d_ele_key.value=25
g.feat.gw_upgr_key.value=20
g.feat.gw_burn_key.value=21
g.feat.gw_kick_key.value=10
g.feat.gw_god_key.value=7
g.feat.gw_ntr_key.value=13
g.feat.gw_tp_key.value=19
g.feat.gw_clone_key.value=85
g.feat.gw_mark_key.value=12
g.feat.gw_invis_key.value=8
g.feat.gw_black_hole_key.value=1
g.feat.gw_plyr_tab_key.value=14
g.feat.gw_delete_key.value=59
end

funcs.doo.gw_keys_set_recc()



function funcs.doo.GW_neuter(_ent,_time)
	if funcs.is.ent(_ent) then
		if g.tbl.gw_ntr.hist[_ent] ~= nil and g.tbl.gw_ntr.hist[_ent][1] then
			if funcs.is.veh(_ent) and funcs.ntwrk.ask_long(_ent,_time) then
				if g.tbl.gw_ntr.veh_hlth.on then
					API.veh.set.engine_health(_ent, 1000)
				end
				API.ent.set.max_speed(_ent,45000)
				g.tbl.gw_ntr.hist[_ent]={false,-1}
				return true
			elseif funcs.is.ped(_ent) then
				if g.tbl.gw_ntr.ped_weap.on and g.tbl.gw_ntr.hist[_ent][2] ~= -1 then
					funcs.doo.give_ped_weap2(_ent,g.tbl.gw_ntr.hist[_ent][2])
				end
				if not API.Ped.is.plyr(_ent) and funcs.ntwrk.ask_long(_ent,_time) then
					if g.tbl.gw_ntr.ped_hlth.on then
						funcs.doo.set_ped_health(_ent,200,100)
					end
					API.ent.set.max_speed(_ent,45000)
				end
				g.tbl.gw_ntr.hist[_ent]={false,-1}
				return true
			end
		else
			g.tbl.gw_ntr.hist[_ent]={false,-1}
			if funcs.is.veh(_ent) and funcs.ntwrk.ask_long(_ent,_time) then
				if g.tbl.gw_ntr.veh_weap.on and ntv.is.veh_have_weap(_ent) then
					ntv.doo.rmv_veh_weap(_ent)
				end
				if g.tbl.gw_ntr.veh_hlth.on then
					if ntv.get.veh_engine_health(_ent,false) ~= g.tbl.gw_ntr.veh_hlth.value then
						API.veh.set.engine_health(_ent, g.tbl.gw_ntr.veh_hlth.value)
					end
				end
				if g.tbl.gw_ntr.veh_speed.on then
					API.ent.set.max_speed(_ent,g.tbl.gw_ntr.veh_speed.value)
				end
				g.tbl.gw_ntr.hist[_ent]={true,-1}
				return true
			elseif funcs.is.ped(_ent) then
				if g.tbl.gw_ntr.ped_weap.on and API.Ped.get.weapon(_ent) ~= API.get_hash_key("weapon_unarmed") then
					g.tbl.gw_ntr.hist[_ent]={true,API.Ped.get.weapon(_ent)}
					API.wpn.ped_remove(_ent, API.Ped.get.weapon(_ent))
				end
				if not API.Ped.is.plyr(_ent) then
					if g.tbl.gw_ntr.ped_hlth.on and API.Ped.get.health(_ent) ~= g.tbl.gw_ntr.ped_hlth.value then
						funcs.doo.set_ped_health(_ent,g.tbl.gw_ntr.ped_hlth.value,100)
					end
					if g.tbl.gw_ntr.ped_speed.on then
						API.ent.set.max_speed(_ent,g.tbl.gw_ntr.ped_speed.value)
					end
					g.tbl.gw_ntr.hist[_ent][1]=true
				end
				return true
			end
		end
	end
	return false
end

g.tbl.gw_ntr={}
g.tbl.gw_ntr.hist={}
g.tbl.gw_ntr.prnt = menu_add_feature("Gee-Watch Neuter", "parent", g.prnt.optns_gw_b.id)

g.tbl.gw_ntr.veh_hlth=menu_add_feature("Set vehicle engine health","value_f",g.tbl.gw_ntr.prnt.id)
funcs.set_feat_i_f(g.tbl.gw_ntr.veh_hlth,0,1000,50,500,"g.tbl.gw_ntr.veh_hlth")
g.tbl.gw_ntr.veh_hlth.on=true

g.tbl.gw_ntr.veh_speed=menu_add_feature("Set vehicle speed","value_f",g.tbl.gw_ntr.prnt.id)
funcs.set_feat_i_f(g.tbl.gw_ntr.veh_speed,-50,50,0.5,5,"g.tbl.gw_ntr.veh_speed")
g.tbl.gw_ntr.veh_speed.on=true

g.tbl.gw_ntr.veh_weap=menu_add_feature("Remove vehicle weapon (Irreversible)","toggle",g.tbl.gw_ntr.prnt.id)
funcs.add_to_S_L(g.tbl.gw_ntr.veh_weap,"g.tbl.gw_ntr.veh_weap")
g.tbl.gw_ntr.veh_weap.on=true

g.tbl.gw_ntr.ped_hlth=menu_add_feature("Set ped health","value_f",g.tbl.gw_ntr.prnt.id)
funcs.set_feat_i_f(g.tbl.gw_ntr.ped_hlth,100,500,10,120,"g.tbl.gw_ntr.ped_hlth")
g.tbl.gw_ntr.ped_hlth.on=true

g.tbl.gw_ntr.ped_speed=menu_add_feature("Set ped speed","value_f",g.tbl.gw_ntr.prnt.id)
funcs.set_feat_i_f(g.tbl.gw_ntr.ped_speed,0,5,.5,2,"g.tbl.gw_ntr.ped_speed")
g.tbl.gw_ntr.ped_speed.on=true

g.tbl.gw_ntr.ped_weap=menu_add_feature("Remove ped/player current weapon","toggle",g.tbl.gw_ntr.prnt.id)
funcs.add_to_S_L(g.tbl.gw_ntr.ped_weap,"g.tbl.gw_ntr.ped_weap")
g.tbl.gw_ntr.ped_weap.on=true


-----------------------------------------------------------------------------------------GEE-SKID
------------------------------------------------------------------------------------------Options
------------------------------------------------------------------------------Watch_Boost_Options
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g._ped_veh_accel = menu_add_feature("Vehicle/Ped Accel", "action_slider", g.prnt.optns_gw_b.id)
funcs.set_feat_i_f(g._ped_veh_accel,10,200,10,10,"g._ped_veh_accel")

g._ped_veh_revers = menu_add_feature("Vehicle Reverse", "action_slider", g.prnt.optns_gw_b.id)
funcs.set_feat_i_f(g._ped_veh_revers,0,200,10,0,"g._ped_veh_revers")

g._ped_veh_up = menu_add_feature("Vehicle/Ped Go Up", "action_slider", g.prnt.optns_gw_b.id)
funcs.set_feat_i_f(g._ped_veh_up,0,200,10,50,"g._ped_veh_up")

g._ped_veh_down = menu_add_feature("Vehicle/Ped Go Down", "action_slider", g.prnt.optns_gw_b.id)
funcs.set_feat_i_f(g._ped_veh_down,0,200,10,50,"g._ped_veh_down")

g._gee_watch_destroy = menu_add_feature("Upgrade Damage to Destroy?", "toggle", g.prnt.optns_gw_b.id, function(f)
	if funcs.is.GS_loaded() then
		if f.on then g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_damdes_key.value+1]..") set to Destroy.",__GV__,5,"Blue")
		else g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_damdes_key.value+1]..") set to Damage.",__GV__,5,"Blue")
		end
	end
end)
funcs.add_to_S_L(g._gee_watch_destroy,"g._gee_watch_destroy")

g._gee_watch_explo_type = menu_add_feature("Explosion type", "action_value_str", g.prnt.optns_gw_b.id)
new_set_str_data(g._gee_watch_explo_type,{"Simple", "Orbital"})
funcs.add_to_S_L(g._gee_watch_explo_type,"g._gee_watch_explo_type")

g._gee_watch_explo_blame = menu_add_feature("Explosion/Burn blame", "action_value_str", g.prnt.optns_gw_b.id)
new_set_str_data(g._gee_watch_explo_blame,{"Them", "Me"})
funcs.add_to_S_L(g._gee_watch_explo_blame,"g._gee_watch_explo_blame")

g._gee_watch_passenger = menu_add_feature("Boarding player vehicle", "action_value_str", g.prnt.optns_gw_b.id, function(f)
	if funcs.is.GS_loaded() then
		if f.on then g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_board_key.value+1]..") boarding players will only hijack if there is no free seat.",__GV__,5,"Blue")
		else g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_board_key.value+1]..") boarding players will always take driver seat.",__GV__,5,"Blue")
		end
	end
end)
new_set_str_data(g._gee_watch_passenger,{"Only empty seat","Prefer empty seat","Always hijack"})
funcs.add_to_S_L(g._gee_watch_passenger,"g._gee_watch_passenger")
g._gee_watch_passenger.value=1

g._gee_watch_passenger_npc = menu_add_feature("Boarding NPC vehicle", "action_value_str", g.prnt.optns_gw_b.id, function(f)
	if funcs.is.GS_loaded() then
		if f.on then g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_board_key.value+1]..") boarding NPCs will only hijack if there is no free seat.",__GV__,5,"Blue")
		else g.N_P(2,"Gee-Watch ("..inputs.vk_list[g.feat.gw_board_key.value+1]..") boarding NPCs will always take driver seat.",__GV__,5,"Blue")
		end
	end
end)
new_set_str_data(g._gee_watch_passenger_npc,{"Only empty seat","Prefer empty seat","Always hijack"})
funcs.add_to_S_L(g._gee_watch_passenger_npc,"g._gee_watch_passenger_npc")
g._gee_watch_passenger_npc.value=2

g._gee_watch_aim_assist = menu_add_feature("Aim type", "action_value_str", g.prnt.optns_gw_b.id)
new_set_str_data(g._gee_watch_aim_assist,{"Legacy","25% Screen Assist","50% Screen Assist","75% Screen Assist","100% Screen Assist"})
funcs.add_to_S_L(g._gee_watch_aim_assist,"g._gee_watch_aim_assist")
g._gee_watch_aim_assist.value=1

g._gee_watch_trgt_swtch=menu_add_feature("Target switch time (ms)","action_value_i",g.prnt.optns_gw_b.id)
funcs.set_feat_i_f(g._gee_watch_trgt_swtch,25,1000,25,150,"g._gee_watch_trgt_swtch")

g._gee_watch_black_hole_type = menu_add_feature("Type", "action_value_str", g.prnt.optns_gw_black_hole_prnt.id)
new_set_str_data(g._gee_watch_black_hole_type,{"Follow entity","Fixed point"})
funcs.add_to_S_L(g._gee_watch_black_hole_type,"g._gee_watch_black_hole_type")

g._gee_watch_black_hole_los = menu_add_feature("Line of sight", "action_value_str", g.prnt.optns_gw_black_hole_prnt.id)
new_set_str_data(g._gee_watch_black_hole_los,{"Not required","Required"})
funcs.add_to_S_L(g._gee_watch_black_hole_los,"g._gee_watch_black_hole_los")

g._gee_watch_black_hole_power=menu_add_feature("Intensity","action_value_f",g.prnt.optns_gw_black_hole_prnt.id)
funcs.set_feat_i_f(g._gee_watch_black_hole_power,0.25,5,0.25,1,"g._gee_watch_black_hole_power")

g._gee_watch_black_hole_movement=menu_add_feature("Movement type","action_value_str",g.prnt.optns_gw_black_hole_prnt.id)
new_set_str_data(g._gee_watch_black_hole_movement,{"Precise","Chaotic"})
funcs.add_to_S_L(g._gee_watch_black_hole_movement,"g._gee_watch_black_hole_movement")

g._gee_watch_black_hole_duration=menu_add_feature("Duration (Seconds)","action_value_i",g.prnt.optns_gw_black_hole_prnt.id)
funcs.set_feat_i_f(g._gee_watch_black_hole_duration,1,30,1,10,"g._gee_watch_black_hole_duration")

g._gee_watch_black_hole_range=menu_add_feature("Range","action_value_i",g.prnt.optns_gw_black_hole_prnt.id)
funcs.set_feat_i_f(g._gee_watch_black_hole_range,25,500,25,100,"g._gee_watch_black_hole_range")

g._gee_watch_black_hole_sphere=menu_add_feature("Show sphere","value_str",g.prnt.optns_gw_black_hole_prnt.id)
new_set_str_data(g._gee_watch_black_hole_sphere,{"At start","Continuous"})
funcs.add_to_S_L(g._gee_watch_black_hole_sphere,"g._gee_watch_black_hole_sphere")
g._gee_watch_black_hole_sphere.on=true

g._gee_watch_player_info = menu_add_feature("Display player info notification?", "toggle", g.prnt.optns_gw_b.id, function(f)
	if f.on and funcs.is.GS_loaded() then
		g.N_P(2,"Gee-Watch will display player info when aiming at them.",__GV__,4,"Blue")
	end
end)
funcs.add_to_S_L(g._gee_watch_player_info,"g._gee_watch_player_info")

g._gee_watch_tp_speed = menu_add_feature("Retain speed when teleporting", "toggle", g.prnt.optns_gw_b.id)
funcs.add_to_S_L(g._gee_watch_tp_speed,"g._gee_watch_tp_speed")
-----------------------------------------------------------------------------------------GEE-SKID
------------------------------------------------------------------------------------------Options
------------------------------------------------------------------------------Watch_Boost_Options
------------------------------------------------------------------------------Watch_Boost_Display
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------


g._Watch_display_on_ent = menu_add_feature("Enable display", "toggle", g.prnt.optns_gw_b_dsply_on_ent.id,function(f)
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._Watch_display_on_ent,"g._Watch_display_on_ent")

g._Watch_display_NPC_name = menu_add_feature("Display model name of NPC", "toggle", g.prnt.optns_gw_b_dsply_on_ent.id,function(f)
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._Watch_display_NPC_name,"g._Watch_display_NPC_name")

g._Watch_display_list = menu_add_feature("Display list of commands", "toggle", g.prnt.optns_gw_b_dsply_on_ent.id,function(f)
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._Watch_display_list,"g._Watch_display_list")

g._W_B_cr_on = menu_add_feature("Red", "action_value_i", g.prnt.optns_gw_b_dsply_on_ent.id)
funcs.set_feat_i_f(g._W_B_cr_on,0,255,1,0,"g._W_B_cr_on")

g._W_B_cg_on = menu_add_feature("Green", "action_value_i", g.prnt.optns_gw_b_dsply_on_ent.id)
funcs.set_feat_i_f(g._W_B_cg_on,0,255,1,255,"g._W_B_cg_on")

g._W_B_cb_on = menu_add_feature("Blue", "action_value_i", g.prnt.optns_gw_b_dsply_on_ent.id)
funcs.set_feat_i_f(g._W_B_cb_on,0,255,1,0,"g._W_B_cb_on")

g._W_B_ca_on_t = menu_add_feature("Text alpha", "action_value_i", g.prnt.optns_gw_b_dsply_on_ent.id)
funcs.set_feat_i_f(g._W_B_ca_on_t,0,255,1,150,"g._W_B_ca_on_t")

g._W_B_ca_on_b = menu_add_feature("Background alpha", "action_value_i", g.prnt.optns_gw_b_dsply_on_ent.id)
funcs.set_feat_i_f(g._W_B_ca_on_b,0,255,1,105,"g._W_B_ca_on_b")

menu_add_feature("Apply recommended settings?", "action", g.prnt.optns_gw_b_dsply_on_ent.id, function(f)
	funcs.doo.GW_recc_sett2()
end)
-------------------------------------------------------------------------------------------------
g._Watch_display = menu_add_feature("Enable display", "toggle", g.prnt.optns_gw_b_dsply_legacy.id,function(f)
	if f.on and funcs.is.GS_loaded() then
		g.N_P(2,"Gee-Watch overlay will display when aiming at an entity.",__GV__,4,"Blue")
	end
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._Watch_display,"g._Watch_display")



g._test_w_display_action = menu_add_feature("Display test overlay?", "action", g.prnt.optns_gw_b_dsply_legacy.id, function()
	g._test_w_display_action.hidden=true
	g.N_P(2,"Gee-Watch test overlay will display for 10 seconds",__GV__,3,"Blue")
	local time = TIME_MS() +10000
	while time > TIME_MS() do
		YIELD(0)
		funcs.doo.overlay("Explode Destroy Damage Delete Kick Burn Hijack Accel Reverse Repair Upgrade Up Ragdoll Down",g._W_B_cr.value,g._W_B_cg.value,g._W_B_cb.value,g._W_B_a.value,g._W_B_s.value/300,g._W_B_f.value,g._W_B_x.value/300,g._W_B_y.value/300)
	end
	g.N_P(2,"Gee-Watch test overlay is finished.",__GV__,3,"Blue")
	g._test_w_display_action.hidden=false
end)


g._W_B_x = menu_add_feature("X Pos", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_x,0,300,1,150,"g._W_B_x")

g._W_B_y = menu_add_feature("Y Pos", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_y,0,300,1,289,"g._W_B_y")

g._W_B_s = menu_add_feature("Scale", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_s,75,300,1,170,"g._W_B_s")

g._W_B_f = menu_add_feature("Font", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_f,0,9,1,6,"g._W_B_f")

g._W_B_cr = menu_add_feature("Red", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_cr,0,255,1,0,"g._W_B_cr")

g._W_B_cg = menu_add_feature("Green", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_cg,0,255,1,255,"g._W_B_cg")

g._W_B_cb = menu_add_feature("Blue", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_cb,0,255,1,0,"g._W_B_cb")

g._W_B_a = menu_add_feature("Alpha", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_a,30,255,1,105,"g._W_B_a")

g._W_B_highlight_show = menu_add_feature("Highlight entity", "toggle", g.prnt.optns_gw_b_dsply.id,function(f)
	if f.on and funcs.is.GS_loaded() then
		g.N_P(2,"A light will shine on the Gee-Watch aim entity.\nThe brightness adjusts according to the hour of the day.",__GV__,5,"Blue")
	end
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._W_B_highlight_show,"g._W_B_highlight_show")

g._W_B_highlight_bright=menu_add_feature("Highlight brightness", "action_value_f", g.prnt.optns_gw_b_dsply.id)
funcs.set_feat_i_f(g._W_B_highlight_bright,0.2,2,0.1,1,"g._W_B_highlight_bright")

g._W_B_ring_show = menu_add_feature("Circle entity", "toggle", g.prnt.optns_gw_b_dsply.id,function()
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._W_B_ring_show,"g._W_B_ring_show")

g._W_B_ring_bright=menu_add_feature("Circle brightness", "action_value_f", g.prnt.optns_gw_b_dsply.id)
funcs.set_feat_i_f(g._W_B_ring_bright,0.2,2,0.1,1,"g._W_B_ring_bright")

g._W_B_line_show = menu_add_feature("Show line to entity", "toggle", g.prnt.optns_gw_b_dsply.id)
funcs.add_to_S_L(g._W_B_line_show,"g._W_B_line_show")
g._W_B_line_show.on=true

g._W_B_god_show = menu_add_feature("Show God detected", "toggle", g.prnt.optns_gw_b_dsply_legacy.id,function()
	g._W_B_settings_hide()
end)
funcs.add_to_S_L(g._W_B_god_show,"g._W_B_god_show")

g._test_g_display_action = menu_add_feature("Display test god?", "action", g.prnt.optns_gw_b_dsply_legacy.id, function(f)
	f.hidden=true
	g.N_P(2,"God-detected test will display for 10 seconds",__GV__,3,"Blue")
	local time = TIME_MS() +10000
	while time > TIME_MS() do
		YIELD(0)
		funcs.doo.GW_god_show()
	end
	g.N_P(2,"God-detected test is finished.",__GV__,3,"Blue")
	f.hidden=false
end)

g._W_B_god_x = menu_add_feature("God detected X pos", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_god_x,0,300,1,0,"g._W_B_god_x")

g._W_B_god_y = menu_add_feature("God detected Y pos", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_god_y,0,300,1,0,"g._W_B_god_y")

g._W_B_god_s = menu_add_feature("God detected scale", "action_value_i", g.prnt.optns_gw_b_dsply_legacy.id)
funcs.set_feat_i_f(g._W_B_god_s,75,300,1,0,"g._W_B_god_s")

menu_add_feature("Apply recommended settings?", "action", g.prnt.optns_gw_b_dsply_legacy.id, function(f)
	funcs.doo.GW_recc_sett()
end)

function g._W_B_settings_hide()
	g._Watch_display_NPC_name.hidden=(not g._Watch_display_on_ent.on)
	g._Watch_display_list.hidden=(not g._Watch_display_on_ent.on)
	g._W_B_cr_on.hidden=(not g._Watch_display_list.on or not g._Watch_display_on_ent.on)
	g._W_B_cg_on.hidden=(not g._Watch_display_list.on or not g._Watch_display_on_ent.on)
	g._W_B_cb_on.hidden=(not g._Watch_display_list.on or not g._Watch_display_on_ent.on)
	g._W_B_ca_on_t.hidden=(not g._Watch_display_list.on or not g._Watch_display_on_ent.on)
	g._W_B_ca_on_b.hidden=(not g._Watch_display_on_ent.on)
	g._W_B_x.hidden=(not g._Watch_display.on)
	g._W_B_y.hidden=(not g._Watch_display.on)
	g._W_B_s.hidden=(not g._Watch_display.on)
	g._W_B_f.hidden=(not g._Watch_display.on)
	g._W_B_cr.hidden=(not g._Watch_display.on)
	g._W_B_cg.hidden=(not g._Watch_display.on)
	g._W_B_cb.hidden=(not g._Watch_display.on)
	g._W_B_a.hidden=(not g._Watch_display.on)
	g._test_w_display_action.hidden=(not g._Watch_display.on)
	g._test_g_display_action.hidden=(not g._W_B_god_show.on)
	g._W_B_god_x.hidden=(not g._W_B_god_show.on)
	g._W_B_god_y.hidden=(not g._W_B_god_show.on)
	g._W_B_god_s.hidden=(not g._W_B_god_show.on)
	g._W_B_ring_bright.hidden=(not g._W_B_ring_show.on)
	g._W_B_highlight_bright.hidden=(not g._W_B_highlight_show.on)
end

function funcs.doo.GW_recc_sett()
	g._ped_veh_accel.value=120.0
	g._ped_veh_revers.value=0.0
	g._ped_veh_up.value=200.0
	g._ped_veh_down.value=90.0
	g._W_B_x.value=150.0
	g._W_B_y.value=289.0
	g._W_B_s.value=170.0
	g._W_B_f.value=6.0
	g._W_B_cr.value=0.0
	g._W_B_cg.value=255.0
	g._W_B_cb.value=0.0
	g._W_B_a.value=105.0
	g._W_B_god_x.value=150.0
	g._W_B_god_y.value=142.0
	g._W_B_god_s.value=213.0
	g._Watch_display.on=false
	g._W_B_highlight_show.on=true
	g._W_B_highlight_bright.value=1
	g._W_B_ring_show.on=true
	g._W_B_ring_bright.value=1
	g._W_B_god_show.on=false
end

function funcs.doo.GW_recc_sett2()
	g._Watch_display_on_ent.on=true
	g._Watch_display_NPC_name.on=false
	g._Watch_display_list.on=true
	g._W_B_cr_on.value=0
	g._W_B_cg_on.value=255
	g._W_B_cb_on.value=0
	g._W_B_ca_on_t.value=150
	g._W_B_ca_on_b.value=105
end

funcs.doo.GW_recc_sett()
funcs.doo.GW_recc_sett2()


g.print_load_info("Gee-Watch",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Map Teleport"

function funcs.is.should_enable_thermal(f,unarmed)
	if f.value==2 then
		return true
	end
	local my_weap = funcs.ME._weap()
	if f.value==0 then
		if weap_info.sniper_true[my_weap] and funcs.ME._aim() then
			return true
		end
	elseif f.value==1 then
		local veh_weap = ntv.get.ped_veh_weap(funcs.ME._ped()) ~=0
		if my_weap and my_weap ~= unarmed and not veh_weap and weap_info.hand.type[my_weap] ~= "Throw" and funcs.ME._aim() then
			return true
		end
	end
end


function funcs.doo.thermal_each_frame(_val) --doesnt actually need to be called each frame
	if _val ==1 then
		if g.feat.thermal_noise.on then
			ntv.set.thermal_vision_max_noise(0)
			ntv.set.thermal_vision_min_noise(0)
			ntv.set.thermal_vision_hilight_noise(0)
		end
		ntv.set.thermal_fade_start(10.0)
		ntv.set.thermal_fade_end(g.feat.thermal_fade_ends.value)
		ntv.set.thermal_vision_max_thickness(g.feat.thermal_thickness.value)
		if g.feat.thermal_near_colors.on then
			ntv.set.thermal_color_near(g.feat.thermal_near_r.value,g.feat.thermal_near_g.value,g.feat.thermal_near_b.value)
		end
		if g.feat.thermal_heat2.on then
			ntv.set.thermal_heat_scale(2,g.feat.thermal_heat2.value)
		end
	end
end

function funcs.doo.thermal_toggle(_val)
	glbls.set_vision_bypass(_val)
	ntv.set.thermal_vision(_val)
	if _val == 0 then
		ntv.set.thermal_vision_reset()
		return
	end
	funcs.doo.thermal_each_frame(_val)
end

g.feat.thermal_vision_basic=menu_add_feature("Enable thermal normally", "value_str", g.prnt.thermal_vision.id, function(f)
	if f.on then
		g.feat.thermal_vision_flicker.on=false
	end
	local unarmed,was_active = API.get_hash_key("weapon_unarmed")
	while f.on do
		if funcs.is.should_enable_thermal(f,unarmed) then
			funcs.doo.thermal_toggle(1)
			while f.on and funcs.is.should_enable_thermal(f,unarmed) do
				was_active = ntv.is.thermal_vision_active()
				funcs.doo.thermal_each_frame(was_active and 1 or 0)
				if API.cntrl.is.just_pressed(0,54) then
					funcs.doo.thermal_toggle(was_active and 0 or 1)
				end
				YIELD(0)
			end
			funcs.doo.thermal_toggle(0)
		end
		YIELD(0)
	end
	funcs.doo.thermal_toggle(0)
end)
new_set_str_data(g.feat.thermal_vision_basic,{"Aiming with a sniper","Aiming any gun","Always"})
funcs.add_to_S_L(g.feat.thermal_vision_basic,"g.feat.thermal_vision_basic")

g.feat.thermal_vision_flicker=menu_add_feature("Enable thermal flicker", "value_str", g.prnt.thermal_vision.id, function(f)
	if f.on then
		g.feat.thermal_vision_basic.on=false
	end
	local time,was_active
	local unarmed = API.get_hash_key("weapon_unarmed")
	while f.on do
		time = TIME_MS()
		if funcs.is.should_enable_thermal(f,unarmed) then
			funcs.doo.thermal_toggle(1)
			YIELD(0)
			was_active = ntv.is.thermal_vision_active()
			if was_active then -- because gta is dumb and sometimes wont turn it on for a frame or two
				while was_active and f.on and funcs.is.should_enable_thermal(f,unarmed) and TIME_MS() < time+g.feat.thermal_vision_flicker_on.value do
					was_active = ntv.is.thermal_vision_active()
					funcs.doo.thermal_each_frame(was_active and 1 or 0)
					if API.cntrl.is.just_pressed(0,54) then
						funcs.doo.thermal_toggle(was_active and 0 or 1)
					end
					YIELD(0)
				end
				funcs.doo.thermal_toggle(0)
				if was_active then
					time = TIME_MS()
					while f.on and funcs.is.should_enable_thermal(f,unarmed) and TIME_MS() < time+g.feat.thermal_vision_flicker_off.value do
						was_active = ntv.is.thermal_vision_active()
						funcs.doo.thermal_each_frame(was_active and 1 or 0)
						if API.cntrl.is.just_pressed(0,54) then
							funcs.doo.thermal_toggle(was_active and 0 or 1)
						end
						YIELD(0)
					end
				end
			else
				YIELD(0)
			end
		else
			YIELD(0)
		end
	end
	funcs.doo.thermal_toggle(0)
end)
new_set_str_data(g.feat.thermal_vision_flicker,{"Aiming with a sniper","Aiming any gun","Always"})
funcs.add_to_S_L(g.feat.thermal_vision_flicker,"g.feat.thermal_vision_flicker")

function funcs.doo.feat_value_within_limit(f,str,default,digits,type)
	local status,str = funcs.get.text_input(str,default,digits,type)
	if status==0 then
		local num = mth.flr(((tonumber(str)/f.mod)+0.5))*f.mod
		num = num<f.min and f.min or num> f.max and f.max or num
		f.value=num
	end
end

g.feat.thermal_vision_flicker_on=menu_add_feature("Thermal flicker 'on' time (ms)", "action_value_i", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 100 and 5000 ms",f.value,4,3)
end)
funcs.set_feat_i_f(g.feat.thermal_vision_flicker_on,100,5000,100,500,"g.feat.thermal_vision_flicker_on")

g.feat.thermal_vision_flicker_off=menu_add_feature("Thermal flicker 'off' time (ms)", "action_value_i", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 100 and 5000 ms",f.value,4,3)
end)
funcs.set_feat_i_f(g.feat.thermal_vision_flicker_off,100,5000,100,1000,"g.feat.thermal_vision_flicker_off")

g.feat.thermal_thickness=menu_add_feature("See-through thickness", "action_value_f", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 1 and 100",f.value,3,3)
end)
funcs.set_feat_i_f(g.feat.thermal_thickness,1,100,1,5,"g.feat.thermal_thickness")

g.feat.thermal_fade_ends=menu_add_feature("Fade distance", "action_value_f", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 10 and 3000",f.value,4,3)
end)
funcs.set_feat_i_f(g.feat.thermal_fade_ends,10,3000,10,2000,"g.feat.thermal_fade_ends")

g.feat.thermal_noise=menu_add_feature("Remove noise", "toggle", g.prnt.thermal_vision.id, function(f)
	if not f.on then
		ntv.set.thermal_vision_reset()
	end
end)
funcs.add_to_S_L(g.feat.thermal_noise,"g.feat.thermal_noise")

g.feat.thermal_heat2=menu_add_feature("Heat scale", "value_f", g.prnt.thermal_vision.id, function(f)
	if not f.on then
		ntv.set.thermal_vision_reset()
	end
end)
funcs.set_feat_i_f(g.feat.thermal_heat2,0,1,0.05,0.55,"g.feat.thermal_heat2")

g.feat.thermal_near_colors=menu_add_feature("Custom color", "toggle", g.prnt.thermal_vision.id, function(f)
	if not f.on then
		ntv.set.thermal_vision_reset()
	end
end)
funcs.add_to_S_L(g.feat.thermal_near_colors,"g.feat.thermal_near_colors")

g.feat.thermal_near_r=menu_add_feature("Red", "action_value_i", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 0 and 255",f.value,3,3)
end)
funcs.set_feat_i_f(g.feat.thermal_near_r,0,255,1,69,"g.feat.thermal_near_r")

g.feat.thermal_near_g=menu_add_feature("Green", "action_value_i", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 0 and 255",f.value,3,3)
end)
funcs.set_feat_i_f(g.feat.thermal_near_g,0,255,1,69,"g.feat.thermal_near_g")

g.feat.thermal_near_b=menu_add_feature("Blue", "action_value_i", g.prnt.thermal_vision.id, function(f)
	funcs.doo.feat_value_within_limit(f,"Enter a number between 0 and 255",f.value,3,3)
end)
funcs.set_feat_i_f(g.feat.thermal_near_b,0,255,1,0,"g.feat.thermal_near_b")


------------------------------------------------------------------------------------------GeeSkid
---------------------------------------------------------------------------------------------Self
-------------------------------------------------------------------------------------TeleportSelf
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g.feat.self_veh_tp_best_seat_auto=menu_add_feature("Best free seat", "value_str", g.prnt.self_teleport_seat.id, function(f)--will TP you to the driver seat or closest to it
	g.feat.self_veh_tp_driver_seat_auto.on=false
	if not funcs.ME._in_veh() and funcs.is.GS_loaded() and f.on then
		g.N_P(2,"You are not in a vehicle.\nWaiting to Auto-TP...",__GV__,4,"Blue")
	end
	local my_veh,my_seat,free_seat,npc_or_dead_fail,time
	while f.on do
		YIELD(250)
		if funcs.ME._in_veh() and not funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id())) then
			my_veh=API.plyr.get.veh(API.plyr.my_id())
			my_seat = funcs.get.what_seat_plyr_in(my_veh,API.plyr.my_id())
			free_seat,npc_or_dead_fail = funcs.get.first_free_seat(my_veh,true)
			if free_seat > -2 and my_seat > free_seat then
				for i = 0,funcs.get.veh_seats(my_veh) do
					if my_seat > i-1 then
						if funcs.is.seat_empty(my_veh, i-1) then
							API.Ped.set.into_veh(API.plyr.get.ped(API.plyr.my_id()),my_veh,i-1)
							break
						elseif f.value == 0 and funcs.is.ent(my_veh) and not API.Ped.is.plyr(API.veh.get.ped_in_seat(my_veh, i-1)) then
							API.Ped.clear_tasks(API.veh.get.ped_in_seat(my_veh, i-1))
							time = TIME_MS() + 500
							while time > TIME_MS() and funcs.is.ent(my_veh) and funcs.is.ent(API.veh.get.ped_in_seat(my_veh, i-1)) do
								YIELD(0)
							end
							if funcs.is.seat_empty(my_veh, i-1) then
								API.Ped.set.into_veh(API.plyr.get.ped(API.plyr.my_id()),my_veh,i-1)
								break
							else
								npc_or_dead_fail=true
							end
						end
					end
				end
			end
			if npc_or_dead_fail then
				YIELD(5000) -- prevents it from tying to kick out or delete dead peds repeatedly
			end
		end
	end
end)
new_set_str_data(g.feat.self_veh_tp_best_seat_auto,{"Take NPC Seat","Only empty seat"})
funcs.add_to_S_L(g.feat.self_veh_tp_best_seat_auto,"g.feat.self_veh_tp_best_seat_auto")

g.feat.self_veh_tp_driver_seat_auto=menu_add_feature("Hijack", "value_str", g.prnt.self_teleport_seat.id, function(f)
	g.feat.self_veh_tp_best_seat_auto.on=false
	if not funcs.ME._in_veh() and funcs.is.GS_loaded() and f.on then
		g.N_P(2,"You are not in a vehicle.\nWaiting to Auto-Hijack...",__GV__,4,"Blue")
	end
	local me,friend,same_orgmc,continue,my_ped,name
	while f.on do
		YIELD(250)
		me=API.plyr.my_id()
		friend,same_orgmc,continue = false,false,false
		if funcs.ME._in_veh() and not funcs.ME._driving(API.plyr.get.veh(me)) then
			my_ped=API.plyr.get.ped(me)
			if funcs.is.seat_empty(API.plyr.get.veh(me),-1) then
				API.Ped.set.into_veh(my_ped,API.plyr.get.veh(me),-1)
			else
				if API.Ped.is.plyr(API.veh.get.ped_in_seat(API.plyr.get.veh(me), -1)) then
					if API.plyr.is.friend(API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(API.plyr.get.veh(me), -1))) then
						friend = true
					end
					if funcs.is.same_orgmc(me,API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(API.plyr.get.veh(me), -1))) then
						same_orgmc = true
					end
				end
				if f.value == 3 or (not friend and not same_orgmc) then
					continue = true
				elseif f.value == 1 and not friend then
					continue = true
				elseif f.value == 2 and not same_orgmc then
					continue=true
				end
				if continue then
					name = funcs.get.pid_name(API.veh.get.ped_in_seat(API.plyr.get.veh(me), -1))
					if funcs.doo.veh_tp_into_hijack(API.plyr.get.veh(me),true) then
						g.N_P(2,name.." - Kicked out :)",__GV__,4,"Green")
					else
						g.N_P(2,name.." - FAILED to Kick out :(",__GV__,4,"Red")
						YIELD(5000)
					end
				end
			end
		end
	end
end)
new_set_str_data(g.feat.self_veh_tp_driver_seat_auto,{"Not Friends/ORG/MC","Not Friends","Not ORG/MC","Anyone"})
funcs.add_to_S_L(g.feat.self_veh_tp_driver_seat_auto,"g.feat.self_veh_tp_driver_seat_auto")

menu_add_feature("Free seat in current vehicle", "action", g.prnt.self_teleport.id, function(f)
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle...",__GV__,4,"Blue")
	else
		local me=API.plyr.my_id()
		local my_ped=API.plyr.get.ped(me)
		local my_veh=API.plyr.get.veh(me)
		local seat_count = funcs.get.veh_seats(my_veh)
		if funcs.is.seat_empty(my_veh,-1) then
			API.Ped.set.into_veh(my_ped,my_veh,-1)
		elseif vehicle.is_vehicle_full(my_veh) then
			for i=1,seat_count-1 do
				local random_seat = mth.rndm(0,seat_count-2)
				if funcs.is.seat_empty(my_veh,random_seat) then
					API.Ped.set.into_veh(my_ped,my_veh,random_seat)
					break
				end
			end
		else
			g.N_P(2,"Vehicle is full.",__GV__,4,"Blue")
		end
	end
end)

menu_add_feature("Hijack driver seat in current vehicle", "action", g.prnt.self_teleport.id, function()
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle.",__GV__,4,"Blue")
	else
		local me=API.plyr.my_id()
		if funcs.ME._driving(API.plyr.get.veh(me)) then
			g.N_P(2,"You are already driving!",__GV__,4,"Blue")
		elseif funcs.is.seat_empty(API.plyr.get.veh(me),-1) then
			API.Ped.set.into_veh(API.plyr.get.ped(me),API.plyr.get.veh(me),-1)
		else
			local name = funcs.get.pid_name(API.veh.get.ped_in_seat(API.plyr.get.veh(me), -1))
			if funcs.doo.veh_tp_into_hijack(API.plyr.get.veh(me),true) then
				g.N_P(2,name.." - Kicked out :)",__GV__,4,"Green")
			else
				g.N_P(2,name.." - FAILED to Kick out :(",__GV__,4,"Red")
			end
		end
	end
end)

g.var.rand_pid_last_for_tp = 32
g.feat.tp_into_rndm_plyr_veh=menu_add_feature("Into random player vehicle", "action_value_str", g.prnt.self_teleport.id, function(f,pid)
	if API.plyr.count() < 2 then
		g.N_P(2,"You are the only player in session.",__GV__,4,"Blue")
	else
		local pid_table,pid_table2 = funcs.get.rand_pid_table(),{}
		local previous = nil
		for i=1,#pid_table do
			if funcs.is.valid_pid(pid_table[i]) and pid_table[i] ~= funcs.ME._id() then
				if API.plyr.is.in_veh(pid_table[i]) or API.plyr.get.coords(pid_table[i]).z == -50  then
					if not funcs.ME._in_that_veh(API.plyr.get.veh(pid_table[i])) then
						if g.var.rand_pid_last_for_tp == pid_table[i] then
							previous=pid_table[i]
						else
							pid_table2[#pid_table2+1]=pid_table[i]
						end
					end
				end
			end
		end
		if previous then
			pid_table2[#pid_table2+1] = previous
		end
		if #pid_table2 == 0 then
			g.N_P(2,"No available players.",__GV__,4,"Blue")
		else
			funcs.doo.tp_into_plyr_veh2(pid_table2,f.value,true)
		end
	end
end)
new_set_str_data(g.feat.tp_into_rndm_plyr_veh,{"Free Seat","Their Seat","Hijack"})
funcs.add_to_S_L(g.feat.tp_into_rndm_plyr_veh,"g.feat.tp_into_rndm_plyr_veh")

g.feat.tp_near_rndm_plyr=menu_add_feature("Near random player", "action", g.prnt.self_teleport.id, function(f,pid)
	if API.plyr.count() < 2 then
		g.N_P(2,"You are the only player in session.",__GV__,4,"Blue")
	else
		local plyr_pos = nil
		local plyr=nil
		local pid_table = funcs.get.rand_pid_table()
		for i=1,#pid_table do
			if funcs.is.valid_pid(pid_table[i]) and (pid_table[i] ~= API.plyr.my_id()) then
				 if not intrr.is_pid_intrr(pid_table[i]) and not funcs.ME._in_that_veh(API.plyr.get.veh(pid_table[i])) then
					if (API.plyr.get.coords(pid_table[i]) ~= funcs.vec(0,0,0)) and (pid_table[i] ~= g.var.rand_pid_last_for_tp) then
						plyr_pos = funcs.get.pos_nearby2(API.plyr.get.coords(pid_table[i]),20,false)
						plyr=pid_table[i]
						break
					end
				end
			end
		end
		if not plyr_pos then
			if funcs.is.valid_pid(g.var.rand_pid_last_for_tp) then
				plyr_pos = funcs.get.pos_nearby2(API.plyr.get.coords(g.var.rand_pid_last_for_tp),20,false)
			else
				g.N_P(2,"No player available.",__GV__,4,"Blue")
			end
		end
		if not plyr_pos then
			g.N_P(2,"No player available.",__GV__,4,"Blue")
		elseif funcs.ME._in_veh() then
			if not funcs.doo.tp_ent(g.tbl.PID_INFO.veh[API.plyr.my_id()+1],plyr_pos, 0 ,false) then
				g.N_P(2,funcs.get.pid_name(API.plyr.my_id()).."  -  "..funcs.get.veh_model_name(g.tbl.PID_INFO.veh[API.plyr.my_id()+1]).."\nFailed to get control of vehicle :(",__GV__,4,"Red")
			else
				g.var.rand_pid_last_for_tp=plyr
			end
		else
			API.ent.set.coords(API.plyr.get.ped(API.plyr.my_id()),plyr_pos)
			g.var.rand_pid_last_for_tp=plyr
		end
		pid_table = nil
	end
end)

function funcs.doo.tp_into_plyr_veh2(_table,_action,_bypass)
	local hover_tbl,i_hovered,completed,not_needed = funcs.get.hover_info(),false,false,false
	local pid,veh,stop,time,seat,no_veh
	g.tbl.online_plyr_temp[#g.tbl.online_plyr_temp+1]=false
	local name = funcs.get.pid_name(_table[1])
	local temp = #g.tbl.online_plyr_temp
	local function should_continue()
		if (_action == 0 and funcs.get.num_empty_seats(veh) == 0) or
			(_action == 1 and pid == funcs.ME._id()) or
			(_action == 2 and funcs.ME._driving(veh)) then
			not_needed=true
			return false
		end
		return true
	end
	for i=1,#_table do
		pid = _table[i]
		not_needed=false
		if funcs.is.valid_pid(pid) and pid ~= funcs.ME._id() then
			if API.plyr.is.in_veh(pid) then
				veh = API.plyr.get.veh(pid)
				if should_continue() then
					if _action == 0 then
						completed = funcs.doo.veh_tp_into_free_seat(veh)
					elseif _action == 1 then
						seat = funcs.get.what_seat_plyr_in(veh,pid)
						completed = funcs.doo.veh_tp_into_that_seat(veh,seat)
					elseif _action == 2 then
						completed = funcs.doo.veh_tp_into_that_seat(veh,-1)
					end
				end
			elseif _bypass or (#_table==1 and g.tbl.PID_INFO.tp_sett[pid+1]) then
				if funcs.get.dist_me_pid_3d(pid) > 250 then
					local temp_pos,plyr_pos = API.plyr.get.coords(pid)
					funcs.get.ground_z(temp_pos,true)
					temp_pos.z=temp_pos.z+50
					API.ent.set.coords(funcs.ME._ped(), temp_pos)
					i_hovered=true
					YIELD(0)
					time = TIME_MS() + 1750
					local do_once = false
					while funcs.is.valid_pid(pid) and not completed and not not_needed and (TIME_MS() < time) do
						if g.tbl.online_plyr_temp[temp] == _action then
							completed=true
						elseif g.tbl.online_plyr_temp[temp] == "fail" then
							time = TIME_MS()
						else
							if not funcs.ME._in_veh() then
								plyr_pos = API.plyr.get.coords(pid)
								if plyr_pos.z < -45 then
									API.ent.set.coords(funcs.ME._ped(), temp_pos)
								else
									API.ent.set.coords(funcs.ME._ped(), plyr_pos+funcs.vec(0,0,50))
								end
							end
							if API.plyr.is.in_veh(pid) and not do_once then
								do_once=true
								veh = API.plyr.get.veh(pid)
								YIELD(0)
								if should_continue() then
									time=time+2000
									g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
										local __veh,__pid,__temp,__action =  veh,pid,temp,_action
										if __action == 0 then
											if funcs.doo.veh_tp_into_free_seat(__veh) then
												g.tbl.online_plyr_temp[__temp] = __action
											else
												g.tbl.online_plyr_temp[__temp] = "fail"
											end
										elseif __action == 1 then
											local seat = funcs.get.what_seat_plyr_in(__veh,__pid)
											if seat > -2 and funcs.doo.veh_tp_into_that_seat(__veh,seat) then
												g.tbl.online_plyr_temp[__temp] = __action
											else
												g.tbl.online_plyr_temp[__temp] = "fail"
											end
										elseif __action == 2 then
											if funcs.doo.veh_tp_into_that_seat(__veh,-1) then
												g.tbl.online_plyr_temp[__temp] = __action
											else
												g.tbl.online_plyr_temp[__temp] = "fail"
											end
										end
									end)
								end
							end
						end
						YIELD(10)
					end
					for ii=1,#_table do
						if ii > i and funcs.is.valid_pid(_table[ii]) and not API.plyr.is.in_veh(_table[ii]) and funcs.get.dist_me_pid_3d(_table[ii]) < 250 then
							_table[ii]=nil
						end
					end
				elseif #_table==1 then
					no_veh = name.."\nHas no vehicle."
				end
			elseif #_table==1 then
				no_veh = name.."\nHas no vehicle. Try enabling force check."
			end
		end
		if completed then
			g.var.rand_pid_last_for_tp=pid
			break
		end
	end
	if not completed then
		if i_hovered then
			funcs.doo.hover_back(hover_tbl)
		end
		if no_veh then
			g.N_P(2,no_veh,__GV__,5,"Yellow")
		elseif #_table==1 and not_needed then
			g.N_P(2,name.."\nTeleport not needed/possible.",__GV__,5,"Yellow")
		else
			local name_or = ""
			if #_table==1 then
				name_or = name.."\n"
			end
			if _action == 0 then
				g.N_P(2,name_or.."Teleport FAILED :(\n(No free seat)",__GV__,5,"Red")
			elseif _action == 1 then
				g.N_P(2,name_or.."Teleport FAILED :(\n(Could not steal seat)",__GV__,5,"Red")
			elseif _action == 2 then
				g.N_P(2,name_or.."Teleport FAILED :(\n(Could not hijack)",__GV__,5,"Red")
			end
		end
	end
end

---------------------------------------------------------------------------------------------------------------------------------
g.feat.tp_out_my_veh_f=menu_add_feature("TP out of my vehicle", "value_str", g.prnt.self_teleport_veh_out.id, function(f)
	while f.on do
		f.name = "Hold ("..inputs.vk_list[g.feat.tp_out_my_veh_f_key.value+1]..") - TP out of my veh"
		YIELD(50)
		if not funcs.ME._in_veh() then
			funcs.is.vk_key_down_with_delay(inputs.vk_list[g.feat.tp_out_my_veh_f_key.value+1])
		elseif funcs.is.vk_key_down(inputs.vk_list[g.feat.tp_out_my_veh_f_key.value+1]) then
			funcs.doo.veh_tp_in_or_out(nil,f.value,inputs.vk_list[g.feat.tp_out_my_veh_f_key.value+1],g.feat.tp_out_my_veh_f_dly.value)
		end
	end
	f.name = "TP out of vehicle"
end)
new_set_str_data(g.feat.tp_out_my_veh_f,{"No speed","Some speed","All speed"})
funcs.add_to_S_L(g.feat.tp_out_my_veh_f,"g.feat.tp_out_my_veh_f")
g.feat.tp_out_my_veh_f.value=1

g.feat.tp_out_my_veh_f_dly = menu_add_feature("TP out - Hold Delay (ms)", "autoaction_value_i", g.prnt.self_teleport_veh_out.id)
funcs.set_feat_i_f(g.feat.tp_out_my_veh_f_dly,100,1000,25,700,"g.feat.tp_out_my_veh_f_dly")

g.feat.tp_out_my_veh_f_key=og_menu_add_feature("Key1 for (F) TP out - hidden","action_value_str",g.prnt.self_teleport_veh_out.id)
g.feat.tp_out_my_veh_f_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.tp_out_my_veh_f_key,"g.feat.tp_out_my_veh_f_key")
g.feat.tp_out_my_veh_f_key.hidden=true
g.feat.tp_out_my_veh_f_key.value=5

menu_add_feature("TP out - Set key","action",g.prnt.self_teleport_veh_out.id,function(f)
	funcs.doo.set_keybinds(1,"TP out of vehicle",g.feat.tp_out_my_veh_f_key)
	f.name = "TP out - Set key ("..inputs.vk_list[g.feat.tp_out_my_veh_f_key.value+1]..")"
end)
---------------------------------------------------------------------------------------------------------------------------------
g.feat.tp_into_close_veh_f=menu_add_feature("TP into closest vehicle", "value_str", g.prnt.self_teleport_veh_in.id, function(f)
	while f.on do
		f.name = "Hold ("..inputs.vk_list[g.feat.tp_into_close_veh_f_key.value+1]..") - TP into closest veh"
		YIELD(50)
		if funcs.ME._in_veh() then
			funcs.is.vk_key_down_with_delay(inputs.vk_list[g.feat.tp_into_close_veh_f_key.value+1])
		elseif funcs.is.vk_key_down(inputs.vk_list[g.feat.tp_into_close_veh_f_key.value+1]) then
			funcs.doo.veh_tp_in_or_out(f.value,nil,inputs.vk_list[g.feat.tp_into_close_veh_f_key.value+1],g.feat.tp_into_close_veh_f_dly.value)
		end
	end
	f.name = "TP into vehicle"
end)
new_set_str_data(g.feat.tp_into_close_veh_f,{"Free Seat","Hijack","Prefer Free Seat"})
funcs.add_to_S_L(g.feat.tp_into_close_veh_f,"g.feat.tp_into_close_veh_f")

g.feat.tp_into_close_veh_f_dly = menu_add_feature("TP into - Delay (ms)", "action_value_i", g.prnt.self_teleport_veh_in.id)
funcs.set_feat_i_f(g.feat.tp_into_close_veh_f_dly,100,1000,25,700,"g.feat.tp_into_close_veh_f_dly")

g.feat.tp_into_close_veh_f_key=og_menu_add_feature("Key1 for (F) TP into - hidden","autoaction_value_str",g.prnt.self_teleport_veh_in.id)
g.feat.tp_into_close_veh_f_key:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.feat.tp_into_close_veh_f_key,"g.feat.tp_into_close_veh_f_key")
g.feat.tp_into_close_veh_f_key.hidden=true
g.feat.tp_into_close_veh_f_key.value=5

menu_add_feature("TP into - Set key","action",g.prnt.self_teleport_veh_in.id,function(f)
	funcs.doo.set_keybinds(1,"TP into vehicle",g.feat.tp_into_close_veh_f_key)
	f.name = "TP into - Set key ("..inputs.vk_list[g.feat.tp_into_close_veh_f_key.value+1]..")"
end)
---------------------------------------------------------------------------------------------------------------------------------
g.tbl.auto_enter = {}
g.tbl.auto_enter.feat=menu_add_feature("Enable","toggle",g.prnt.self_teleport_veh_auto.id,function(f)
	local veh
	while f.on do
		if funcs.ME._in_veh() then
			YIELD(500)
		else
			YIELD(100)
			veh = ntv.get.veh_ped_try_enter(API.plyr.get.ped(API.plyr.my_id()))
			if funcs.is.veh(veh) then
				g.tbl.auto_enter.do_it(veh)
				YIELD(100)
			end
		end
	end
end)
funcs.add_to_S_L(g.tbl.auto_enter.feat,"g.tbl.auto_enter.feat")

function g.tbl.auto_enter.do_it(_veh)
	for i=1,funcs.get.veh_seats(_veh) do
		if API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh,i-2)) then
			if g.tbl.auto_enter.plyr.value == 0 or g.tbl.auto_enter.plyr.value == 1 then
				if not funcs.doo.veh_tp_into_free_seat(_veh) and g.tbl.auto_enter.plyr.value == 1 then
					funcs.doo.veh_tp_into_hijack(_veh,true)
				end
			else
				funcs.doo.veh_tp_into_hijack(_veh,true)
			end
			return
		end
	end
	if g.tbl.auto_enter.npc.value == 0 or g.tbl.auto_enter.npc.value == 1 then
		if not funcs.doo.veh_tp_into_free_seat(_veh) and g.tbl.auto_enter.npc.value == 1 then
			funcs.doo.veh_tp_into_hijack(_veh,false)
		end
	else
		funcs.doo.veh_tp_into_hijack(_veh,false)
	end
	return
end

g.tbl.auto_enter.plyr = menu_add_feature("Entering player vehicle", "action_value_str", g.prnt.self_teleport_veh_auto.id)
new_set_str_data(g.tbl.auto_enter.plyr,{"Only empty seat","Prefer empty seat","Always hijack"})
funcs.add_to_S_L(g.tbl.auto_enter.plyr,"g.tbl.auto_enter.plyr")
g.tbl.auto_enter.plyr.value=1

g.tbl.auto_enter.npc = menu_add_feature("Entering NPC vehicle", "action_value_str", g.prnt.self_teleport_veh_auto.id)
new_set_str_data(g.tbl.auto_enter.npc,{"Only empty seat","Prefer empty seat","Always hijack"})
funcs.add_to_S_L(g.tbl.auto_enter.npc,"g.tbl.auto_enter.npc")
g.tbl.auto_enter.npc.value=1



---------------------------------------------------------------------------------------------------------------------------------
g.feat.tp_friends_2_me=menu_add_feature("TP my friends to me", "action_value_str", g.prnt.self_teleport_plyrs.id, function(f)
	funcs.doo.tp_frnds_or_org_2_me_v2("friends",f.value == 0 and "front" or "nearby",funcs.ME._veh_or_me_crds())
end)
new_set_str_data(g.feat.tp_friends_2_me,{"In front","Nearby"})
funcs.add_to_S_L(g.feat.tp_friends_2_me,"g.feat.tp_friends_2_me")

menu_add_feature("TP my friends to waypoint/objective", "action", g.prnt.self_teleport_plyrs.id, function(f)
	local wp = funcs.get.waypoint() or funcs.get.OBJ_coords3()
	if wp then
		funcs.doo.tp_frnds_or_org_2_me_v2("friends","nearby",wp)
	else
		g.N_P(2,"No waypoint/objective.",__GV__,4,"Yellow")
	end
end)

g.feat.tp_orgmc_2_me=menu_add_feature("TP my ORG/MC to me", "action_value_str", g.prnt.self_teleport_plyrs.id, function(f)
	funcs.doo.tp_frnds_or_org_2_me_v2("same_orgmc",f.value == 0 and "front" or "nearby",funcs.ME._veh_or_me_crds())
end)
new_set_str_data(g.feat.tp_orgmc_2_me,{"In front","Nearby"})
funcs.add_to_S_L(g.feat.tp_orgmc_2_me,"g.feat.tp_orgmc_2_me")

menu_add_feature("TP my ORG/MC to waypoint/objective", "action", g.prnt.self_teleport_plyrs.id, function(f)
	local wp = funcs.get.waypoint() or funcs.get.OBJ_coords3()
	if wp then
		funcs.doo.tp_frnds_or_org_2_me_v2("same_orgmc","nearby",wp)
	else
		g.N_P(2,"No waypoint/objective.",__GV__,4,"Yellow")
	end
end)

g.feat.tp_all_plyrs_2_me=menu_add_feature("TP all players to me", "action_value_str", g.prnt.self_teleport_plyrs.id, function(f)
	funcs.doo.tp_frnds_or_org_2_me_v2("all_players",f.value == 0 and "front" or "nearby",funcs.ME._veh_or_me_crds())
end)
new_set_str_data(g.feat.tp_all_plyrs_2_me,{"In front","Nearby"})
funcs.add_to_S_L(g.feat.tp_all_plyrs_2_me,"g.feat.tp_all_plyrs_2_me")

menu_add_feature("TP all players to waypoint/objective", "action", g.prnt.self_teleport_plyrs.id, function(f)
	local wp = funcs.get.waypoint() or funcs.get.OBJ_coords3()
	if wp then
		funcs.doo.tp_frnds_or_org_2_me_v2("all_players","nearby",wp)
	else
		g.N_P(2,"No waypoint/objective.",__GV__,4,"Yellow")
	end
end)

function funcs.doo.tp_2_me_tp(_pid,tp_points,active,veh_active,my_orig_pos, heading)
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		g.tbl.sssn_pid_active[active][_pid]=true
		local _pid,active,veh_active,my_orig_pos, heading = _pid,active,veh_active,my_orig_pos, heading
		local veh = API.plyr.get.veh(_pid)
		if not g.tbl.sssn_pid_active[veh_active][veh] then
			g.tbl.sssn_pid_active[veh_active][veh]=true
			if funcs.ntwrk.ask_long(veh,2000) then
				tp_points[_pid].z=tp_points[_pid].z+funcs.get.veh_tp_height(veh)
				API.ent.set.coords(veh, tp_points[_pid])
			else
				g.N_P(2,funcs.get.pid_name(_pid).."\nTeleport FAILED :(",__GV__,5,"Red")
			end
		end
		g.tbl.sssn_pid_active[active][_pid]=false
	end)
end

function funcs.doo.tp_frnds_or_org_2_me_v2(_type,_where,_pos)
	local tp_table = {}
	for i=0,31 do
		if funcs.is.valid_pid(i) and i ~= funcs.ME._id() then
			local coords = API.plyr.get.coords(i)
			if API.plyr.is.in_veh(i) or (coords.z > -51 and coords.z < -49) then
				if funcs.get.dist_pospos_v2(coords,_pos) > 75 then
					if _type == "friends" then
						if API.plyr.is.friend(i) then
							tp_table[#tp_table+1]=i
						end
					elseif _type == "same_orgmc" then
						if funcs.is.same_orgmc(funcs.ME._id(),i) then
							tp_table[#tp_table+1]=i
						end
					else
						tp_table[#tp_table+1]=i
					end
				end
			end
		end
	end
	if #tp_table == 0 then
		g.N_P(2,"No players available.",__GV__,4,"Blue")
	else
		local my_orig_pos = _pos -- added waypoint/objective too lazy to update
		local heading = funcs.ME._head()
		local tp_points = {}
		if _where == "front" then
			for k,v in pairs(tp_table) do
				tp_points[v]=funcs.get.front_of_pos(my_orig_pos, heading+mth.rndm(-20,20), mth.rndm(10,20), 180+mth.rndm(-20,20), mth.rndm(2,5))
			end
		else--if _where == "nearby" then
			local t = funcs.get.spawn_points(my_orig_pos,#tp_table)
			for k,v in pairs(tp_table) do
				tp_points[v]=t[k]
			end
		end
		g.tbl.sssn_pid_active[#g.tbl.sssn_pid_active+1]={}
		local active = #g.tbl.sssn_pid_active
		g.tbl.sssn_pid_active[#g.tbl.sssn_pid_active+1]={}
		local veh_active = #g.tbl.sssn_pid_active
		for i=1,#tp_table do
			if funcs.is.valid_pid(tp_table[i]) and API.plyr.is.in_veh(tp_table[i]) then
				funcs.doo.tp_2_me_tp(tp_table[i],tp_points,active,veh_active,my_orig_pos, heading)
			end
		end
		local found = true
		while found do
			found = false
			for k,v in pairs(g.tbl.sssn_pid_active[active]) do
				if v then found = true break end
			end
			YIELD(10)
		end
		local hover_tbl,i_hovered,h_pos = funcs.get.hover_info(),false
		for i=1,#tp_table do
			_pid = tp_table[i]
			if funcs.is.valid_pid(_pid) and g.tbl.sssn_pid_active[active][_pid]==nil and funcs.get.dist_me_pid_3d(_pid) > 250 then
				h_pos = API.plyr.get.coords(_pid)
				funcs.get.ground_z(h_pos,true)
				if API.plyr.get.coords(_pid).z < -45 then
					API.ent.set.coords(funcs.ME._ped(), h_pos+funcs.vec(0,0,50))
				else
					API.ent.set.coords(funcs.ME._ped(), API.plyr.get.coords(_pid)+funcs.vec(0,0,50))
				end
				i_hovered=true
				local time = TIME_MS() + 2500
				local do_once = false
				while time > TIME_MS() do
					for ii=1,#tp_table do
						if funcs.is.valid_pid(tp_table[ii]) and g.tbl.sssn_pid_active[active][tp_table[ii]]==nil and API.plyr.is.in_veh(tp_table[ii]) then
							funcs.doo.tp_2_me_tp(tp_table[ii],tp_points,active,veh_active,my_orig_pos, heading)
							if not do_once then
								do_once=true
								time=time+1000
							end
						end
					end
					if API.plyr.get.coords(_pid).z < -45 then
						API.ent.set.coords(funcs.ME._ped(), h_pos+funcs.vec(0,0,50))
					else
						API.ent.set.coords(funcs.ME._ped(), API.plyr.get.coords(_pid)+funcs.vec(0,0,50))
					end
					YIELD(10)
					if do_once then
						local found = false
						for k,v in pairs(g.tbl.sssn_pid_active[active]) do
							if v then found = true break end
						end
						if not found then
							time = TIME_MS()
						end
					end
				end
			end
		end
		if i_hovered then
			funcs.doo.hover_back(hover_tbl)
		end
	end
end

menu_add_feature("TP forward", "action", g.prnt.self_teleport.id, function()
	local my_pos = funcs.get.front_of_dir(funcs.ME._veh_or_me_crds(),funcs.ME._veh_or_me_rot(),20)
	my_pos.z=0
	if funcs.get.ground_z(my_pos,false) then
		if funcs.ME._in_veh() then
			local veh = funcs.ME._veh()
			local hash = API.ent.get.model_hash(veh)
			if streaming.is_model_a_plane(hash) or streaming.is_model_a_heli(hash) then
				my_pos.z=my_pos.z+2
				if API.ent.is.in_air(veh) then
					if funcs.ME._veh_crds().z < my_pos.z then
						my_pos.z=my_pos.z+69
					else
						my_pos.z=funcs.ME._veh_crds().z
					end
				end
			end
			my_pos.z=my_pos.z+veh_stuff.info[hash].Z_HEIGHT+1
			if not funcs.doo.tp_ent(g.tbl.PID_INFO.veh[API.plyr.my_id()+1],my_pos, 0 ,false) then
				g.N_P(2,funcs.get.pid_name(API.plyr.my_id()).."  -  "..funcs.get.veh_model_name(g.tbl.PID_INFO.veh[API.plyr.my_id()+1]).."\nFailed to get control of vehicle :(",__GV__,4,"Red")
			end
		else
			API.ent.set.coords(API.plyr.get.ped(API.plyr.my_id()),my_pos)
		end
	else
		g.N_P(2,"No TP location found :(",__GV__,4,"Red")
	end
end)

g.tbl.tp_time_hist = {}
g.tbl.tp_time_hist.history = {}
--g.tbl.tp_time_hist.slot = 1



g.tbl.tp_time_hist.record_feat=menu_add_feature("TP back in time record hidden", "toggle", g.prnt.self_teleport.id, function(f)
	local my_pos=API.plyr.get.coords(API.plyr.my_id())
	local continue,count,dist
	g.tbl.tp_time_hist.history[1] = my_pos
	local function in_my_grid(old_pos,new_pos,_max)
		if mth.abs(new_pos.x - old_pos.x) > _max or mth.abs(new_pos.y - old_pos.y) > _max or mth.abs(new_pos.z - old_pos.z) > _max then
			return false
		end
		return true
	end
	while f.on do
		YIELD(500)
		dist = 10
		if g.tbl.PID_INFO.interior[API.plyr.my_id()+1] then
			dist = 2
		end
		if not in_my_grid(my_pos,API.plyr.get.coords(API.plyr.my_id()),dist) then
			count = 0
			continue = true
			for i=0,#g.tbl.tp_time_hist.history do
				if count > 5 then
					break
				else
					count = count + 1
					if g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history-i] ~= nil and in_my_grid(g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history-i],API.plyr.get.coords(API.plyr.my_id()),dist) then
						continue = false
						break
					end
				end
			end
			my_pos = API.plyr.get.coords(API.plyr.my_id())
			if continue then
				g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history+1] = my_pos
			end
		end
	end
end)
g.tbl.tp_time_hist.record_feat.on = true
g.tbl.tp_time_hist.record_feat.hidden = true

g.tbl.tp_time_hist.back_feat=menu_add_feature("TP back in time", "action", g.prnt.self_teleport.id, function()
	if g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history-1] ~= nil then
		if funcs.ME._in_veh() then
			if not funcs.doo.tp_ent(g.tbl.PID_INFO.veh[API.plyr.my_id()+1],g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history-1], 0 ,false) then
				g.N_P(2,funcs.get.veh_ped_name_in_seat(g.tbl.PID_INFO.veh[API.plyr.my_id()+1],"first_plyr").."  -  "..funcs.get.veh_model_name(g.tbl.PID_INFO.veh[API.plyr.my_id()+1]).."\nFailed to get control of vehicle :(",__GV__,4,"Red")
			else
				table.remove(g.tbl.tp_time_hist.history,#g.tbl.tp_time_hist.history)
			end
		else
			API.ent.set.coords(API.plyr.get.ped(API.plyr.my_id()),g.tbl.tp_time_hist.history[#g.tbl.tp_time_hist.history-1])
			table.remove(g.tbl.tp_time_hist.history,#g.tbl.tp_time_hist.history)
		end
	end
end)

g.feat.cam_aim_tp=menu_add_feature("Camera aim TP (No clip)", "action_value_i", g.prnt.self_teleport.id, function(f)
	local pos = funcs.get.my_cam_ray_pos(f.value)
	if funcs.ME._in_veh() then
		if not funcs.doo.tp_ent(funcs.ME._veh(),pos, 0 ,false) then
			g.N_P(2,funcs.get.veh_ped_name_in_seat(funcs.ME._veh(),"first_plyr").."  -  "..funcs.get.veh_model_name(funcs.ME._veh()).."\nFailed to get control of vehicle :(",__GV__,4,"Red")
		end
	else
		API.ent.set.coords(API.plyr.get.ped(API.plyr.my_id()),pos)
	end
end)
funcs.set_feat_i_f(g.feat.cam_aim_tp,5,500,5,100,"g.feat.cam_aim_tp")

g.feat.cam_aim_tp_v2=menu_add_feature("Camera aim TP (With clip)", "action_value_i", g.prnt.self_teleport.id, function(f)
	local pos = funcs.get.ray_vctr_or_max(f.value,nil,funcs.get.my_cam_ray_pos())
	if funcs.ME._in_veh() then
		if not funcs.doo.tp_ent(funcs.ME._veh(),pos, 0 ,false) then
			g.N_P(2,funcs.get.veh_ped_name_in_seat(funcs.ME._veh(),"first_plyr").."  -  "..funcs.get.veh_model_name(funcs.ME._veh()).."\nFailed to get control of vehicle :(",__GV__,4,"Red")
		end
	else
		API.ent.set.coords(API.plyr.get.ped(API.plyr.my_id()),pos)
	end
end)
funcs.set_feat_i_f(g.feat.cam_aim_tp_v2,5,500,5,100,"g.feat.cam_aim_tp_v2")

g.feat.tp_self_to_wp=menu_add_feature("Waypoint/objective", "action", g.prnt.self_teleport.id, function(f)
	local wp = funcs.get.waypoint() or funcs.get.OBJ_coords3()
	if wp then
		if funcs.ME._in_veh() then
			if g.feat.tp_type.value==0 then
				funcs.doo.wp_obj_tp_type(wp)
			end
			local veh = funcs.ME._veh()
			wp.z=wp.z+funcs.get.veh_tp_height(veh)
			if funcs.ntwrk.ask_long(veh,1500) then
				API.ent.set.coords(veh,wp)
			else
				g.N_P(2,"Teleport\nFAILED to get control of vehicle :(",__GV__,4,"Red")
			end
		else
			API.ent.set.coords(funcs.ME._ped(),wp)
		end
	else
		g.N_P(2,"No waypoint/objective.",__GV__,4,"Yellow")
	end
end)

function funcs.get.num_shift(from,to,mult)
	if to > from then
		return from + mth.abs(to-from)*0.01*mult
	end
	return from - mth.abs(from-to)*0.01*mult
end


function funcs.doo.v3_shift(from,to,mult)
	from.x = funcs.get.num_shift(from.x,to.x,mult)
	from.y = funcs.get.num_shift(from.y,to.y,mult)
	from.z = funcs.get.num_shift(from.z,to.z,mult)
end

function funcs.get.arc_from_dist(total,current)
	local half = total*0.5
	if current <= half then
		return mth.abs(current/half)
	end
	return mth.abs((current-total)/half)
end

function funcs.doo.warp_tp(wp,ent)
	API.ent.set.collision(ent,false)
	local trgt_crds_do,dist2
	local ent_pos = API.ent.get.coords(ent)
	local vec_to_trgt,dist = funcs.get.vctr_to_pos3(wp,ent_pos,true)
	local rot = API.ent.get.rotation(ent)
	local my_ped = funcs.ME._ped()
	while funcs.is.ent(ent) and (ent == my_ped or funcs.ME._driving(ent)) and not funcs.is.in_grid_xy(ent_pos,wp,10) do
		API.ent.set.max_speed(ent,45000)
		ent_pos = API.ent.get.coords(ent)
		dist2 = funcs.get.dist_pospos_v3(wp,ent_pos)
		trgt_crds_do = g.tbl.a_b.get_movement(wp,ent_pos,15)
		trgt_crds_do.z = trgt_crds_do.z + funcs.get.arc_from_dist(dist,dist2)*100
		API.ent.set.velocity(ent,trgt_crds_do)
		funcs.doo.v3_shift(rot,vec_to_trgt,1)
		API.ent.set.rotation(ent,rot)
		YIELD(0)
	end
	while funcs.is.ent(ent) and (ent == my_ped or funcs.ME._driving(ent)) and not funcs.is.in_grid_xy(ent_pos,wp,1) do
		ent_pos = API.ent.get.coords(ent)
		trgt_crds_do = g.tbl.a_b.get_movement(wp,ent_pos,1)
		API.ent.set.velocity(ent,trgt_crds_do)
		funcs.doo.v3_shift(rot,vec_to_trgt,1)
		API.ent.set.rotation(ent,rot)
		YIELD(0)
	end
	if funcs.is.ent(ent) then
		API.ent.set.velocity(ent,funcs.vec(0,0,0))
		API.ent.set.collision(ent,true)
		if funcs.is.veh(ent) then
			API.veh.set.on_ground(ent)
		end
	end
end

g.feat.tp_self_to_wp_warp=menu_add_feature("Warp to waypoint/objective", "action", g.prnt.self_teleport.id, function(f)
	local wp = funcs.get.waypoint() or funcs.get.OBJ_coords3()
	if wp then
		if funcs.ME._driving(funcs.ME._veh()) then
			if g.feat.tp_type.value==0 then
				funcs.doo.wp_obj_tp_type(wp)
			end
			local veh = funcs.ME._veh()
			wp.z=wp.z+funcs.get.veh_tp_height(veh)
			funcs.doo.warp_tp(wp,veh)
		elseif not funcs.ME._in_veh() then
			funcs.doo.warp_tp(wp,funcs.ME._ped())
		else
			g.N_P(2,"Warp won't work as a passenger.",__GV__,4,"Yellow")
		end
	else
		g.N_P(2,"No waypoint/objective.",__GV__,4,"Yellow")
	end
end)



g.tbl.mouse_inputs={
		257,
		329,
		1,
		346,
		106,
		2,
		24,
		92,
		69,
		142,
		176,
}

function funcs.doo.no_left_click()
	ntv.doo.disable_firing()
	for k,v in pairs(g.tbl.mouse_inputs) do
		controls.disable_control_action(0, v, true)
	end
end

--funcs.get.ent_blip_image(API.plyr.get.ped(_pid))


function funcs.get.ent_blip_image_and_rot(ent)
	local blip = ui.get_blip_from_entity(ent)
	local blip_sprite_id = ntv.get.blip_sprite(blip)
	return g.tbl.blip_image[blip_sprite_id],ntv.get.blip_rot(blip),blip_sprite_id,blip
end

g.tbl.blip_image = {
[225] = "Sedans",
[227] = "Sedans",
[326] = "Sedans",
[421] = API.get_hash_key("rhino"),
[422] = "Helicopters",
[423] = "Planes",
[424] = API.get_hash_key("hydra"),
[426] = API.get_hash_key("insurgent3"),
[427] = "Boats",
[523] = "Sports",
[528] = API.get_hash_key("phantom2"),
[529] = API.get_hash_key("boxville5"),
[530] = API.get_hash_key("ruiner2"),
[531] = API.get_hash_key("dune4"),
[532] = API.get_hash_key("wastelander"),
[533] = API.get_hash_key("voltic2"),
[534] = API.get_hash_key("technical2"),
[558] = API.get_hash_key("apc"),
[559] = API.get_hash_key("oppressor"),
[560] = API.get_hash_key("halftrack"),
[561] = API.get_hash_key("dune3"),
[562] = API.get_hash_key("tampa3"),
[572] = API.get_hash_key("alphaz1"),
[573] = API.get_hash_key("bombushka"),
[574] = API.get_hash_key("havok"),
[575] = API.get_hash_key("howard"),
[576] = API.get_hash_key("hunter"),
[577] = API.get_hash_key("microlight"),
[578] = API.get_hash_key("mogul"),
[579] = API.get_hash_key("molotok"),
[580] = API.get_hash_key("nokota"),
[581] = API.get_hash_key("pyro"),
[582] = API.get_hash_key("rogue"),
[583] = API.get_hash_key("starling"),
[584] = API.get_hash_key("seabreeze"),
[585] = API.get_hash_key("tula"),
[589] = API.get_hash_key("avenger"),
[595] = API.get_hash_key("stromberg"),
[596] = API.get_hash_key("deluxo"),
[597] = API.get_hash_key("thruster"),
[598] = API.get_hash_key("khanjali"),
[599] = API.get_hash_key("rcv"),
[600] = API.get_hash_key("volatol"),
[601] = API.get_hash_key("barrage"),
[602] = API.get_hash_key("akula"),
[603] = API.get_hash_key("chernobog"),
[612] = API.get_hash_key("seasparrow"),
[613] = API.get_hash_key("caracara2"),
[631] = API.get_hash_key("pbus2"),--festivalbus
[633] = API.get_hash_key("menacer"),
[634] = API.get_hash_key("scramjet"),
[635] = API.get_hash_key("pounder2"),
[636] = API.get_hash_key("mule4"),
[637] = API.get_hash_key("speedo4"),
[638] = API.get_hash_key("blimp"),
[639] = API.get_hash_key("oppressor2"),
[640] = API.get_hash_key("strikeforce"),
[658] = API.get_hash_key("bruiser"),
[659] = API.get_hash_key("brutus"),
[660] = API.get_hash_key("cerberus"),
[661] = API.get_hash_key("deathbike"),
[662] = API.get_hash_key("dominator"),
[663] = API.get_hash_key("impaler2"),
[664] = API.get_hash_key("imperator"),
[665] = API.get_hash_key("issi4"),
[666] = API.get_hash_key("monster3"),
[667] = API.get_hash_key("scarab"),
[668] = API.get_hash_key("slamvan4"),
[669] = API.get_hash_key("zr380"),
[734] = API.get_hash_key("everon"),
[735] = API.get_hash_key("outlaw"),
[736] = API.get_hash_key("vagrant"),
[737] = API.get_hash_key("zhaba"),
[745] = API.get_hash_key("winky"),
[746] = API.get_hash_key("avisa"),
[747] = API.get_hash_key("veto"),
[748] = API.get_hash_key("veto2"),
[749] = API.get_hash_key("blazer"),
[750] = API.get_hash_key("vetir"),
[753] = API.get_hash_key("seasparrow2"),
[756] = API.get_hash_key("toreador"),
[757] = API.get_hash_key("squaddie"),
[758] = API.get_hash_key("alkonost"),
[759] = API.get_hash_key("valkyrie2"),
[760] = API.get_hash_key("kosatka"),
[799] = API.get_hash_key("slamvan"),
[800] = API.get_hash_key("crusader"),
[818] = API.get_hash_key("patriot3"),
[820] = API.get_hash_key("jubilee"),
[821] = API.get_hash_key("granger2"),
[823] = API.get_hash_key("deity"),
[824] = API.get_hash_key("champion"),
[825] = API.get_hash_key("buffalo4"),

}



function funcs.doo.draw_map_pids(i,cursor_raw,posXoffset,posYoffset,mathX,mathY,mult,full_color)
	local pos
	local PED = API.plyr.get.ped(i)
	local pid_color = funcs.get.rgba_from_pid(i) or full_color
	if g.tbl.PID_INFO.interior[i+1] then
		local blip_image,blip_rot,blip_sprite_id,this_blip = funcs.get.ent_blip_image_and_rot(PED)
		if g.tbl.map_blips[blip_sprite_id] then
			pos = funcs.get.map_tp_screen_pos(API.plyr.get.coords(i),posXoffset,posYoffset,mathX,mathY,mult)
			API.SD.draw_sprt(g.tbl.map_blips[blip_sprite_id], funcs.get.map_tp_screen_pos(ntv.get.blip_coords(this_blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, 0, pid_color)
		end
	else
		pos = funcs.get.map_tp_screen_pos(API.plyr.get.coords(i),posXoffset,posYoffset,mathX,mathY,mult)
		local veh = API.plyr.get.veh(i)
		local hash = API.ent.get.model_hash(veh)
		local class = API.veh.get.class_name(veh)
		local blip_image,blip_rot,blip_sprite_id = funcs.get.ent_blip_image_and_rot(PED)
		local has_bounty = glbls.is_pid_bounty(i)
		if API.ent.is.dead(PED) and g.tbl.PID_INFO.undead_blip[i+1]==-1 then
			API.SD.draw_sprt(g.feat.map_type.value == 0 and g.var.map_dead or g.var.map_dead_w, pos,1.25*g.RES_H, 0, full_color)
		elseif g.var.psv_bnty_do and (has_bounty or glbls.is_pid_passive(i)) then
			API.SD.draw_sprt(has_bounty and g.var.map_bounty or g.var.map_passive, pos,has_bounty and 1*g.RES_H or 1.25*g.RES_H, 0, has_bounty and funcs.get.rgba_to_int(224, 50, 50, 255) or full_color)
		elseif g.tbl.PID_INFO.pause[i+1] then
			API.SD.draw_sprt(g.var.map_paused, pos,1.25*g.RES_H, 0, pid_color)
		else
			if API.plyr.is.friend(i) then
				API.SD.draw_sprt(g.var.map_semicircle,pos,0.15*g.RES_H,mth.pi,funcs.get.rgba_to_int(93,182,229,255))
			end
			if glbls.is_pid_otr(i) then
				API.SD.draw_sprt(g.var.map_semicircle,pos,0.15*g.RES_H,0,funcs.get.rgba_to_int(114,204,114,255))
			end
			if API.plyr.is.in_veh(i) and (g.tbl.veh_esp.png_true[hash] or g.tbl.veh_esp.png_true[class]) then
				if g.tbl.veh_esp.png_true[hash] then
					if hash == 788747387 or hash == 4212341271 then --buzzard|savage
						API.SD.draw_sprt(g.tbl.veh_esp.png_int[hash], pos,1.15*g.RES_H, g.var.helo_rot, pid_color)
					else
						API.SD.draw_sprt(g.tbl.veh_esp.png_int[hash], pos,1.15*g.RES_H, g.tbl.veh_esp.png_rot_true[hash] and mth.rad(API.ent.get.heading(veh))*-1 or 0, pid_color)
					end
				elseif class == "Helicopters" then
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[class], pos,1.15*g.RES_H, g.var.helo_rot, pid_color)
				else
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[class], pos,1.15*g.RES_H, g.tbl.veh_esp.png_rot_true[class] and mth.rad(API.ent.get.heading(veh))*-1 or 0, pid_color)
				end
			elseif blip_image and g.tbl.veh_esp.png_true[blip_image] then
				if blip_image == "Helicopters" then
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[blip_image], pos,1.15*g.RES_H, g.var.helo_rot, pid_color)
				elseif g.tbl.veh_esp.png_rot_true[blip_image] then
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[blip_image], pos,1.15*g.RES_H, mth.rad(blip_rot)*-1, pid_color)
				else
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[blip_image], pos,1.15*g.RES_H, 0, pid_color)
				end
			else
				API.SD.draw_sprt(g.feat.map_type.value == 0 and g.tbl.plyr_blips[g.tbl.PID_INFO.color[i+1]] or g.tbl.plyr_blips_w[g.tbl.PID_INFO.color[i+1]] or g.feat.map_type.value == 0 and g.tbl.plyr_blips[-1] or g.tbl.plyr_blips_w[-1], pos,0.15*g.RES_H, mth.rad(API.plyr.get.heading(i))*-1, full_color)
				if blip_sprite_id == 364 then
					API.SD.draw_sprt(g.var.map_dead, pos,0.9*g.RES_H, 0, full_color)
				end
			end
		end
	end
	if pos and funcs.is.in_grid_ratio_square(cursor_raw,pos,g.feat.map_names.value*0.1) then
		API.SD.draw_text(
		funcs.get.pid_name(i),
		funcs.vec(pos.x+(0.01*(g.RES_H+(1-g.RES_H))),pos.y*2),
		funcs.vec(pos.x+(0.01*(g.RES_H+(1-g.RES_H))),pos.y*2),0.69*g.RES_H,
		pid_color,(1 << 1)+(1<<2),nil)

	end
	return pos
end

function funcs.doo.map_wp_obj(wp_obj,sprite,posXoffset,posYoffset,mathX,mathY,mult,size,color)
	if wp_obj.x ~=0 and wp_obj.y ~=0 then
		local pos = funcs.get.map_tp_screen_pos(wp_obj,posXoffset,posYoffset,mathX,mathY,mult)
		API.SD.draw_sprt(sprite, pos,size*g.RES_H, 0, color)
	end
end

g.var.helo_rot = 0
g.var.rand_pid_time = TIME_MS()
g.var.rand_pid_do = false
g.var.psv_bnty_time = TIME_MS()
g.var.psv_bnty_do = false
g.tbl.map_active={}

function funcs.get.map_tp_screen_pos(pos,posXoffset,posYoffset,mathX,mathY,mult)
	pos = v2(
	(pos.x-posXoffset)/mathX/g.RES_RATIO*mult,
	(pos.y-posYoffset)/mathY*mult
	)
	pos.x = pos.x < -1 and -0.99 or pos.x
	pos.x = pos.x > 1 and 0.99 or pos.x
	pos.y = pos.y < -1 and -0.99 or pos.y
	pos.y = pos.y > 1 and 0.99 or pos.y
	return pos
end

function funcs.get.map_blip_color(k,blip,me)
	local blip_hud_color = ntv.get.blip_hud_color(blip)
	if g.tbl.map_blips_use_hud_color[k] then
		return g.tbl.hud_colors[blip_hud_color].color
	elseif blip_hud_color == 0 then
		return funcs.get.rgba_from_pid(me)
	end
	return g.tbl.hud_colors[blip_hud_color].color
end

function funcs.doo.map_and_mouse(cursor_raw,cursor_pos,color,full_color,mathX,mathY,posXoffset,posYoffset,rawXoffset,rawYoffset,mult,cayo,time)
	if g.var.helo_rot >= mth.pi*2 then g.var.helo_rot = 0 else g.var.helo_rot = g.var.helo_rot + .05 end
	mult = mult == 1 and 1 or g.feat.map_zoom.value
	cursor_raw.x = controls.get_control_normal(0, 239)*2-1
	cursor_raw.y = controls.get_control_normal(0, 240)*2*-1+1
	cursor_pos.x = cursor_raw.x/mult*mathX*g.RES_RATIO+posXoffset
	cursor_pos.y = cursor_raw.y/mult*mathY+posYoffset
	local plyrs={}
	local me = funcs.ME._id()

	--draw map image
	if cayo then
		API.SD.draw_sprt(g.feat.map_type.value == 0 and g.var.map_color_cayo or g.var.map_dark_cayo,
		funcs.vec(0-rawXoffset*mult,									0-rawYoffset*mult),
		0.1179999*mult*g.RES_H, 0, color)
	else
		API.SD.draw_sprt(g.feat.map_type.value == 0 and g.var.map_color_combo or g.var.map_dark_combo,
		funcs.vec(0-rawXoffset*mult,									0-rawYoffset*mult),
		0.3*mult*g.RES_H, 0, color)
	end

	--timer pid display order
	if g.var.rand_pid_time < TIME_MS() then
		g.var.rand_pid_time = TIME_MS() +1000
		g.var.rand_pid_do = not g.var.rand_pid_do
	end

	--timer alternate player blips
	if g.var.psv_bnty_time < TIME_MS() then
		g.var.psv_bnty_time = TIME_MS() +750
		g.var.psv_bnty_do = not g.var.psv_bnty_do
	end

	--most non player blips
	local blip,blip_hud_color
	if not g.feat.map_only_players.on then
		for k,v in pairs(g.tbl.map_blips) do
			blip = ntv.get.first_blip_infoid(k)
			while blip do
				API.SD.draw_sprt(g.tbl.map_blips[k], funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, mth.rad(ntv.get.blip_rot(blip))*-1,funcs.get.map_blip_color(k,blip,me))
				blip = ntv.get.next_blip_infoid(k)
			end
		end
	end

	--all kosatka blips
	blip = ntv.get.first_blip_infoid(760)--kosatka
	while blip do
		API.SD.draw_sprt(g.var.map_sub2, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, mth.rad(ntv.get.blip_rot(blip))*-1,g.tbl.hud_colors[ntv.get.blip_hud_color(blip)].color)
		blip = ntv.get.next_blip_infoid(760)
	end

	--all ai blips
	blip = ntv.get.first_blip_infoid(270)--ai
	while blip do
		API.SD.draw_sprt(g.var.map_ai, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, 0,g.tbl.hud_colors[ntv.get.blip_hud_color(blip)].color)
		blip = ntv.get.next_blip_infoid(270)
	end

	--all non white rotating helo blips
	blip = ntv.get.first_blip_infoid(422)--helo
	while blip do
		blip_hud_color = ntv.get.blip_hud_color(blip)
		if blip_hud_color > 1 then
			API.SD.draw_sprt(g.var.map_player_heli, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, g.var.helo_rot,g.tbl.hud_colors[blip_hud_color].color)
		end
		blip = ntv.get.next_blip_infoid(422)
	end

	--all non white jet blips
	blip = ntv.get.first_blip_infoid(16)--jet
	while blip do
		blip_hud_color = ntv.get.blip_hud_color(blip)
		if blip_hud_color > 1 then
			API.SD.draw_sprt(g.var.map_police_plane_move, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H,  mth.rad(ntv.get.blip_rot(blip))*-1,g.tbl.hud_colors[blip_hud_color].color)
		end
		blip = ntv.get.next_blip_infoid(16)
	end
	blip = ntv.get.first_blip_infoid(424)--jet
	while blip do
		blip_hud_color = ntv.get.blip_hud_color(blip)
		if blip_hud_color > 1 then
			API.SD.draw_sprt(g.var.map_player_jet, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H,  mth.rad(ntv.get.blip_rot(blip))*-1,g.tbl.hud_colors[blip_hud_color].color)
		end
		blip = ntv.get.next_blip_infoid(424)
	end

	--all mission blue vehicle blips
	for k,v in pairs(g.tbl.blip_image) do
		blip = ntv.get.first_blip_infoid(k)
		while blip do
			blip_hud_color = ntv.get.blip_hud_color(blip)
			if (blip_hud_color == 11 or blip_hud_color == 9) and g.tbl.veh_esp.png_true[v] then
				if v == "Helicopters" then
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[v], funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, g.var.helo_rot, g.tbl.hud_colors[blip_hud_color].color)
				elseif g.tbl.veh_esp.png_rot_true[v] then
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[v], funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, mth.rad(ntv.get.blip_rot(blip))*-1, g.tbl.hud_colors[blip_hud_color].color)
				else
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[v], funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H, 0, g.tbl.hud_colors[blip_hud_color].color)
				end
			end
			blip = ntv.get.next_blip_infoid(k)
		end
	end

	--all mission blue static helo blips
	blip = ntv.get.first_blip_infoid(64)--heli popo
	while blip do
		blip_hud_color = ntv.get.blip_hud_color(blip)
		if blip_hud_color == 11 or blip_hud_color == 9 then
			API.SD.draw_sprt(g.var.map_police_heli, funcs.get.map_tp_screen_pos(ntv.get.blip_coords(blip),posXoffset,posYoffset,mathX,mathY,mult),1*g.RES_H,  0,g.tbl.hud_colors[blip_hud_color].color)
		end
		blip = ntv.get.next_blip_infoid(64)
	end



	--all vehicle blips with my hash as the decorator (not regular personal vehicles)
	local all_veh =  API.veh.get.all()
	local boss_hash = funcs.get.pid_boss_hash(me) or funcs.ME._net_hash()
	for  k,v in pairs(all_veh) do
		local hash = API.ent.get.model_hash(v)
		if g.tbl.veh_esp.png_int[hash] then
			local sub_pos=API.ent.get.coords(v)
			if sub_pos.z >-51 then
				if decorator.decor_get_int(v, "Player_Submarine") == boss_hash or
					decorator.decor_get_int(v, "Player_Avenger")  == boss_hash or--2176659152
					decorator.decor_get_int(v, "Player_Truck")  == boss_hash or --1502869817
					decorator.decor_get_int(v, "Player_Hacker_Truck")  == boss_hash or
					decorator.decor_get_int(v, "Company_SUV") == boss_hash  or
					decorator.decor_get_int(v, "Player_Moon_Pool") == boss_hash  or
					decorator.decor_get_int(v, "Player_Acid_Lab")  == boss_hash then
					sub_pos = funcs.get.map_tp_screen_pos(sub_pos,posXoffset,posYoffset,mathX,mathY,mult)
					API.SD.draw_sprt(g.tbl.veh_esp.png_int[hash], sub_pos,1.15*g.RES_H, g.tbl.veh_esp.png_rot_true[hash] and mth.rad(API.ent.get.heading(v))*-1 or  0, funcs.get.rgba_from_pid(me))
				end
			end
		end
	end
	if g.var.rand_pid_do then

		funcs.doo.map_wp_obj(g.var.obj_low,g.tbl.RADAR.objective,posXoffset,posYoffset,mathX,mathY,mult,1,funcs.get.rgba_to_int(240, 200, 80, 255))
		funcs.doo.map_wp_obj(g.var.wp_low,g.tbl.RADAR.waypoint,posXoffset,posYoffset,mathX,mathY,mult,1.5,funcs.get.rgba_to_int(164, 76, 242,255))
		for i =31,0,-1 do
			if API.plyr.is.valid(i) then
				local pos=funcs.doo.draw_map_pids(i,cursor_raw,posXoffset,posYoffset,mathX,mathY,mult,full_color)
				if pos and funcs.is.in_grid_ratio_square(cursor_raw,pos,0.025) then
					plyrs[#plyrs+1]={DIST=funcs.get.dist_pospos_v2(cursor_raw,pos),PID=i,VEH=API.plyr.is.in_veh(i) and API.plyr.get.veh(i) or false}
				end
			end
		end
	else
		for i =0,31 do
			if API.plyr.is.valid(i) then
				local pos=funcs.doo.draw_map_pids(i,cursor_raw,posXoffset,posYoffset,mathX,mathY,mult,full_color)
				if pos and funcs.is.in_grid_ratio_square(cursor_raw,pos,0.025) then
					plyrs[#plyrs+1]={DIST=funcs.get.dist_pospos_v2(cursor_raw,pos),PID=i,VEH=API.plyr.is.in_veh(i) and API.plyr.get.veh(i) or false}
				end
			end
		end
		funcs.doo.map_wp_obj(g.var.obj_low,g.tbl.RADAR.objective,posXoffset,posYoffset,mathX,mathY,mult,1,funcs.get.rgba_to_int(240, 200, 80, 255))
		funcs.doo.map_wp_obj(g.var.wp_low,g.tbl.RADAR.waypoint,posXoffset,posYoffset,mathX,mathY,mult,1.5,funcs.get.rgba_to_int(164, 76, 242,255))
	end
	local closest
	local text = "Coords: "..(mth.flr(cursor_pos.x/5)*5)..","..(mth.flr(cursor_pos.y/5)*5).." | 0:"..(g.feat.map_only_players.on and "Only players" or "All blips").." | 1:Set waypoint | 2:Orbital"
	if #plyrs>0 then
		table.sort(plyrs, function(a, b) return a.DIST < b.DIST end)
		closest = plyrs[1]
	end
	if closest then
		if closest.VEH and closest.VEH ~= funcs.ME._veh() and closest.PID ~= API.plyr.my_id() then
			text = text.." | 3:TP "
			if API.plyr.is.god(closest.PID) then
				text = text.."#FF0000FF#[G]#DEFAULT# "
			end
			if API.ent.get.god(closest.VEH) then
				text = text.."#FF0000FF#[VG]#DEFAULT# "
			end
			text = text..funcs.get.pid_name(closest.PID).." to me"
		else
			text = text.." | "
			if API.plyr.is.god(closest.PID) then
				text = text.."#FF0000FF#[G]#DEFAULT# "
			end
			text = text..funcs.get.pid_name(closest.PID)
		end
	end
	API.SD.draw_rect(funcs.vec(0,-0.9),funcs.vec(0.51,0.06), funcs.get.rgba_to_int(0,0,0,100))
	API.SD.draw_text(
			text,
			funcs.vec(0,-0.9*2),
			funcs.vec(0,-0.9*2),
			0.8*g.RES_H,
			full_color,
			(1<<0)+(1 << 1)+(1<<2),
			nil)
	API.SD.draw_sprt(g.var.map_cursor,cursor_raw,0.5*g.RES_H, 0, full_color)
	funcs.doo.no_left_click()
	ntv.doo.hide_weapon_wheel_from_mouse()


	if funcs.is.vk_key_down("0") and not g.tbl.map_active["filter"] then
		g.feat.map_only_players.on=(not g.feat.map_only_players.on)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			g.tbl.map_active["filter"]=true
			while funcs.is.vk_key_down("0") do
				YIELD(0)
			end
			g.tbl.map_active["filter"]=false
		end)
	elseif funcs.is.vk_key_down("1") and not g.tbl.map_active["waypoint"] then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			g.tbl.map_active["waypoint"]=true
			ui.set_waypoint_off()
			YIELD(0)
			ui.set_new_waypoint(funcs.vec(cursor_pos.x,cursor_pos.y))
			while funcs.is.vk_key_down("1") do
				YIELD(0)
			end
			g.tbl.map_active["waypoint"]=false
		end)
	elseif funcs.is.vk_key_down("2") and not g.tbl.map_active["orbital"] then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			g.tbl.map_active["orbital"]=true
			local pid,veh
			if closest then
				pid = closest.PID and closest.PID or nil
				veh = closest.VEH  and closest.VEH or nil
			end
			local pos = v3(cursor_pos.x,cursor_pos.y,0)
			if veh then
				pos = API.ent.get.coords(veh)
			elseif pid then
				local plyr_pos = API.plyr.get.coords(pid)
				if plyr_pos.z >-49 then
					pos = plyr_pos
				end
			end
			if pos.z == 0 then
				funcs.get.ground_z(pos,false)
			end
			funcs.doo.orb_explo_ptfx_n_audio(pos,pid and API.plyr.get.ped(pid) or funcs.ME._ped())
			local time = TIME_MS() + 100
			while time > TIME_MS() and funcs.is.vk_key_down("2") do
				YIELD(0)
			end
			g.tbl.map_active["orbital"]=false
		end)
	elseif funcs.is.vk_key_down("3") and closest and closest.VEH and closest.PID ~= me and not g.tbl.map_active[closest.VEH] then
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local veh,pid = closest.VEH,closest.PID
			g.tbl.map_active[veh]=true
			if funcs.ntwrk.ask_long(veh,1500) then
				local pos = funcs.get.front_of_dir(funcs.ME._veh_or_me_crds(),funcs.ME._veh_or_me_rot(),funcs.get.spawn_front_dist(pid,funcs.ME._veh()))
				pos.z=pos.z+funcs.get.veh_tp_height(veh)+1
				API.ent.set.coords(veh,pos)
			else
				g.N_P(2,"Teleport\nFAILED to get control of vehicle :(",__GV__,4,"Red")
			end
			g.tbl.map_active[veh]=false
		end)
	end
	if time > TIME_MS() and not g.tbl.PID_INFO.interior[me+1] then
		local pos = funcs.get.map_tp_screen_pos(API.plyr.get.coords(me),posXoffset,posYoffset,mathX,mathY,mult)
		local percent = (time - TIME_MS())/3000
		API.SD.draw_line(funcs.vec(-1,pos.y),funcs.vec(1,pos.y), 1, g.feat.map_type.value == 0 and funcs.get.rgba_to_int(0,0,0,mth.flr(255*percent)) or funcs.get.rgba_to_int(255,255,255,mth.flr(255*percent)))
		API.SD.draw_line(funcs.vec(pos.x,-1),funcs.vec(pos.x,1), 1, g.feat.map_type.value == 0 and funcs.get.rgba_to_int(0,0,0,mth.flr(255*percent)) or funcs.get.rgba_to_int(255,255,255,mth.flr(255*percent)))
	end
end


g.tbl.map_blips_use_hud_color = {
	[777] = true,
	[679] = true,
	[40] = true,
	[556] = true,
	[417] = true,
	[418] = true,
	[478] = true,
	[501] = true,
	[84] = true,
	[429] = true,
	[630] = true,
	[436] = true,
	[442] = true,
	[307] = true,
	[523] = true,
	[568] = true,
	[643] = true,
	[432] = true,
	[433] = true,
	[272] = true,
	[469] = true,
	[514] = true,
	[618] = true,
	[627] = true,
	[586] = true,
	[765] = true,
	[780] = true,
	[784] = true,
	[768] = true,
	[794] = true,
}

g.tbl.hud_colors = {
[0] = {name = "HUD_COLOUR_PURE_WHITE", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[1] = {name = "HUD_COLOUR_WHITE", color = funcs.get.rgba_to_int(240, 240, 240, 255)},
[2] = {name = "HUD_COLOUR_BLACK", color = funcs.get.rgba_to_int(0, 0, 0, 255)},
[3] = {name = "HUD_COLOUR_GREY", color = funcs.get.rgba_to_int(155, 155, 155, 255)},
[4] = {name = "HUD_COLOUR_GREYLIGHT", color = funcs.get.rgba_to_int(205, 205, 205, 255)},
[5] = {name = "HUD_COLOUR_GREYDARK", color = funcs.get.rgba_to_int(77, 77, 77, 255)},
[6] = {name = "HUD_COLOUR_RED", color = funcs.get.rgba_to_int(224, 50, 50, 255)},
[7] = {name = "HUD_COLOUR_REDLIGHT", color = funcs.get.rgba_to_int(240, 153, 153, 255)},
[8] = {name = "HUD_COLOUR_REDDARK", color = funcs.get.rgba_to_int(112, 25, 25, 255)},
[9] = {name = "HUD_COLOUR_BLUE", color = funcs.get.rgba_to_int(93, 182, 229, 255)},
[10] = {name = "HUD_COLOUR_BLUELIGHT", color = funcs.get.rgba_to_int(174, 219, 242, 255)},
[11] = {name = "HUD_COLOUR_BLUEDARK", color = funcs.get.rgba_to_int(47, 92, 115, 255)},
[12] = {name = "HUD_COLOUR_YELLOW", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[13] = {name = "HUD_COLOUR_YELLOWLIGHT", color = funcs.get.rgba_to_int(254, 235, 169, 255)},
[14] = {name = "HUD_COLOUR_YELLOWDARK", color = funcs.get.rgba_to_int(126, 107, 41, 255)},
[15] = {name = "HUD_COLOUR_ORANGE", color = funcs.get.rgba_to_int(255, 133, 85, 255)},
[16] = {name = "HUD_COLOUR_ORANGELIGHT", color = funcs.get.rgba_to_int(255, 194, 170, 255)},
[17] = {name = "HUD_COLOUR_ORANGEDARK", color = funcs.get.rgba_to_int(127, 66, 42, 255)},
[18] = {name = "HUD_COLOUR_GREEN", color = funcs.get.rgba_to_int(114, 204, 114, 255)},
[19] = {name = "HUD_COLOUR_GREENLIGHT", color = funcs.get.rgba_to_int(185, 230, 185, 255)},
[20] = {name = "HUD_COLOUR_GREENDARK", color = funcs.get.rgba_to_int(57, 102, 57, 255)},
[21] = {name = "HUD_COLOUR_PURPLE", color = funcs.get.rgba_to_int(132, 102, 226, 255)},
[22] = {name = "HUD_COLOUR_PURPLELIGHT", color = funcs.get.rgba_to_int(192, 179, 239, 255)},
[23] = {name = "HUD_COLOUR_PURPLEDARK", color = funcs.get.rgba_to_int(67, 57, 111, 255)},
[24] = {name = "HUD_COLOUR_PINK", color = funcs.get.rgba_to_int(203, 54, 148, 255)},
[25] = {name = "HUD_COLOUR_RADAR_HEALTH", color = funcs.get.rgba_to_int(53, 154, 71, 255)},
[26] = {name = "HUD_COLOUR_RADAR_ARMOUR", color = funcs.get.rgba_to_int(93, 182, 229, 255)},
[27] = {name = "HUD_COLOUR_RADAR_DAMAGE", color = funcs.get.rgba_to_int(235, 36, 39, 255)},
[28] = {name = "HUD_COLOUR_NET_PLAYER1", color = funcs.get.rgba_to_int(194, 80, 80, 255)},
[29] = {name = "HUD_COLOUR_NET_PLAYER2", color = funcs.get.rgba_to_int(156, 110, 175, 255)},
[30] = {name = "HUD_COLOUR_NET_PLAYER3", color = funcs.get.rgba_to_int(255, 123, 196, 255)},
[31] = {name = "HUD_COLOUR_NET_PLAYER4", color = funcs.get.rgba_to_int(247, 159, 123, 255)},
[32] = {name = "HUD_COLOUR_NET_PLAYER5", color = funcs.get.rgba_to_int(178, 144, 132, 255)},
[33] = {name = "HUD_COLOUR_NET_PLAYER6", color = funcs.get.rgba_to_int(141, 206, 167, 255)},
[34] = {name = "HUD_COLOUR_NET_PLAYER7", color = funcs.get.rgba_to_int(113, 169, 175, 255)},
[35] = {name = "HUD_COLOUR_NET_PLAYER8", color = funcs.get.rgba_to_int(211, 209, 231, 255)},
[36] = {name = "HUD_COLOUR_NET_PLAYER9", color = funcs.get.rgba_to_int(144, 127, 153, 255)},
[37] = {name = "HUD_COLOUR_NET_PLAYER10", color = funcs.get.rgba_to_int(106, 196, 191, 255)},
[38] = {name = "HUD_COLOUR_NET_PLAYER11", color = funcs.get.rgba_to_int(214, 196, 153, 255)},
[39] = {name = "HUD_COLOUR_NET_PLAYER12", color = funcs.get.rgba_to_int(234, 142, 80, 255)},
[40] = {name = "HUD_COLOUR_NET_PLAYER13", color = funcs.get.rgba_to_int(152, 203, 234, 255)},
[41] = {name = "HUD_COLOUR_NET_PLAYER14", color = funcs.get.rgba_to_int(178, 98, 135, 255)},
[42] = {name = "HUD_COLOUR_NET_PLAYER15", color = funcs.get.rgba_to_int(144, 142, 122, 255)},
[43] = {name = "HUD_COLOUR_NET_PLAYER16", color = funcs.get.rgba_to_int(166, 117, 94, 255)},
[44] = {name = "HUD_COLOUR_NET_PLAYER17", color = funcs.get.rgba_to_int(175, 168, 168, 255)},
[45] = {name = "HUD_COLOUR_NET_PLAYER18", color = funcs.get.rgba_to_int(232, 142, 155, 255)},
[46] = {name = "HUD_COLOUR_NET_PLAYER19", color = funcs.get.rgba_to_int(187, 214, 91, 255)},
[47] = {name = "HUD_COLOUR_NET_PLAYER20", color = funcs.get.rgba_to_int(12, 123, 86, 255)},
[48] = {name = "HUD_COLOUR_NET_PLAYER21", color = funcs.get.rgba_to_int(123, 196, 255, 255)},
[49] = {name = "HUD_COLOUR_NET_PLAYER22", color = funcs.get.rgba_to_int(171, 60, 230, 255)},
[50] = {name = "HUD_COLOUR_NET_PLAYER23", color = funcs.get.rgba_to_int(206, 169, 13, 255)},
[51] = {name = "HUD_COLOUR_NET_PLAYER24", color = funcs.get.rgba_to_int(71, 99, 173, 255)},
[52] = {name = "HUD_COLOUR_NET_PLAYER25", color = funcs.get.rgba_to_int(42, 166, 185, 255)},
[53] = {name = "HUD_COLOUR_NET_PLAYER26", color = funcs.get.rgba_to_int(186, 157, 125, 255)},
[54] = {name = "HUD_COLOUR_NET_PLAYER27", color = funcs.get.rgba_to_int(201, 225, 255, 255)},
[55] = {name = "HUD_COLOUR_NET_PLAYER28", color = funcs.get.rgba_to_int(240, 240, 150, 255)},
[56] = {name = "HUD_COLOUR_NET_PLAYER29", color = funcs.get.rgba_to_int(237, 140, 161, 255)},
[57] = {name = "HUD_COLOUR_NET_PLAYER30", color = funcs.get.rgba_to_int(249, 138, 138, 255)},
[58] = {name = "HUD_COLOUR_NET_PLAYER31", color = funcs.get.rgba_to_int(252, 239, 166, 255)},
[59] = {name = "HUD_COLOUR_NET_PLAYER32", color = funcs.get.rgba_to_int(240, 240, 240, 255)},
[60] = {name = "HUD_COLOUR_SIMPLEBLIP_DEFAULT", color = funcs.get.rgba_to_int(159, 201, 166, 255)},
[61] = {name = "HUD_COLOUR_MENU_BLUE", color = funcs.get.rgba_to_int(140, 140, 140, 255)},
[62] = {name = "HUD_COLOUR_MENU_GREY_LIGHT", color = funcs.get.rgba_to_int(140, 140, 140, 255)},
[63] = {name = "HUD_COLOUR_MENU_BLUE_EXTRA_DARK", color = funcs.get.rgba_to_int(40, 40, 40, 255)},
[64] = {name = "HUD_COLOUR_MENU_YELLOW", color = funcs.get.rgba_to_int(240, 160, 0, 255)},
[65] = {name = "HUD_COLOUR_MENU_YELLOW_DARK", color = funcs.get.rgba_to_int(240, 160, 0, 255)},
[66] = {name = "HUD_COLOUR_MENU_GREEN", color = funcs.get.rgba_to_int(240, 160, 0, 255)},
[67] = {name = "HUD_COLOUR_MENU_GREY", color = funcs.get.rgba_to_int(140, 140, 140, 255)},
[68] = {name = "HUD_COLOUR_MENU_GREY_DARK", color = funcs.get.rgba_to_int(60, 60, 60, 255)},
[69] = {name = "HUD_COLOUR_MENU_HIGHLIGHT", color = funcs.get.rgba_to_int(30, 30, 30, 255)},
[70] = {name = "HUD_COLOUR_MENU_STANDARD", color = funcs.get.rgba_to_int(140, 140, 140, 255)},
[71] = {name = "HUD_COLOUR_MENU_DIMMED", color = funcs.get.rgba_to_int(75, 75, 75, 255)},
[72] = {name = "HUD_COLOUR_MENU_EXTRA_DIMMED", color = funcs.get.rgba_to_int(50, 50, 50, 255)},
[73] = {name = "HUD_COLOUR_BRIEF_TITLE", color = funcs.get.rgba_to_int(95, 95, 95, 255)},
[74] = {name = "HUD_COLOUR_MID_GREY_MP", color = funcs.get.rgba_to_int(100, 100, 100, 255)},
[75] = {name = "HUD_COLOUR_NET_PLAYER1_DARK", color = funcs.get.rgba_to_int(93, 39, 39, 255)},
[76] = {name = "HUD_COLOUR_NET_PLAYER2_DARK", color = funcs.get.rgba_to_int(77, 55, 89, 255)},
[77] = {name = "HUD_COLOUR_NET_PLAYER3_DARK", color = funcs.get.rgba_to_int(124, 62, 99, 255)},
[78] = {name = "HUD_COLOUR_NET_PLAYER4_DARK", color = funcs.get.rgba_to_int(120, 80, 80, 255)},
[79] = {name = "HUD_COLOUR_NET_PLAYER5_DARK", color = funcs.get.rgba_to_int(87, 72, 66, 255)},
[80] = {name = "HUD_COLOUR_NET_PLAYER6_DARK", color = funcs.get.rgba_to_int(74, 103, 83, 255)},
[81] = {name = "HUD_COLOUR_NET_PLAYER7_DARK", color = funcs.get.rgba_to_int(60, 85, 88, 255)},
[82] = {name = "HUD_COLOUR_NET_PLAYER8_DARK", color = funcs.get.rgba_to_int(105, 105, 64, 255)},
[83] = {name = "HUD_COLOUR_NET_PLAYER9_DARK", color = funcs.get.rgba_to_int(72, 63, 76, 255)},
[84] = {name = "HUD_COLOUR_NET_PLAYER10_DARK", color = funcs.get.rgba_to_int(53, 98, 95, 255)},
[85] = {name = "HUD_COLOUR_NET_PLAYER11_DARK", color = funcs.get.rgba_to_int(107, 98, 76, 255)},
[86] = {name = "HUD_COLOUR_NET_PLAYER12_DARK", color = funcs.get.rgba_to_int(117, 71, 40, 255)},
[87] = {name = "HUD_COLOUR_NET_PLAYER13_DARK", color = funcs.get.rgba_to_int(76, 101, 117, 255)},
[88] = {name = "HUD_COLOUR_NET_PLAYER14_DARK", color = funcs.get.rgba_to_int(65, 35, 47, 255)},
[89] = {name = "HUD_COLOUR_NET_PLAYER15_DARK", color = funcs.get.rgba_to_int(72, 71, 61, 255)},
[90] = {name = "HUD_COLOUR_NET_PLAYER16_DARK", color = funcs.get.rgba_to_int(85, 58, 47, 255)},
[91] = {name = "HUD_COLOUR_NET_PLAYER17_DARK", color = funcs.get.rgba_to_int(87, 84, 84, 255)},
[92] = {name = "HUD_COLOUR_NET_PLAYER18_DARK", color = funcs.get.rgba_to_int(116, 71, 77, 255)},
[93] = {name = "HUD_COLOUR_NET_PLAYER19_DARK", color = funcs.get.rgba_to_int(93, 107, 45, 255)},
[94] = {name = "HUD_COLOUR_NET_PLAYER20_DARK", color = funcs.get.rgba_to_int(6, 61, 43, 255)},
[95] = {name = "HUD_COLOUR_NET_PLAYER21_DARK", color = funcs.get.rgba_to_int(61, 98, 127, 255)},
[96] = {name = "HUD_COLOUR_NET_PLAYER22_DARK", color = funcs.get.rgba_to_int(85, 30, 115, 255)},
[97] = {name = "HUD_COLOUR_NET_PLAYER23_DARK", color = funcs.get.rgba_to_int(103, 84, 6, 255)},
[98] = {name = "HUD_COLOUR_NET_PLAYER24_DARK", color = funcs.get.rgba_to_int(35, 49, 86, 255)},
[99] = {name = "HUD_COLOUR_NET_PLAYER25_DARK", color = funcs.get.rgba_to_int(21, 83, 92, 255)},
[100] = {name = "HUD_COLOUR_NET_PLAYER26_DARK", color = funcs.get.rgba_to_int(93, 98, 62, 255)},
[101] = {name = "HUD_COLOUR_NET_PLAYER27_DARK", color = funcs.get.rgba_to_int(100, 112, 127, 255)},
[102] = {name = "HUD_COLOUR_NET_PLAYER28_DARK", color = funcs.get.rgba_to_int(120, 120, 75, 255)},
[103] = {name = "HUD_COLOUR_NET_PLAYER29_DARK", color = funcs.get.rgba_to_int(152, 76, 93, 255)},
[104] = {name = "HUD_COLOUR_NET_PLAYER30_DARK", color = funcs.get.rgba_to_int(124, 69, 69, 255)},
[105] = {name = "HUD_COLOUR_NET_PLAYER31_DARK", color = funcs.get.rgba_to_int(10, 43, 50, 255)},
[106] = {name = "HUD_COLOUR_NET_PLAYER32_DARK", color = funcs.get.rgba_to_int(95, 95, 10, 255)},
[107] = {name = "HUD_COLOUR_BRONZE", color = funcs.get.rgba_to_int(180, 130, 97, 255)},
[108] = {name = "HUD_COLOUR_SILVER", color = funcs.get.rgba_to_int(150, 153, 161, 255)},
[109] = {name = "HUD_COLOUR_GOLD", color = funcs.get.rgba_to_int(214, 181, 99, 255)},
[110] = {name = "HUD_COLOUR_PLATINUM", color = funcs.get.rgba_to_int(166, 221, 190, 255)},
[111] = {name = "HUD_COLOUR_GANG1", color = funcs.get.rgba_to_int(29, 100, 153, 255)},
[112] = {name = "HUD_COLOUR_GANG2", color = funcs.get.rgba_to_int(214, 116, 15, 255)},
[113] = {name = "HUD_COLOUR_GANG3", color = funcs.get.rgba_to_int(135, 125, 142, 255)},
[114] = {name = "HUD_COLOUR_GANG4", color = funcs.get.rgba_to_int(229, 119, 185, 255)},
[115] = {name = "HUD_COLOUR_SAME_CREW", color = funcs.get.rgba_to_int(252, 239, 166, 255)},
[116] = {name = "HUD_COLOUR_FREEMODE", color = funcs.get.rgba_to_int(45, 110, 185, 255)},
[117] = {name = "HUD_COLOUR_PAUSE_BG", color = funcs.get.rgba_to_int(0, 0, 0, 186)},
[118] = {name = "HUD_COLOUR_FRIENDLY", color = funcs.get.rgba_to_int(93, 182, 229, 255)},
[119] = {name = "HUD_COLOUR_ENEMY", color = funcs.get.rgba_to_int(194, 80, 80, 255)},
[120] = {name = "HUD_COLOUR_LOCATION", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[121] = {name = "HUD_COLOUR_PICKUP", color = funcs.get.rgba_to_int(114, 204, 114, 255)},
[122] = {name = "HUD_COLOUR_PAUSE_SINGLEPLAYER", color = funcs.get.rgba_to_int(114, 204, 114, 255)},
[123] = {name = "HUD_COLOUR_FREEMODE_DARK", color = funcs.get.rgba_to_int(22, 55, 92, 255)},
[124] = {name = "HUD_COLOUR_INACTIVE_MISSION", color = funcs.get.rgba_to_int(154, 154, 154, 255)},
[125] = {name = "HUD_COLOUR_DAMAGE", color = funcs.get.rgba_to_int(194, 80, 80, 255)},
[126] = {name = "HUD_COLOUR_PINKLIGHT", color = funcs.get.rgba_to_int(252, 115, 201, 255)},
[127] = {name = "HUD_COLOUR_PM_MITEM_HIGHLIGHT", color = funcs.get.rgba_to_int(252, 177, 49, 255)},
[128] = {name = "HUD_COLOUR_SCRIPT_VARIABLE", color = funcs.get.rgba_to_int(0, 0, 0, 255)},
[129] = {name = "HUD_COLOUR_YOGA", color = funcs.get.rgba_to_int(109, 247, 204, 255)},
[130] = {name = "HUD_COLOUR_TENNIS", color = funcs.get.rgba_to_int(241, 101, 34, 255)},
[131] = {name = "HUD_COLOUR_GOLF", color = funcs.get.rgba_to_int(214, 189, 97, 255)},
[132] = {name = "HUD_COLOUR_SHOOTING_RANGE", color = funcs.get.rgba_to_int(112, 25, 25, 255)},
[133] = {name = "HUD_COLOUR_FLIGHT_SCHOOL", color = funcs.get.rgba_to_int(47, 92, 115, 255)},
[134] = {name = "HUD_COLOUR_NORTH_BLUE", color = funcs.get.rgba_to_int(93, 182, 229, 255)},
[135] = {name = "HUD_COLOUR_SOCIAL_CLUB", color = funcs.get.rgba_to_int(234, 153, 28, 255)},
[136] = {name = "HUD_COLOUR_PLATFORM_BLUE", color = funcs.get.rgba_to_int(11, 55, 123, 255)},
[137] = {name = "HUD_COLOUR_PLATFORM_GREEN", color = funcs.get.rgba_to_int(146, 200, 62, 255)},
[138] = {name = "HUD_COLOUR_PLATFORM_GREY", color = funcs.get.rgba_to_int(234, 153, 28, 255)},
[139] = {name = "HUD_COLOUR_FACEBOOK_BLUE", color = funcs.get.rgba_to_int(66, 89, 148, 255)},
[140] = {name = "HUD_COLOUR_INGAME_BG", color = funcs.get.rgba_to_int(0, 0, 0, 186)},
[141] = {name = "HUD_COLOUR_DARTS", color = funcs.get.rgba_to_int(114, 204, 114, 255)},
[142] = {name = "HUD_COLOUR_WAYPOINT", color = funcs.get.rgba_to_int(164, 76, 242, 255)},
[143] = {name = "HUD_COLOUR_MICHAEL", color = funcs.get.rgba_to_int(101, 180, 212, 255)},
[144] = {name = "HUD_COLOUR_FRANKLIN", color = funcs.get.rgba_to_int(171, 237, 171, 255)},
[145] = {name = "HUD_COLOUR_TREVOR", color = funcs.get.rgba_to_int(255, 163, 87, 255)},
[146] = {name = "HUD_COLOUR_GOLF_P1", color = funcs.get.rgba_to_int(240, 240, 240, 255)},
[147] = {name = "HUD_COLOUR_GOLF_P2", color = funcs.get.rgba_to_int(235, 239, 30, 255)},
[148] = {name = "HUD_COLOUR_GOLF_P3", color = funcs.get.rgba_to_int(255, 149, 14, 255)},
[149] = {name = "HUD_COLOUR_GOLF_P4", color = funcs.get.rgba_to_int(246, 60, 161, 255)},
[150] = {name = "HUD_COLOUR_WAYPOINTLIGHT", color = funcs.get.rgba_to_int(210, 166, 249, 255)},
[151] = {name = "HUD_COLOUR_WAYPOINTDARK", color = funcs.get.rgba_to_int(82, 38, 121, 255)},
[152] = {name = "HUD_COLOUR_PANEL_LIGHT", color = funcs.get.rgba_to_int(0, 0, 0, 77)},
[153] = {name = "HUD_COLOUR_MICHAEL_DARK", color = funcs.get.rgba_to_int(72, 103, 116, 255)},
[154] = {name = "HUD_COLOUR_FRANKLIN_DARK", color = funcs.get.rgba_to_int(85, 118, 85, 255)},
[155] = {name = "HUD_COLOUR_TREVOR_DARK", color = funcs.get.rgba_to_int(127, 81, 43, 255)},
[156] = {name = "HUD_COLOUR_OBJECTIVE_ROUTE", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[157] = {name = "HUD_COLOUR_PAUSEMAP_TINT", color = funcs.get.rgba_to_int(0, 0, 0, 215)},
[158] = {name = "HUD_COLOUR_PAUSE_DESELECT", color = funcs.get.rgba_to_int(100, 100, 100, 127)},
[159] = {name = "HUD_COLOUR_PM_WEAPONS_PURCHASABLE", color = funcs.get.rgba_to_int(45, 110, 185, 255)},
[160] = {name = "HUD_COLOUR_PM_WEAPONS_LOCKED", color = funcs.get.rgba_to_int(240, 240, 240, 191)},
[161] = {name = "HUD_COLOUR_END_SCREEN_BG", color = funcs.get.rgba_to_int(0, 0, 0, 186)},
[162] = {name = "HUD_COLOUR_CHOP", color = funcs.get.rgba_to_int(224, 50, 50, 255)},
[163] = {name = "HUD_COLOUR_PAUSEMAP_TINT_HALF", color = funcs.get.rgba_to_int(0, 0, 0, 215)},
[164] = {name = "HUD_COLOUR_NORTH_BLUE_OFFICIAL", color = funcs.get.rgba_to_int(0, 71, 133, 255)},
[165] = {name = "HUD_COLOUR_SCRIPT_VARIABLE_2", color = funcs.get.rgba_to_int(0, 0, 0, 255)},
[166] = {name = "HUD_COLOUR_H", color = funcs.get.rgba_to_int(33, 118, 37, 255)},
[167] = {name = "HUD_COLOUR_HDARK", color = funcs.get.rgba_to_int(37, 102, 40, 255)},
[168] = {name = "HUD_COLOUR_T", color = funcs.get.rgba_to_int(234, 153, 28, 255)},
[169] = {name = "HUD_COLOUR_TDARK", color = funcs.get.rgba_to_int(225, 140, 8, 255)},
[170] = {name = "HUD_COLOUR_HSHARD", color = funcs.get.rgba_to_int(20, 40, 0, 255)},
[171] = {name = "HUD_COLOUR_CONTROLLER_MICHAEL", color = funcs.get.rgba_to_int(48, 255, 255, 255)},
[172] = {name = "HUD_COLOUR_CONTROLLER_FRANKLIN", color = funcs.get.rgba_to_int(48, 255, 0, 255)},
[173] = {name = "HUD_COLOUR_CONTROLLER_TREVOR", color = funcs.get.rgba_to_int(176, 80, 0, 255)},
[174] = {name = "HUD_COLOUR_CONTROLLER_CHOP", color = funcs.get.rgba_to_int(127, 0, 0, 255)},
[175] = {name = "HUD_COLOUR_VIDEO_EDITOR_VIDEO", color = funcs.get.rgba_to_int(53, 166, 224, 255)},
[176] = {name = "HUD_COLOUR_VIDEO_EDITOR_AUDIO", color = funcs.get.rgba_to_int(162, 79, 157, 255)},
[177] = {name = "HUD_COLOUR_VIDEO_EDITOR_TEXT", color = funcs.get.rgba_to_int(104, 192, 141, 255)},
[178] = {name = "HUD_COLOUR_HB_BLUE", color = funcs.get.rgba_to_int(29, 100, 153, 255)},
[179] = {name = "HUD_COLOUR_HB_YELLOW", color = funcs.get.rgba_to_int(234, 153, 28, 255)},
[180] = {name = "HUD_COLOUR_VIDEO_EDITOR_SCORE", color = funcs.get.rgba_to_int(240, 160, 1, 255)},
[181] = {name = "HUD_COLOUR_VIDEO_EDITOR_AUDIO_FADEOUT", color = funcs.get.rgba_to_int(59, 34, 57, 255)},
[182] = {name = "HUD_COLOUR_VIDEO_EDITOR_TEXT_FADEOUT", color = funcs.get.rgba_to_int(41, 68, 53, 255)},
[183] = {name = "HUD_COLOUR_VIDEO_EDITOR_SCORE_FADEOUT", color = funcs.get.rgba_to_int(82, 58, 10, 255)},
[184] = {name = "HUD_COLOUR_HEIST_BACKGROUND", color = funcs.get.rgba_to_int(37, 102, 40, 186)},
[185] = {name = "HUD_COLOUR_VIDEO_EDITOR_AMBIENT", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[186] = {name = "HUD_COLOUR_VIDEO_EDITOR_AMBIENT_FADEOUT", color = funcs.get.rgba_to_int(80, 70, 34, 255)},
[187] = {name = "HUD_COLOUR_VIDEO_EDITOR_AMBIENT_DARK", color = funcs.get.rgba_to_int(255, 133, 85, 255)},
[188] = {name = "HUD_COLOUR_VIDEO_EDITOR_AMBIENT_LIGHT", color = funcs.get.rgba_to_int(255, 194, 170, 255)},
[189] = {name = "HUD_COLOUR_VIDEO_EDITOR_AMBIENT_MID", color = funcs.get.rgba_to_int(255, 133, 85, 255)},
[190] = {name = "HUD_COLOUR_LOW_FLOW", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[191] = {name = "HUD_COLOUR_LOW_FLOW_DARK", color = funcs.get.rgba_to_int(240, 200, 80, 255)},
[192] = {name = "HUD_COLOUR_G1", color = funcs.get.rgba_to_int(247, 159, 123, 255)},
[193] = {name = "HUD_COLOUR_G2", color = funcs.get.rgba_to_int(226, 134, 187, 255)},
[194] = {name = "HUD_COLOUR_G3", color = funcs.get.rgba_to_int(239, 238, 151, 255)},
[195] = {name = "HUD_COLOUR_G4", color = funcs.get.rgba_to_int(113, 169, 175, 255)},
[196] = {name = "HUD_COLOUR_G5", color = funcs.get.rgba_to_int(160, 140, 193, 255)},
[197] = {name = "HUD_COLOUR_G6", color = funcs.get.rgba_to_int(141, 206, 167, 255)},
[198] = {name = "HUD_COLOUR_G7", color = funcs.get.rgba_to_int(181, 214, 234, 255)},
[199] = {name = "HUD_COLOUR_G8", color = funcs.get.rgba_to_int(178, 144, 132, 255)},
[200] = {name = "HUD_COLOUR_G9", color = funcs.get.rgba_to_int(0, 132, 114, 255)},
[201] = {name = "HUD_COLOUR_G10", color = funcs.get.rgba_to_int(216, 85, 117, 255)},
[202] = {name = "HUD_COLOUR_G11", color = funcs.get.rgba_to_int(30, 100, 152, 255)},
[203] = {name = "HUD_COLOUR_G12", color = funcs.get.rgba_to_int(43, 181, 117, 255)},
[204] = {name = "HUD_COLOUR_G13", color = funcs.get.rgba_to_int(233, 141, 79, 255)},
[205] = {name = "HUD_COLOUR_G14", color = funcs.get.rgba_to_int(137, 210, 215, 255)},
[206] = {name = "HUD_COLOUR_G15", color = funcs.get.rgba_to_int(134, 125, 141, 255)},
[207] = {name = "HUD_COLOUR_ADVERSARY", color = funcs.get.rgba_to_int(109, 34, 33, 255)},
[208] = {name = "HUD_COLOUR_DEGEN_RED", color = funcs.get.rgba_to_int(255, 0, 0, 255)},
[209] = {name = "HUD_COLOUR_DEGEN_YELLOW", color = funcs.get.rgba_to_int(255, 255, 0, 255)},
[210] = {name = "HUD_COLOUR_DEGEN_GREEN", color = funcs.get.rgba_to_int(0, 255, 0, 255)},
[211] = {name = "HUD_COLOUR_DEGEN_CYAN", color = funcs.get.rgba_to_int(0, 255, 255, 255)},
[212] = {name = "HUD_COLOUR_DEGEN_BLUE", color = funcs.get.rgba_to_int(0, 0, 255, 255)},
[213] = {name = "HUD_COLOUR_DEGEN_MAGENTA", color = funcs.get.rgba_to_int(255, 0, 255, 255)},
[214] = {name = "HUD_COLOUR_STUNT_1", color = funcs.get.rgba_to_int(38, 136, 234, 255)},
[215] = {name = "HUD_COLOUR_STUNT_2", color = funcs.get.rgba_to_int(224, 50, 50, 255)},
[216] = {name = "HUD_COLOUR_SPECIAL_RACE_SERIES", color = funcs.get.rgba_to_int(154, 178, 54, 255)},
[217] = {name = "HUD_COLOUR_SPECIAL_RACE_SERIES_DARK", color = funcs.get.rgba_to_int(93, 107, 45, 255)},
[218] = {name = "HUD_COLOUR_CS", color = funcs.get.rgba_to_int(206, 169, 13, 255)},
[219] = {name = "HUD_COLOUR_CS_DARK", color = funcs.get.rgba_to_int(103, 84, 6, 255)},
[220] = {name = "HUD_COLOUR_TECH_GREEN", color = funcs.get.rgba_to_int(0, 151, 151, 255)},
[221] = {name = "HUD_COLOUR_TECH_GREEN_DARK", color = funcs.get.rgba_to_int(5, 119, 113, 255)},
[222] = {name = "HUD_COLOUR_TECH_RED", color = funcs.get.rgba_to_int(151, 0, 0, 255)},
[223] = {name = "HUD_COLOUR_TECH_GREEN_VERY_DARK", color = funcs.get.rgba_to_int(0, 40, 40, 255)},
[224] = {name = "HUD_COLOUR_PLACEHOLDER_01", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[225] = {name = "HUD_COLOUR_PLACEHOLDER_02", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[226] = {name = "HUD_COLOUR_PLACEHOLDER_03", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[227] = {name = "HUD_COLOUR_PLACEHOLDER_04", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[228] = {name = "HUD_COLOUR_PLACEHOLDER_05", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[229] = {name = "HUD_COLOUR_PLACEHOLDER_06", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[230] = {name = "HUD_COLOUR_PLACEHOLDER_07", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[231] = {name = "HUD_COLOUR_PLACEHOLDER_08", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[232] = {name = "HUD_COLOUR_PLACEHOLDER_09", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
[233] = {name = "HUD_COLOUR_PLACEHOLDER_10", color = funcs.get.rgba_to_int(255, 255, 255, 255)},
}

g.feat.map_tp=menu_add_feature("Map Teleport","toggle", g.prnt.utils_map_tp.id, function(f)
	while not g.var.GS_has_loaded or not g.var.map_images_loaded or not g.tbl.RADAR.objective or not g.tbl.RADAR.loaded do
		YIELD(0)
	end
	local cursor_raw = v2()
	local cursor_pos = v2()
	local posXoffset,posYoffset = 232,1700
	local rawXoffset,rawYoffset = 0,0
	local mult = 1
	local cayo = false
	local limitX,limitY = 8000,9000
	local mathX,mathY = 13830,7785
	local full_color,color = funcs.get.rgba_to_int(255,255,255,255)
	local time = TIME_MS() + 2000
	while f.on do
		color = funcs.get.rgba_to_int(255,255,255,g.feat.map_alpha.value)
		funcs.doo.map_and_mouse(cursor_raw,cursor_pos,color,full_color,mathX,mathY,posXoffset,posYoffset,rawXoffset,rawYoffset,mult,cayo,time)
		if funcs.is.vk_key_down("ESCAPE") or funcs.is.key_active(25,1) or controls.is_disabled_control_pressed(0,25) then
			f.on=false
		elseif funcs.is.vk_key_down("SHIFT") then
			if mult == 1 then
				if funcs.is.in_grid_xy(funcs.vec(4763.5,-5153.5),cursor_pos,1300) then
					posXoffset,posYoffset = 4763.5,-5153.5
					cayo = true
				else
					rawXoffset,rawYoffset = cursor_raw.x,cursor_raw.y
					posXoffset,posYoffset = cursor_pos.x,cursor_pos.y
				end
				mult = g.feat.map_zoom.value
			else
				rawXoffset,rawYoffset = 0,0
				posXoffset,posYoffset = 232,1700
				mult = 1
				cayo = false
			end
			while funcs.is.vk_key_down("SHIFT") do
				YIELD(0)
				funcs.doo.map_and_mouse(cursor_raw,cursor_pos,color,full_color,mathX,mathY,posXoffset,posYoffset,rawXoffset,rawYoffset,mult,cayo,time)
			end
		elseif mult == 1 and (funcs.is.key_active(15,1) or controls.is_disabled_control_pressed(0,15)) then
			if funcs.is.in_grid_xy(funcs.vec(4763.5,-5153.5),cursor_pos,1300) then
				posXoffset,posYoffset = 4763.5,-5153.5
				cayo = true
			else
				rawXoffset,rawYoffset = cursor_raw.x,cursor_raw.y
				posXoffset,posYoffset = cursor_pos.x,cursor_pos.y
			end
			mult = g.feat.map_zoom.value
		elseif mult ~= 1 and (funcs.is.key_active(14,1) or controls.is_disabled_control_pressed(0,14)) then
			rawXoffset,rawYoffset = 0,0
			posXoffset,posYoffset = 232,1700
			mult = 1
			cayo = false
		elseif (funcs.is.key_active(223,1)  or controls.is_disabled_control_pressed(0,223)) and mth.abs(cursor_pos.x) < limitX and mth.abs(cursor_pos.y) < limitY then
			while funcs.is.key_active(223,1) do
				YIELD(0)
				funcs.doo.map_and_mouse(cursor_raw,cursor_pos,color,full_color,mathX,mathY,posXoffset,posYoffset,rawXoffset,rawYoffset,mult,cayo,time)
			end
			if mth.abs(cursor_pos.x) < limitX and mth.abs(cursor_pos.y) < limitY then
				local pos = v3(cursor_pos.x,cursor_pos.y,0)
				if funcs.get.ground_z(pos,true) then
					if funcs.ME._in_veh() then
						local veh = funcs.ME._veh()
						pos.z=pos.z+funcs.get.veh_tp_height(veh)
						if funcs.ntwrk.ask_long(veh,1500) then
							API.ent.set.coords(veh,pos)
						else
							g.N_P(2,"Teleport\nFAILED to get control of vehicle :(",__GV__,4,"Red")
						end
					else
						API.ent.set.coords(funcs.ME._ped(),pos)
					end
					f.on=false
				end
			end
		end
		YIELD(0)
	end
end)

g.feat.map_type = menu_add_feature("Select map type", "action_value_str",g.prnt.utils_map_tp.id)
new_set_str_data(g.feat.map_type,{"Color","Dark"})
funcs.add_to_S_L(g.feat.map_type,"g.feat.map_type")

g.feat.map_only_players = menu_add_feature("Only show players", "toggle",g.prnt.utils_map_tp.id)
funcs.add_to_S_L(g.feat.map_only_players,"g.feat.map_only_players")

g.feat.map_alpha = menu_add_feature("Map alpha", "action_value_i",g.prnt.utils_map_tp.id)
funcs.set_feat_i_f(g.feat.map_alpha,50,255,5,150,"g.feat.map_alpha")

g.feat.map_zoom = menu_add_feature("Zoom magnification", "action_value_i",g.prnt.utils_map_tp.id)
funcs.set_feat_i_f(g.feat.map_zoom,3,7,1,5,"g.feat.map_zoom")

g.feat.map_names = menu_add_feature("Show name distance", "action_value_f",g.prnt.utils_map_tp.id)
funcs.set_feat_i_f(g.feat.map_names,0.5,10,0.5,1,"g.feat.map_names")



g.print_load_info("Map Teleport",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)

g.var.feat_loading_str = "Main file contents"

g.prnt.utils_time_stop_watch = menu_add_feature("Stopwatch", "parent",g.prnt.utils_time.id)

menu_add_feature("Stopwatch", "toggle",g.prnt.utils_time_stop_watch.id,function(f)
	local time,current,h,m,s,text = TIME_MS()
	local color = funcs.get.rgba_to_int(255,255,255,255)
	while f.on do
		current = (TIME_MS()-time)
		s = mth.flr((current/1000/60 - mth.flr(current/1000/60))*600)*.1
		m = mth.flr(current/1000/60)
		--h fuck you, you dont get hours
		text = g.feat.stopwatch_t.value == 0 and m..":"..s or m.."m "..s.."s"
		API.SD.draw_text(text,funcs.vec(g.feat.stopwatch_x.value,g.feat.stopwatch_y.value),funcs.vec(g.feat.stopwatch_x.value,g.feat.stopwatch_y.value),g.feat.stopwatch_s.value*g.RES_H,color,1 << 1,nil)
		YIELD(0)
	end
	g.N_P(2,"Stopwatch ended\n"..text,__GV__,7,"Blue")
end)

g.feat.stopwatch_x = menu_add_feature("X Pos", "action_value_f",g.prnt.utils_time_stop_watch.id)
funcs.set_feat_i_f(g.feat.stopwatch_x,-1,1,0.01,-0.5,"g.feat.stopwatch_x")

g.feat.stopwatch_y = menu_add_feature("Y Pos", "action_value_f",g.prnt.utils_time_stop_watch.id)
funcs.set_feat_i_f(g.feat.stopwatch_y,-1,1,0.01,-0.9,"g.feat.stopwatch_y")

g.feat.stopwatch_s = menu_add_feature("Scale", "action_value_f",g.prnt.utils_time_stop_watch.id)
funcs.set_feat_i_f(g.feat.stopwatch_s,0.1,3,0.1,1.5,"g.feat.stopwatch_s")

g.feat.stopwatch_t = menu_add_feature("Time display style", "action_value_str",g.prnt.utils_time_stop_watch.id)
new_set_str_data(g.feat.stopwatch_t,{"Style 1","Style 2"})
funcs.add_to_S_L(g.feat.stopwatch_t,"g.feat.stopwatch_t")




g.prnt.utils_time_race = menu_add_feature("1/4 Mile Race", "parent",g.prnt.utils_time.id)

menu_add_feature("Start race", "toggle",g.prnt.utils_time_race.id,function(f)
	if f.on then
		if not funcs.ME._in_veh() then
			g.N_P(2,"You're not in a vehicle...",__GV__,4,"Yellow")
			f.on = false
			return
		end
		local my_veh,start,finish = funcs.ME._veh()
		local max_speed,my_speed=0
		local firework,firework_pop,start_movement
		local trigger = g.feat.race_start.value
		local color = funcs.get.rgba_to_int(255,255,255,255)
		API.ent.set.velocity(my_veh,funcs.vec(0,0,0))
		if trigger == 1 then
			local start_pos = API.ent.get.coords(my_veh)+funcs.vec(0,0,5)
			local target_pos = funcs.get.front_of_pos(API.ent.get.coords(my_veh), API.ent.get.heading(my_veh), 69, 180, 40)
			gameplay.shoot_single_bullet_between_coords(start_pos,target_pos,0, API.get_hash_key("weapon_firework"),  funcs.ME._ped(), false, true, 100)
			YIELD(0)
			firework = funcs.get.closest_obj(start_pos,100.00,439782367)
		end
		while f.on and not start do
			if trigger == 0 and API.ent.get.speed(my_veh) > 0 then
				start=true
			elseif trigger == 1 and not funcs.is.ent(firework) then
				firework_pop=TIME_MS()
				start=true
			end
			if not funcs.ME._in_veh() then
				g.N_P(2,"You got out of your vehicle...",__GV__,4,"Yellow")
				f.on = false
			end
			if trigger == 1 and not start_movement and API.ent.get.speed(my_veh) > 0 then
				start_movement = TIME_MS()
			end
			API.SD.draw_text(trigger == 0 and "Waiting for vehicle movement..." or "Waiting for firwork to burst...",funcs.vec(g.feat.race_x.value*(2/3),g.feat.race_y.value),funcs.vec(g.feat.race_x.value*(2/3),g.feat.race_y.value),g.feat.race_s.value*g.RES_H,color,(1 << 1)+ (1<<0),nil)
			YIELD(0)
		end
		local start_pos,dist = API.ent.get.coords(my_veh)
		local time,current,h,m,s,text = TIME_MS()

		local quarter,eighth
		local sixty = ":("
		local veh_name = funcs.get.veh_model_name(my_veh)
		while f.on and not finish and funcs.ME._in_veh() do
			current = (TIME_MS()-time)
			s =funcs.get._3_dec(current/1000)
			text = s.."s"
			my_speed = API.ent.get.speed(my_veh)
			if trigger == 1 and not start_movement and my_speed > 0 then
				start_movement = TIME_MS()
			end
			max_speed = my_speed > max_speed and my_speed or max_speed
			dist = funcs.get.dist_pospos_v3(API.ent.get.coords(my_veh),start_pos)
			if sixty == ":(" and my_speed >= 26.8224 then
				sixty = text
			end
			if not eighth and dist >= 201.168 then
				eighth = text
			end
			if not quarter and dist >= 402.336 then
				quarter = text
				finish=true
			end

			API.SD.draw_text(text,funcs.vec(g.feat.race_x.value,g.feat.race_y.value),funcs.vec(g.feat.race_x.value,g.feat.race_y.value),g.feat.race_s.value*g.RES_H,color,1 << 1,nil)
			YIELD(0)
		end
		if finish then
			sixty = type(sixty)=="number" and sixty.." s" or sixty
			if trigger == 1 then
				if start_movement < firework_pop then
					g.N_P(2,veh_name.."\n#FF0000FF#CHEATER#DEFAULT# Started "..funcs.get._3_dec((firework_pop-start_movement)/1000).."s early\nMax speed "..funcs.get._3_dec(max_speed*2.23694).." MPH\n0-60 time "..sixty.."\n1/8 Mile "..eighth.."\n1/4 Mile "..quarter,__GV__,15,"Yellow")
				else
					g.N_P(2,veh_name.."\nStarted "..funcs.get._3_dec((start_movement-firework_pop)/1000).."s late\nMax speed "..funcs.get._3_dec(max_speed*2.23694).." MPH\n0-60 time "..sixty.."\n1/8 Mile "..eighth.."\n1/4 Mile "..quarter,__GV__,15,"Blue")
				end
			else
				g.N_P(2,veh_name.."\nMax speed "..funcs.get._3_dec(max_speed*2.23694).." MPH\n0-60 time "..sixty.."\n1/8 Mile "..eighth.."\n1/4 Mile "..quarter,__GV__,15,"Blue")
			end
		end
	end
	f.on=false
end)

g.feat.race_start = menu_add_feature("Trigger", "action_value_str",g.prnt.utils_time_race.id)
new_set_str_data(g.feat.race_start,{"Vehicle movement", "Firework"})
funcs.add_to_S_L(g.feat.race_start,"g.feat.race_start")

g.feat.race_x = menu_add_feature("X Pos", "action_value_f",g.prnt.utils_time_race.id)
funcs.set_feat_i_f(g.feat.race_x,-1,1,0.01,0,"g.feat.race_x")

g.feat.race_y = menu_add_feature("Y Pos", "action_value_f",g.prnt.utils_time_race.id)
funcs.set_feat_i_f(g.feat.race_y,-1,1,0.01,-0.9,"g.feat.race_y")

g.feat.race_s = menu_add_feature("Scale", "action_value_f",g.prnt.utils_time_race.id)
funcs.set_feat_i_f(g.feat.race_s,0.1,3,0.1,1.5,"g.feat.race_s")



g.var.wp_low=v3()
g.var.obj_low=v3()

function funcs.get.OBJ_coords3()
	if g.var.obj_low.x ~=0 and g.var.obj_low.y ~=0 then
		return v3(g.var.obj_low.x,g.var.obj_low.y,g.var.obj_low.z)
	end
end

function funcs.get.OBJ_coords2()
	local found,obj_pos = ui.get_objective_coord()
	if found and obj_pos ~= funcs.vec(0,0,0) then --this prevents you from tp'ing under the city
		local bad_blip = false
		for i=1,#g.tbl.PID_INFO.otr_blip do
			if ntv.is.blip_exist(g.tbl.PID_INFO.otr_blip[i]) and funcs.get.dist_pospos_v2(ui.get_blip_coord(g.tbl.PID_INFO.otr_blip[i]),obj_pos) < 25 then --this ensures that i wont tp to a green otr blip i made
				bad_blip=true
				break
			end
		end
		if not bad_blip then
			for i=1,#g.tbl.PID_INFO.undead_blip do
				if ntv.is.blip_exist(g.tbl.PID_INFO.undead_blip[i]) and funcs.get.dist_pospos_v2(ui.get_blip_coord(g.tbl.PID_INFO.undead_blip[i]),obj_pos) < 25  then
					bad_blip=true
					break
				end
			end
		end
		if not bad_blip then
			return (obj_pos+funcs.vec(0,0,.5))
		end
	end
	return nil
end

function funcs.get.OBJ_coords4(obj_list)
	local blip
	for k,v in ipairs(obj_list) do
		blip = ntv.get.first_blip_infoid(v)
		if blip then
			return blip
		end
	end
	return nil
end

function funcs.get.OBJ_coords5(obj_color,otr_dead_blips)
	for k,v in pairs(obj_color) do
		local blip = ntv.get.first_blip_infoid(1)
		while blip do
			if not otr_dead_blips[blip] and ntv.get.blip_hud_color(blip) == v and not API.Ped.is.plyr(ui.get_entity_from_blip(blip)) then
				return blip
			end
			blip = ntv.get.next_blip_infoid(1)
		end
	end
	return nil
end

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	while not g.var.GS_has_loaded do
		YIELD(0)
	end
	local otr_dead_blips = {}
	local all_blips =  {}
	local basic_blips = {}
	local obj,obj_v2,found,blip,blip_color,bypass,time
	local check_color ={
	12,	--HUD_COLOUR_YELLOW
	11,	--HUD_COLOUR_BLUEDARK
	9	--HUD_COLOUR_BLUE
	}
	local obj_color ={
	12,	--HUD_COLOUR_YELLOW
	11, --HUD_COLOUR_BLUEDARK
	18,	--HUD_COLOUR_GREEN
	9	--HUD_COLOUR_BLUE
	}
	local blip_list = {}
	for k,v in pairs(g.tbl.blip_image) do --shitload of vehicle blips
		blip_list[#blip_list+1]=k
	end
	blip_list[#blip_list+1]=679--casino
	blip_list[#blip_list+1]=64--static helo
	blip_list[#blip_list+1]=280--waving ped
	blip_list[#blip_list+1]=480--standing ped
	blip_list[#blip_list+1]=455--yacht
	blip_list[#blip_list+1]=431--circle  $
	blip_list[#blip_list+1]=456--finders_keepers  ?
	blip_list[#blip_list+1]=403--testosterone
	blip_list[#blip_list+1]=52--crim_holdups
	local function record_blip(BLIP,color)
		time=TIME_MS()+500
		found=true
		while ntv.is.blip_exist(BLIP) and time>TIME_MS() and ntv.get.blip_hud_color(BLIP) == color do
			obj = ntv.get.blip_coords(BLIP)
			obj.z=obj.z+1
			g.var.obj_low.x = obj.x
			g.var.obj_low.y = obj.y
			g.var.obj_low.z = obj.z
			YIELD(0)
		end
	end
	local function wipe_blips(tbl)
		for k, v in pairs(tbl) do
			if type(v) == "table" then
				for kk, vv in pairs(v) do
					v[kk]=nil
				end
			end
		end
	end
	local function get_blip_list()
		wipe_blips(all_blips)
		for k,v in pairs(blip_list) do
			blip = ntv.get.first_blip_infoid(v)
			while blip do
				all_blips[v] = all_blips[v] or {}
				all_blips[v][#all_blips[v]+1]=blip
				blip = ntv.get.next_blip_infoid(v)
			end
		end
	end
	local function get_otr_dead_blips()
		for k,v in pairs(otr_dead_blips) do
			otr_dead_blips[k]=nil
		end
		for k,v in pairs(g.tbl.PID_INFO.otr_blip) do
			if v > -1 then
				otr_dead_blips[v]=true
			end
		end
		for k,v in pairs(g.tbl.PID_INFO.undead_blip) do
			if v > -1 then
				otr_dead_blips[v]=true
			end
		end
	end
	while true do
		found=false
		bypass=false
		get_otr_dead_blips()
		blip = funcs.get.OBJ_coords5(obj_color,otr_dead_blips)--basic bitch circle blip by color priority
		blip_color = ntv.get.blip_hud_color(blip)
		while ntv.is.blip_exist(blip) do
			record_blip(blip,blip_color)
			YIELD(0)
			get_otr_dead_blips()
			blip = funcs.get.OBJ_coords5(obj_color,otr_dead_blips)--basic bitch circle blip by color priority
			blip_color = ntv.get.blip_hud_color(blip)
		end
		get_blip_list()
		for k,BLIP_COLOR in ipairs(obj_color) do-- by color priority
			if bypass then
				break
			else
				for SPRITE_ID,BLIP_TBL in pairs(all_blips) do --most vehicle blips and several extras
					if bypass then
						break
					elseif BLIP_COLOR ~= 9 or (SPRITE_ID == 280 or SPRITE_ID == 480) then --only shows blue  color blips if standing ped or waving ped
						for kk,BLIP in pairs(BLIP_TBL) do
							if bypass then
								break
							else
								while ntv.is.blip_exist(BLIP) and ntv.get.blip_hud_color(BLIP) == BLIP_COLOR do
									get_otr_dead_blips()
									if funcs.get.OBJ_coords5(obj_color,otr_dead_blips) then--basic bitch circle blip by color priority
										bypass=true
										break
									else
										record_blip(BLIP,BLIP_COLOR)
									end
									YIELD(0)
								end
							end
						end
					end
				end
			end
			YIELD(0)
		end
		g.var.obj_low.x = 0
		g.var.obj_low.y = 0
		g.var.obj_low.z = 0
		if not found then
			YIELD(500)
		end
	end
end)

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	local wp,temp,found,tbl_entry = ui.get_waypoint_coord()
	while true do
		found=false
		if ntv.is.waypoint() then
			wp = ui.get_waypoint_coord()
			tbl_entry = funcs.vec_wp[funcs.get.v2_to_text(wp)]
			if tbl_entry then
				g.var.wp_low.x = tbl_entry.x
				g.var.wp_low.y = tbl_entry.y
				g.var.wp_low.z = tbl_entry.z
				while wp.x == g.var.wp_low.x and wp.y == g.var.wp_low.y do
					found=true
					YIELD(500)
					wp = ui.get_waypoint_coord()
				end
			elseif wp.x < 16000 then
				wp = v3(wp.x,wp.y,0)
				if funcs.get.ground_z(wp,false) then
					g.var.wp_low.x = wp.x
					g.var.wp_low.y = wp.y
					g.var.wp_low.z = wp.z
					while wp.x == g.var.wp_low.x and wp.y == g.var.wp_low.y do
						found=true
						YIELD(500)
						wp = ui.get_waypoint_coord()
					end
				end
			end
		end
		g.var.wp_low.x = 0
		g.var.wp_low.y = 0
		g.var.wp_low.z = 0
		if not found then
			YIELD(500)
		end
	end
end)

function funcs.get.ground_z(pos,focus)
	pos.z=0
	local time,temp,ground_z = TIME_MS() + 1000
	while TIME_MS() < time and pos.z<=900 do
		if focus then
			ntv.cam.set.focus_pos(pos) --SetFocusPosAndVel 100% success (GTA3 graphics)
		end
		ntv.doo.request_collision(pos) --RequestCollisionAtCoord 99% success
		YIELD(0)
		temp=ntv.get.ground_z(pos,1,0)
		if temp then
			if ground_z == nil then
				ground_z=temp
			elseif temp>ground_z then
				ground_z=temp
			end
		end
		pos.z=pos.z+50
	end
	if ground_z then
		pos.z=ground_z+1.5
	end
	if focus then
		ntv.cam.set.no_focus_pos() --ClearFocus
	end
	return ground_z
end

function funcs.get.waypoint()
	if ntv.is.waypoint() then
		local wp,time = ui.get_waypoint_coord(), TIME_MS() + 1000
		if funcs.vec_wp[funcs.get.v2_to_text(wp)] then
			return funcs.vec_wp[funcs.get.v2_to_text(wp)] + funcs.vec(0,0,0)
		elseif wp.x < 16000 then
			wp = v3(wp.x,wp.y,0)
			if funcs.get.ground_z(wp,true) then
				funcs.vec_wp[funcs.get.v2_to_text(wp)] = v3(wp.x,wp.y,wp.z)
				return wp
			end
		end
	end
end

menu_add_feature("TP-Self to personal vehicle", "action", g.prnt.self_veh_pers.id, function()
	funcs.doo.tp_pers_veh("self_2_veh")
end)

menu_add_feature("TP-Self to personal vehicle and drive", "action", g.prnt.self_veh_pers.id, function()
	funcs.doo.tp_pers_veh("self_2_veh_drive")
end)

menu_add_feature("TP-Personal-Vehicle to me", "action", g.prnt.self_veh_pers.id, function()
	funcs.doo.tp_pers_veh("veh_2_me")
end)

menu_add_feature("TP-Personal-Vehicle to me and drive", "action", g.prnt.self_veh_pers.id, function()
	funcs.doo.tp_pers_veh("veh_2_me_drive")
end)

g.feat.pers_veh_action_list=menu_add_feature("Personal vehicle", "action_value_str", g.prnt.self_veh_pers.id, function(f)
	local veh = API.plyr.pers_veh()
	if veh ~= 0 and funcs.is.veh(veh) then
		if f.value == 0 then
			funcs.doo.veh_repair_all(veh, 1000,nil,false,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
		elseif f.value == 1 then
			funcs.doo.veh_destroy(veh, 1000)
		elseif f.value == 2 then
			funcs.doo.veh_action_list(veh,1000,"upgrades",nil)
		elseif f.value == 3 then
			if funcs.is.veh_empty(veh) then
				g.N_P(2,"No one in the vehicle",__GV__,4,"Blue")
			else
				funcs.doo.kick_all_from_veh(veh)
			end
		else
			funcs.doo.clone_veh_for_me(veh)
		end
	else
		g.N_P(2,"No personal vehicle found...",__GV__,4,"Blue")
	end
end)
new_set_str_data(g.feat.pers_veh_action_list,{"Repair", "Destroy","Upgrade","Kick all from vehicle","Clone"})
funcs.add_to_S_L(g.feat.pers_veh_action_list,"g.feat.pers_veh_action_list")

g.feat.pers_veh_info_show=menu_add_feature("Show personal vehicle info", "action_value_str", g.prnt.self_veh_pers.id, function(f)
	local veh = API.plyr.pers_veh()
	if veh ~= 0 and funcs.is.veh(veh) then
		if f.value == 0 then
			funcs.doo.display_veh_info(veh,false,false,false,false,false,true,true,false,false,false,false,false,false)
		elseif f.value == 1 then
			funcs.doo.display_veh_info(veh,false,false,false,false,true,true,true,true,false,false,false,false,true)
		else
			funcs.doo.display_veh_info(veh,true,true,true,true,true,true,true,true,true,true,true,true,true)
		end
	else
		g.N_P(2,"Personal vehicle not found",__GV__,4,"Blue")
	end
end)
new_set_str_data(g.feat.pers_veh_info_show,{"Minimal", "Most","All"})
funcs.add_to_S_L(g.feat.pers_veh_info_show,"g.feat.pers_veh_info_show")

menu_add_feature("TP-Self to last vehicle", "action", g.prnt.self_veh_last.id, function()
	funcs.doo.tp_last_veh("self_2_veh")
end)

menu_add_feature("TP-Self to last vehicle and drive", "action", g.prnt.self_veh_last.id, function()
	funcs.doo.tp_last_veh("self_2_veh_drive")
end)

menu_add_feature("TP-Last-Vehicle to me", "action", g.prnt.self_veh_last.id, function()
	funcs.doo.tp_last_veh("veh_2_me")
end)

menu_add_feature("TP-Last-Vehicle to me and drive", "action", g.prnt.self_veh_last.id, function()
	funcs.doo.tp_last_veh("veh_2_me_drive")
end)

g.feat.last_veh_action_list=menu_add_feature("Last vehicle", "action_value_str", g.prnt.self_veh_last.id, function(f)
	local _veh
	if funcs.ME._in_veh() then	_veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist-1] else _veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist] end
	if f.value == 4 and g.tbl.veh_clone[_veh] ~= nil then
		local pos = funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),5 + funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos()))
		funcs.doo.create_clone_veh(g.tbl.veh_clone[_veh],pos,API.cam.get.rot().z)
	elseif not funcs.is.veh(_veh) then
		g.N_P(2,"Last vehicle not found",__GV__,4,"Blue")
	elseif funcs.get.dist_pospos_v3(API.ent.get.coords(_veh),funcs.vec(0,0,0)) < 10 then --sometimes gta reports its pos as 0,0,0 when it cant find it
		g.N_P(2,"Last vehicle not found",__GV__,4,"Blue")
	elseif f.value == 0 then
		funcs.doo.veh_repair_all(_veh, 1000,nil,false,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
	elseif f.value == 1 then
		funcs.doo.veh_destroy(_veh, 2500)
	elseif f.value == 2 then
		funcs.doo.veh_action_list(_veh,1000,"upgrades",nil)
	elseif f.value == 3 then
		if funcs.is.veh_empty(_veh) then
			g.N_P(2,"No one in the vehicle",__GV__,4,"Blue")
		else
			funcs.doo.kick_all_from_veh(_veh)
		end
	else
		funcs.doo.clone_veh_for_me(_veh)
	end
end)
new_set_str_data(g.feat.last_veh_action_list,{"Repair", "Destroy","Upgrade","Kick all from vehicle", "Clone"})
funcs.add_to_S_L(g.feat.last_veh_action_list,"g.feat.last_veh_action_list")

function funcs.doo.tp_last_veh(_action)
	local veh
	if funcs.ME._in_veh() then	veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist-1] else veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist] end
	local mee = API.plyr.get.ped(API.plyr.my_id())
	local my_veh = API.Ped.get.veh(mee)
	local function kick_driver(_veh)
		if funcs.is.ent(API.veh.get.ped_in_seat(_veh, -1)) then
			if API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, -1)) then
				glbls.kick_from_veh(API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(_veh, -1)))
			end
			API.Ped.clear_tasks(API.veh.get.ped_in_seat(_veh, -1))
		end
		local time = TIME_MS() + 250
		while funcs.is.ent(API.veh.get.ped_in_seat(_veh, -1)) and TIME_MS() < time do
			YIELD(0)
		end
	end
	if veh and veh ~= 0 and veh ~= my_veh and funcs.is.veh(veh) then
		funcs.doo.veh_flip(veh,"flip_right",250)
		if _action == "self_2_veh" then
			local pos = API.ent.get.coords(veh)
			pos.z = pos.z + 3
			API.ent.set.coords(mee, pos)
		elseif _action == "self_2_veh_drive" then
			kick_driver(veh)
			if not funcs.doo.veh_tp_into_free_seat(veh) then
				if not funcs.doo.veh_tp_into_hijack(veh) then
					funcs.N_P(2,"No free seat. Failed to hijack. :(",funcs.ver_text,4,"Red")
				else
					return true
				end
			else
				return true
			end
		elseif _action == "veh_2_me" then
			kick_driver(veh)
			if not funcs.doo.tp_veh_to_me(veh) then
				funcs.N_P(2,"Could not teleport vehicle :(",funcs.ver_text,4,"Red")
			end
		elseif _action == "veh_2_me_drive" then
			kick_driver(veh)
			if funcs.doo.tp_veh_to_me(veh) then
				if not funcs.doo.veh_tp_into_free_seat(veh) then
					if not funcs.doo.veh_tp_into_hijack(veh) then
						funcs.N_P(2,"No free seat. Failed to hijack. :(",funcs.ver_text,4,"Red")
					end
				end
			else
				funcs.N_P(2,"Could not teleport vehicle :(",funcs.ver_text,4,"Red")
			end
		end
	elseif veh == my_veh and funcs.ME._in_veh() then
		funcs.N_P(2,"You're already in your last vehicle...",funcs.ver_text,4,"Blue")
	else
		funcs.N_P(2,"Last vehicle not found...",funcs.ver_text,4,"Blue")
	end
end


g.feat.last_veh_info_show=menu_add_feature("Show last vehicle info", "action_value_str", g.prnt.self_veh_last.id, function(f)
	local _veh
	if funcs.ME._in_veh() then	_veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist-1] else _veh = g.tbl.my_veh_hist[#g.tbl.my_veh_hist] end
	if not funcs.is.veh(_veh) then
		g.N_P(2,"Last vehicle not found",__GV__,4,"Blue")
	elseif funcs.get.dist_pospos_v3(API.ent.get.coords(_veh),funcs.vec(0,0,0)) < 10 then --sometimes gta reports its pos as 0,0,0 when it cant find it
		g.N_P(2,"Last vehicle not found",__GV__,4,"Blue")
	elseif f.value == 0 then
		funcs.doo.display_veh_info(_veh,false,false,false,false,false,true,true,false,false,false,false,false,false)
	elseif f.value == 1 then
		funcs.doo.display_veh_info(_veh,false,false,false,false,true,true,true,true,false,false,false,false,true)
	else
		funcs.doo.display_veh_info(_veh,true,true,true,true,true,true,true,true,true,true,true,true,true)
	end
end)
new_set_str_data(g.feat.last_veh_info_show,{"Minimal", "Most","All"})
funcs.add_to_S_L(g.feat.last_veh_info_show,"g.feat.last_veh_info_show")


function funcs.doo.clone_veh_for_me(_veh,_pos,_head)
	_pos = _pos or funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),funcs.get.spawn_front_dist(funcs.ME._id(),_veh) + funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos()))
	_head = _head or API.cam.get.rot().z
	assert(funcs.is.veh(_veh), "Attempted to clone an invalid vehicle.")
	funcs.doo.record_clone_veh(g.tbl.veh_clone,_veh)
	assert(g.tbl.veh_clone[_veh]~=nil, "Could not clone vehicle.")
	funcs.doo.create_clone_veh(g.tbl.veh_clone[_veh],_pos,_head)
end
------------------------------------------------------------------------------------------GeeSkid
---------------------------------------------------------------------------------------------Self
------------------------------------------------------------------------------------------Weapons
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

--------------------------------------------------Extracted from Universe. Modified significantly
g.tbl.ge = {}
g.tbl.ge.aim={}
g.tbl.ge.trcr={}
g.tbl.ge.trcr.table={}
g.tbl.ge.trgt={}
g.tbl.ge.trgt._bool=nil
g.tbl.ge.trgt._screen_pos=nil

g.tbl.ge._weap_hash = {
API.get_hash_key("weapon_heavysniper_mk2"),
API.get_hash_key("weapon_railgun"),
API.get_hash_key("weapon_rpg"),
API.get_hash_key("weapon_emplauncher"),
API.get_hash_key("weapon_firework"),
API.get_hash_key("weapon_grenadelauncher"),
API.get_hash_key("weapon_raypistol"),
API.get_hash_key("weapon_bzgas"),
API.get_hash_key("weapon_stickybomb"),
API.get_hash_key("weapon_proxmine"),
API.get_hash_key("weapon_molotov"),
API.get_hash_key("weapon_pipebomb"),
}

g.tbl.ge._weap_name = {
"Mk2 Sniper",
"Railgun",
"RPG",
"EMP Launcher",
"Firework Launcher",
"Grenade Launcher",
"Up-N-Atomizer",
"BZ-Gas",
"Sticky bomb",
"Proximity mine",
"Molotov",
"Pipebomb",
}

g.tbl.ge._weap_comp = {
[API.get_hash_key("weapon_heavysniper_mk2")]=API.get_hash_key("COMPONENT_HEAVYSNIPER_MK2_CLIP_EXPLOSIVE"), --0x89EBDAA7, --"Mk2 Sniper",
[API.get_hash_key("weapon_emplauncher")]=API.get_hash_key("COMPONENT_EMPLAUNCHER_CLIP_01"), --"EMP Launcher",
[API.get_hash_key("weapon_grenadelauncher")]=API.get_hash_key("COMPONENT_GRENADELAUNCHER_CLIP_01 0x11AE5C97"), --"Grenade Launcher",
}




function funcs.get.GE_start()
	local v3_start,pos,dir,mult,success
	local function get_bone_coord()
		success, v3_start = API.Ped.get.bone_coords(API.plyr.get.ped(API.plyr.my_id()), 0x9995, funcs.vec(0.0,0.0,-0.8))
		while not success do
			success, v3_start = API.Ped.get.bone_coords(API.plyr.get.ped(API.plyr.my_id()), 0x9995, funcs.vec(0.0,0.0,-0.8))
			system.wait(250)
		end
	end
	if funcs.ME._in_veh() then
		if g.tbl.ge.aim.veh_pos.value == 0 then
			if g.tbl.ge.aim.frwd_veh_offst_type.value == 2 then
				mult = 0
			elseif g.tbl.ge.aim.frwd_veh_offst_type.value == 1 then
				mult = g.tbl.ge.aim.frwd_veh_offst.value
			else
				_min,_max = API.ent.get.dimensions(API.plyr.get.veh(API.plyr.my_id()))
				mult=(((_max.x/3)+(_max.y/3)+(_max.z/3))*g.tbl.ge.aim.frwd_veh_smrt.value)
			end
		elseif g.tbl.ge.aim.fire_pos.value == 0 then
			mult = g.tbl.ge.aim.frwd_foot_offst.value
		else
			mult = g.tbl.ge.aim.frwd_cam_offst.value
		end
		if g.tbl.ge.aim.veh_pos.value == 0 then
			v3_start = API.ent.get.coords(API.plyr.get.veh(API.plyr.my_id()))
			if g.tbl.ge.aim.vert_veh_offst.value == 0 then
				_min,_max = API.ent.get.dimensions(API.plyr.get.veh(API.plyr.my_id()))
				v3_start.z=v3_start.z+(((_max.x/3)+(_max.y/3)+(_max.z/3))*g.tbl.ge.aim.smrt_veh_offst.value)
			elseif g.tbl.ge.aim.vert_veh_offst.value == 1 then
				v3_start.z=v3_start.z+g.tbl.ge.aim.mnl_veh_offst.value
			end
		elseif g.tbl.ge.aim.veh_pos.value == 1 then
			get_bone_coord()
		else
			v3_start = API.cam.get.pos()
		end
	elseif g.tbl.ge.aim.fire_pos.value == 0 then
		get_bone_coord()
		mult = g.tbl.ge.aim.frwd_foot_offst.value
	else
		v3_start = API.cam.get.pos()
		mult = g.tbl.ge.aim.frwd_cam_offst.value
	end
	pos=v3_start
	dir = API.cam.get.rot()
	dir:transformRotToDir()
	dir = dir * mult
	v3_start = v3_start + dir
	return v3_start
end

function funcs.get.GE_calc(_shotgun,_trgt_crds)
	_shotgun = _shotgun or false
	local v3_start=funcs.get.GE_start()
	local v3_end = v3_start
	if not _shotgun then
		if _trgt_crds == nil then
			local dir = API.cam.get.rot()
			dir:transformRotToDir()
			dir = dir * 1500
			v3_end = v3_end + dir
		else
			v3_end = _trgt_crds
		end
	else
		local spread1000,spreadv3 = mth.flr(g.tbl.ge.spread.value*20),v3()
		if g.tbl.ge.spread_type.value == 0 then -- circular
			spreadv3=funcs.vec(mth.rndm(-spread1000,spread1000)*0.001,0,mth.rndm(-spread1000,spread1000)*0.001)
		elseif g.tbl.ge.spread_type.value == 1 then -- horizontal
			spreadv3=funcs.vec(0,0,mth.rndm(-spread1000,spread1000)*0.001)
		else -- vertical
			spreadv3=funcs.vec((mth.rndm(-spread1000,spread1000)*0.001)+3,0,0)
		end
		if _trgt_crds == nil then
			local dir = API.cam.get.rot()+spreadv3
			dir:transformRotToDir()
			dir = dir * 1500
			v3_end = v3_end + dir
		else
			local dir,dist = funcs.get.vctr_to_pos3(_trgt_crds,v3_start,true)
			dir=dir+spreadv3
			dir:transformRotToDir()
			dir = dir * dist
			v3_end = v3_end + dir
		end
	end
	return v3_start,v3_end
end

function g.tbl.ge.trgt.straight_thread(v3_start,v3_end,_ent)
	if g.tbl.ge.enable_trgtng.on and g.tbl.ge.trgt.speed_type.value ~= 2 then
		local weap_obj=weap_info.hand.obj[g.tbl.ge._weap_hash[g.tbl.ge.feat.value+1]]
		if weap_obj ~= nil then
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local obj_hash,this_obj = weap_obj
				local _start,_end,_ped = v3_start,v3_end,_ent
				local trgt_crds_do,vec_to_trgt,trgt_crds
				local time = TIME_MS()+250
				local stop = false
				while time > TIME_MS() and not stop do
					local all_obj=object.get_all_objects()
					for i=1,#all_obj do
						if not API.ent.is.attached(all_obj[i]) and API.ent.get.model_hash(all_obj[i])==obj_hash then
							if not g.tbl.a_b.prev_obj[all_obj[i]] and funcs.is.in_grid(API.ent.get.coords(all_obj[i]),_start,10) then
								this_obj=all_obj[i]
								g.tbl.a_b.prev_obj[this_obj]=true
								API.ent.set.max_speed(this_obj,45000)
								time = TIME_MS()+5000
								local init_time = TIME_MS()+15
								local mult =0.69
								if weap_obj == weap_info.hand.obj[API.get_hash_key("weapon_raypistol")] then
									mult=4
								end
								if g.tbl.ge.trgt.speed_type.value == 1 then
									if g.tbl.ge.trgt.speed_amnt.value == 1 then
										if weap_obj == weap_info.hand.obj[API.get_hash_key("weapon_rpg")] then
											mult=1
										elseif weap_obj == weap_info.hand.obj[API.get_hash_key("weapon_firework")] then
											mult=1.25
										end
									end
									init_time = TIME_MS()+5000
								end
								while time > TIME_MS() and funcs.is.ent(this_obj) and not stop do
									if funcs.ntwrk.ask_quick(this_obj) then
										if API.ent.is.collided(this_obj) then
											stop=true
											API.ent.set.velocity(this_obj,API.ent.get.velocity(this_obj)*(0.25-g.tbl.ge.trgt.speed_amnt.value*0.02))
										else
											trgt_crds = _end
											if funcs.is.ent(_ped) then
												trgt_crds = API.ent.get.coords(_ped)
												_end = API.ent.get.coords(_ped)
											end
											trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(trgt_crds,API.ent.get.coords(this_obj),g.tbl.ge.trgt.speed_amnt.value*mult)
											if mult ~= 4 then
												API.ent.set.rotation(this_obj,funcs.get.vctr_to_pos(trgt_crds,this_obj))
											end
											API.ent.set.velocity(this_obj,trgt_crds_do)
										end
									end
									if init_time < TIME_MS() or funcs.get.total_velocity(this_obj) < 1 then
										stop = true
									end
									YIELD(5)
								end
								while time > TIME_MS() do
									YIELD(0)
								end
								stop=true
								g.tbl.a_b.prev_obj[this_obj]=false
								time = TIME_MS()
								break
							end
						end
					end
					YIELD(0)
				end
			end, nil)
		end
	end
end

g.tbl.ge.feat=menu_add_feature("Gee-Eye","value_str",g.prnt.self_weapons_ge.id,function(f)
	if funcs.is.GS_loaded() and f.on then
		g.N_P(2,"Press "..inputs.vk_list[g.tbl.ge.slct_key1.value+1].." to fire Gee-Eye",__GV__,10,"Blue")
	end
	local blame,notif_shoot,notif_mk2,trgt_crds,trgt_ped,f_value,time
	local v3_start,v3_end = v3(),v3()
	local function trigger()
		trgt_crds,trgt_ped = g.tbl.ge.trgt.trgt_crds,g.tbl.ge.trgt.trgt_ped
		if funcs.is.vk_key_down(inputs.vk_list[g.tbl.ge.slct_key1.value+1]) then
			return true
		elseif g.tbl.ge.enable_trgtng.on and g.tbl.ge.trgt.trigger_bot.on and trgt_crds ~= nil and trgt_ped ~= nil then
			return true
		end
		return false
	end
	local function show_reticle()
		if g.tbl.ge.trgt.show_rtcl.on and not g.tbl.rtcl.is_active and g.tbl.ge.enable_trgtng.on and trgt_crds == nil and trgt_ped == nil then
			g.tbl.ge.trgt.show_that_marker(funcs.vec(0,0),g.tbl.ge.trgt.mrkr_a.value)
		end
	end
	local function delay(_val)
		time = TIME_MS() + _val
		while time > TIME_MS() do
			YIELD(0)
			show_reticle()
		end
	end
	while f.on do
		YIELD(0)
		g.tbl.ge.aim.const_bool=g.tbl.ge.enable_trgtng.on
		notif_shoot=false
		if f_value ~= f.value+g.tbl.ge.blame.value + g.tbl.ge.slct_key1.value then
			if g.tbl.ge.blame.value == 1 then blame = 100000 else blame=API.plyr.get.ped(API.plyr.my_id())	end
			if g.tbl.ge._weap_comp[g.tbl.ge._weap_hash[f.value+1]] ~= nil then
				API.wpn.ped_give_comp(blame,g.tbl.ge._weap_hash[f.value+1],g.tbl.ge._weap_comp[g.tbl.ge._weap_hash[f.value+1]]) -- i cant be sure if this is needed. Maybe for players that dont have the weapon already
			end
			g.tbl.ge.trgt.range_name()
			f_value = f.value+g.tbl.ge.blame.value
		end
		show_reticle()
		while trigger() and not ntv.is.chat_active() do
			YIELD(0)
			show_reticle()
			if not notif_shoot then
				g.N_P(2,"Firing Gee-Eye!\n"..g.tbl.ge._weap_name[g.tbl.ge.feat.value+1],__GV__,4,"Green")
				notif_shoot = true
			end
			v3_start,v3_end = funcs.get.GE_calc(false,trgt_crds)
			g.tbl.ge.trcr.table[#g.tbl.ge.trcr.table+1]={v3_start,v3_end,TIME_MS(),g.tbl.ge.trcr.fade.value*1000}
			gameplay.shoot_single_bullet_between_coords(v3_start, v3_end, 1, g.tbl.ge._weap_hash[f.value+1], blame, funcs.is._01_to_bool(g.tbl.ge.aud.value),  funcs.is._01_to_bool(g.tbl.ge.vis.value,true), 1000)
			g.tbl.ge.trgt.straight_thread(v3_start,v3_end,trgt_ped)
			if mth.flr(g.tbl.ge.spread.value) > 25 then
				delay(mth.flr(g.tbl.ge.delay.value/8))
				for i=1,7 do
					if funcs.is.vk_key_down(inputs.vk_list[g.tbl.ge.slct_key1.value+1]) then
						v3_start,v3_end = funcs.get.GE_calc(true,trgt_crds)
						g.tbl.ge.trcr.table[#g.tbl.ge.trcr.table+1]={v3_start,v3_end,TIME_MS(),g.tbl.ge.trcr.fade.value*1000}
						g.tbl.ge.trgt.straight_thread(v3_start,v3_end,trgt_ped)
						gameplay.shoot_single_bullet_between_coords(v3_start, v3_end, 1, g.tbl.ge._weap_hash[f.value+1], blame, funcs.is._01_to_bool(g.tbl.ge.aud.value), funcs.is._01_to_bool(g.tbl.ge.vis.value,true), 1000)
						delay(mth.flr(g.tbl.ge.delay.value/8))
					end
				end
			else
				delay(g.tbl.ge.delay.value)
			end
		end
		if g.tbl.ge.feat.value == 0 and g.tbl.ge.blame.value == 1 and funcs.is.GS_loaded() then
			if not notif_mk2 then
				g.N_P(2,"Blaming no-one with Mk2 Sniper results in zero damage to players. I also couldn't figure out why it removes the explosive rounds :(",__GV__,7,"Yellow")
				notif_mk2=true
			end
		else
			notif_mk2=false
		end
	end
	f.name = "Gee-Eye"
end)
g.tbl.ge.feat:set_str_data(g.tbl.ge._weap_name)
funcs.add_to_S_L(g.tbl.ge.feat,"g.tbl.ge.feat")

g.tbl.ge.enable_trgtng=menu_add_feature("Enable assistance mode","toggle",g.prnt.self_weapons_ge.id,function(f)
	g.tbl.ge.trgt.trgt_ent = nil
	g.tbl.ge.trgt.trgt_ped = nil
	g.tbl.ge.trgt.trgt_crds = nil
	g.tbl.ge.trgt.range_name()
	if f.on then
		g.tbl.ge.trgt.peds={}
		g.tbl.ge.trgt.record_ped_info()
		g.tbl.ge.trgt.get_current_target()
	end
end)
funcs.add_to_S_L(g.tbl.ge.enable_trgtng,"g.tbl.ge.enable_trgtng")

g.tbl.ge.trcr.prnt=menu_add_feature("Tracers","parent",g.prnt.self_weapons_ge.id)

g.tbl.ge.trcr.feat=menu_add_feature("Add tracer effect", "toggle", g.tbl.ge.trcr.prnt.id, function(f)
	while f.on do
		YIELD(5)
		for i=1,#g.tbl.ge.trcr.table do
			if g.tbl.ge.trcr.table[i] ~= nil then
				if (g.tbl.ge.trcr.table[i][3]+g.tbl.ge.trcr.table[i][4])>TIME_MS() then
					ui.draw_line(
					g.tbl.ge.trcr.table[i][1],
					g.tbl.ge.trcr.table[i][2],
					g.tbl.ge.trcr.r.value,
					g.tbl.ge.trcr.g.value,
					g.tbl.ge.trcr.b.value,
					mth.flr((g.tbl.ge.trcr.table[i][3]+g.tbl.ge.trcr.table[i][4]-TIME_MS())/g.tbl.ge.trcr.table[i][4]*g.tbl.ge.trcr.a.value)
					)
				else
					g.tbl.ge.trcr.table[i] = nil
				end
			end
		end
	end
end)
funcs.add_to_S_L(g.tbl.ge.trcr.feat,"g.tbl.ge.trcr.feat")

g.tbl.ge.trcr.fade = menu_add_feature("Fade time (seconds)", "action_value_f",g.tbl.ge.trcr.prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trcr.fade,.125,5,.125,1,"g.tbl.ge.trcr.fade")

g.tbl.ge.trcr.r = menu_add_feature("Red", "action_value_i",g.tbl.ge.trcr.prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trcr.r,0,255,5,255,"g.tbl.ge.trcr.r")

g.tbl.ge.trcr.g = menu_add_feature("Green", "action_value_i",g.tbl.ge.trcr.prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trcr.g,0,255,5,0,"g.tbl.ge.trcr.g")

g.tbl.ge.trcr.b = menu_add_feature("Blue", "action_value_i",g.tbl.ge.trcr.prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trcr.b,0,255,5,0,"g.tbl.ge.trcr.b")

g.tbl.ge.trcr.a = menu_add_feature("Alpha", "action_value_i",g.tbl.ge.trcr.prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trcr.a,0,255,5,200,"g.tbl.ge.trcr.a")


g.tbl.ge.aim.prnt=menu_add_feature("Firing point options","parent",g.prnt.self_weapons_ge.id, function()
	g.tbl.ge.aim.veh_prnt.hidden=g.tbl.ge.aim.veh_pos.value ~= 0
	g.tbl.ge.aim.frwd_foot_offst.hidden=g.tbl.ge.aim.fire_pos.value==1 and g.tbl.ge.aim.veh_pos.value~=1
	g.tbl.ge.aim.frwd_cam_offst.hidden=g.tbl.ge.aim.fire_pos.value==0 and g.tbl.ge.aim.veh_pos.value~=2
end)

g.tbl.ge.aim.fade_bool=false
g.tbl.ge.aim.const_bool=false
g.tbl.ge.aim.temp_obj=nil
g.tbl.ge.aim.temp_feat=og_menu_add_feature("test object HIDDEN", "toggle", g.tbl.ge.aim.prnt.id, function(f)
	local time,obj,dir,pos,rot = TIME_MS()-1
	while f.on do
		YIELD(5)
		if g.tbl.ge.aim.fade_bool then
			g.tbl.ge.aim.fade_bool=false
			time = TIME_MS()+7000
		end
		if time > TIME_MS() or g.tbl.ge.aim.const_bool then
			if not funcs.is.ent(g.tbl.ge.aim.temp_obj) then
				funcs.doo.req_model(-1707997257)
				g.tbl.ge.aim.temp_obj = object.create_object(-1707997257,funcs.get.GE_start(), false,false)
				API.ent.freeze(g.tbl.ge.aim.temp_obj,true)
				API.ent.set.collision(g.tbl.ge.aim.temp_obj,false,false)
			else
				if time > TIME_MS() then
					API.ent.set.alpha(g.tbl.ge.aim.temp_obj, mth.flr((time-TIME_MS())/7000*255), false)
				else
					API.ent.set.alpha(g.tbl.ge.aim.temp_obj, 0, false)
				end
				API.ent.set.coords(g.tbl.ge.aim.temp_obj,funcs.get.GE_start())
				API.ent.set.rotation(g.tbl.ge.aim.temp_obj,API.cam.get.rot())
			end
		else
			funcs.doo.remove_ent(g.tbl.ge.aim.temp_obj,100)
			YIELD(100)
		end
	end
	funcs.doo.remove_ent(g.tbl.ge.aim.temp_obj,100)
	f.on=false
end)g.tbl.ge.aim.temp_feat.hidden=true
g.tbl.ge.aim.temp_feat.on=true


function funcs.doo.spawn_obj(_hash,_pos,_rot,_ntwrk,_freeze,_migrate,_vis)
	_rot = _rot or funcs.vec(0,0,0)
	_ntwrk = _ntwrk or true
	_freeze = _freeze or true
	_migrate = _migrate or 0
	_vis = _vis or true
	local temp = object.create_object(_hash, _pos, _ntwrk,false)
	API.ent.set.rotation(temp,_rot)
	API.ent.freeze(temp,_freeze)
	API.ent.set.visible(temp,_vis)
	funcs.doo.id_migrate(temp,_migrate)
	g.tbl.entities[#g.tbl.entities+1]=temp
	return temp
end







function g.tbl.ge.aim.temp_start(_bool)
	g.tbl.ge.aim.fade_bool=_bool
end

g.tbl.ge.aim.fire_pos=menu_add_feature("Firing point","autoaction_value_str",g.tbl.ge.aim.prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=true
	g.tbl.ge.aim.frwd_foot_offst.hidden=f.value==1 and g.tbl.ge.aim.veh_pos.value~=1
	g.tbl.ge.aim.frwd_cam_offst.hidden=f.value==0 and g.tbl.ge.aim.veh_pos.value~=2
end)
new_set_str_data(g.tbl.ge.aim.fire_pos,{"My ped", "Cam"})
funcs.add_to_S_L(g.tbl.ge.aim.fire_pos,"g.tbl.ge.aim.fire_pos")
g.tbl.ge.aim.fire_pos.value=1

g.tbl.ge.aim.frwd_foot_offst=menu_add_feature("Forward offset for ped","autoaction_value_f",g.tbl.ge.aim.prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(not funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.frwd_foot_offst,0,10,.5,2,"g.tbl.ge.aim.frwd_foot_offst")

g.tbl.ge.aim.frwd_cam_offst=menu_add_feature("Forward offset for cam","autoaction_value_f",g.tbl.ge.aim.prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(not funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.frwd_cam_offst,0,10,.5,6,"g.tbl.ge.aim.frwd_cam_offst")

g.tbl.ge.aim.veh_pos=menu_add_feature("Firing point in vehicle","autoaction_value_str",g.tbl.ge.aim.prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(f.value ~= 0 or (f.value == 0 and funcs.ME._in_veh()))
	g.tbl.ge.aim.veh_prnt.hidden=f.value ~= 0
	g.tbl.ge.aim.frwd_foot_offst.hidden=f.value~=1 and g.tbl.ge.aim.fire_pos.value~=0
	g.tbl.ge.aim.frwd_cam_offst.hidden=f.value==0 and g.tbl.ge.aim.fire_pos.value~=1
end)
new_set_str_data(g.tbl.ge.aim.veh_pos,{"Vehicle","My ped","Cam"})
funcs.add_to_S_L(g.tbl.ge.aim.veh_pos,"g.tbl.ge.aim.veh_pos")

g.tbl.ge.aim.veh_prnt=menu_add_feature("Vehicle offsets","parent",g.tbl.ge.aim.prnt.id,function(f)
	g.tbl.ge.aim.smrt_veh_offst.hidden=g.tbl.ge.aim.vert_veh_offst.value ~= 0
	g.tbl.ge.aim.mnl_veh_offst.hidden=g.tbl.ge.aim.vert_veh_offst.value ~= 1
	g.tbl.ge.aim.frwd_veh_smrt.hidden=g.tbl.ge.aim.frwd_veh_offst_type.value ~= 0
	g.tbl.ge.aim.frwd_veh_offst.hidden=g.tbl.ge.aim.frwd_veh_offst_type.value ~= 1
end)

g.tbl.ge.aim.frwd_veh_offst_type=menu_add_feature("Forward Offset type","autoaction_value_str",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(funcs.ME._in_veh())
	g.tbl.ge.aim.frwd_veh_smrt.hidden=f.value ~= 0
	g.tbl.ge.aim.frwd_veh_offst.hidden=f.value ~= 1
end)
new_set_str_data(g.tbl.ge.aim.frwd_veh_offst_type,{"Smart", "Manual","None"})
funcs.add_to_S_L(g.tbl.ge.aim.frwd_veh_offst_type,"g.tbl.ge.aim.frwd_veh_offst_type")

g.tbl.ge.aim.frwd_veh_smrt=menu_add_feature("Forward smart offset (multiplier)","autoaction_value_f",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.frwd_veh_smrt,0,3,.05,1,"g.tbl.ge.aim.frwd_veh_smrt")

g.tbl.ge.aim.frwd_veh_offst=menu_add_feature("Forward manual offset (meters)","autoaction_value_f",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.frwd_veh_offst,0,25,.1,2,"g.tbl.ge.aim.frwd_veh_offst")

g.tbl.ge.aim.vert_veh_offst=menu_add_feature("Vertical offset type","autoaction_value_str",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(funcs.ME._in_veh())
	g.tbl.ge.aim.smrt_veh_offst.hidden=f.value ~= 0
	g.tbl.ge.aim.mnl_veh_offst.hidden=f.value ~= 1
end)
new_set_str_data(g.tbl.ge.aim.vert_veh_offst,{"Smart", "Manual","None"})
funcs.add_to_S_L(g.tbl.ge.aim.vert_veh_offst,"g.tbl.ge.aim.vert_veh_offst")

g.tbl.ge.aim.smrt_veh_offst=menu_add_feature("Vertical smart offset (multiplier)","autoaction_value_f",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(g.tbl.ge.aim.vert_veh_offst.value == 0 and funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.smrt_veh_offst,0,3,.05,1,"g.tbl.ge.aim.smrt_veh_offst")

g.tbl.ge.aim.mnl_veh_offst=menu_add_feature("Vertical manual offset (meters)","autoaction_value_f",g.tbl.ge.aim.veh_prnt.id,function(f)
	g.tbl.ge.aim.fade_bool=(g.tbl.ge.aim.vert_veh_offst.value == 1 and funcs.ME._in_veh())
end)
funcs.set_feat_i_f(g.tbl.ge.aim.mnl_veh_offst,0,25,.1,2,"g.tbl.ge.aim.mnl_veh_offst")


function g.tbl.ge.trgt.check_visibility(_ent)
	local function los_check()
		return (funcs.is.ent(g.tbl.ge.aim.temp_obj) and ntv.is.ents_in_los(g.tbl.ge.aim.temp_obj,_ent,3,true))
	end
	g.tbl.ge.trgt._bool, g.tbl.ge.trgt._screen_pos = graphics.project_3d_coord(API.ent.get.coords(_ent))
	if g.tbl.ge.trgt._bool then
		g.tbl.ge.trgt._screen_pos = funcs.get.screen_pos_math(g.tbl.ge.trgt._screen_pos)
	end
	if g.tbl.ge.trgt.fov_limits.value == 0 then
		return (g.tbl.ge.trgt._bool and (mth.abs(g.tbl.ge.trgt._screen_pos.x)<=(g.tbl.ge.trgt.fov_x.value*0.01)) and (mth.abs(g.tbl.ge.trgt._screen_pos.y)<= (g.tbl.ge.trgt.fov_y.value*0.01)) and los_check())
	elseif g.tbl.ge.trgt.fov_limits.value == 1 then
		return (g.tbl.ge.trgt._bool and los_check())
	end
	return los_check()
end

function g.tbl.ge.trgt.record_ped_info()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local all_peds,this_ped
		local function name_dead(_ped,_name)
			g.tbl.ge.trgt.peds[_ped].NAME = _name
			if API.ent.is.dead(_ped) then
				g.tbl.ge.trgt.peds[_ped].NAME = g.tbl.ge.trgt.peds[_ped].NAME.." (DEAD)"
			end
		end
		while g.tbl.ge.enable_trgtng.on do
			YIELD(0)
			if g.tbl.ge.feat.on then
				all_peds=API.Ped.get.all()
				for i=1,#all_peds do
					this_ped=all_peds[i]
					if g.tbl.ge.trgt.peds[this_ped]== nil or this_ped == funcs.ME._ped() or API.ent.get.coords(this_ped).z < -49 then
						g.tbl.ge.trgt.peds[this_ped]={PED=this_ped,NAME="",GOOD=false}
					elseif API.Ped.is.plyr(this_ped) then
						local pid = API.plyr.get.plyr_from_ped(this_ped)
						name_dead(this_ped,funcs.get.pid_name(pid))
						if not g.tbl.ge.trgt.type_plyr.on then
							g.tbl.ge.trgt.peds[this_ped].GOOD=false
						else
							local frnd = API.plyr.is.friend(pid)
							local orgmc = funcs.is.same_orgmc(funcs.ME._id(),pid)
							local other  = (not frnd and not orgmc)
							if 	(frnd and g.tbl.ge.trgt.type_frnd.value == 0) or
								(orgmc and g.tbl.ge.trgt.type_org.value == 0) or
								(other and g.tbl.ge.trgt.type_othr_plyr.value == 0) then
								g.tbl.ge.trgt.peds[this_ped].GOOD = false
							else
								g.tbl.ge.trgt.peds[this_ped].GOOD = true
							end
						end
					elseif not g.tbl.ge.trgt.type_npc.on then
						g.tbl.ge.trgt.peds[this_ped].GOOD=false
						g.tbl.ge.trgt.peds[this_ped].NAME = ""
					elseif ped_models.rltshp_csa[API.Ped.get.rel_group_hash(this_ped)] then
						name_dead(this_ped,"COP")
						if g.tbl.ge.trgt.type_mssn.value == 0 and (ped_models.rltshp_mssn[API.Ped.get.rel_group_hash(this_ped)] or ntv.is.ped_dislikes(this_ped,API.plyr.get.ped(API.plyr.my_id())) or ntv.is.ped_attack_ped(this_ped,API.plyr.get.ped(API.plyr.my_id()))) then
							g.tbl.ge.trgt.peds[this_ped].GOOD=true
						else
							g.tbl.ge.trgt.peds[this_ped].GOOD=(g.tbl.ge.trgt.type_csa.value == 0)
						end
					elseif (ped_models.rltshp_mssn[API.Ped.get.rel_group_hash(this_ped)] or ntv.is.ped_dislikes(this_ped,API.plyr.get.ped(API.plyr.my_id())) or ntv.is.ped_attack_ped(this_ped,API.plyr.get.ped(API.plyr.my_id()))) then
						name_dead(this_ped,"ANGRY")
						if g.tbl.ge.trgt.type_csa.value == 0  and ped_models.rltshp_csa[API.Ped.get.rel_group_hash(this_ped)] then
							g.tbl.ge.trgt.peds[this_ped].GOOD=true
						else
							g.tbl.ge.trgt.peds[this_ped].GOOD=(g.tbl.ge.trgt.type_mssn.value == 0)
						end
					else
						name_dead(this_ped,"PED")
						g.tbl.ge.trgt.peds[this_ped].GOOD=(g.tbl.ge.trgt.type_othr_npc.value == 0)
					end
				end
				YIELD(100)
				for _,Ped in pairs(g.tbl.ge.trgt.peds) do
					if Ped ~= nil and not funcs.is.ent(Ped.PED) then
						Ped=nil
					end
				end
			end
		end
	end, nil)
end

function g.tbl.ge.trgt.get_current_target()
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local _table,_table2,this_ped,all_peds,time,this_ent
		while g.tbl.ge.enable_trgtng.on do
			YIELD(0)
			if g.tbl.ge.feat.on then
				_table = {}
				all_peds=API.Ped.get.all()
				for i=1,#all_peds do
					this_ped = all_peds[i]
					if g.tbl.ge.trgt.peds[this_ped] ~= nil and g.tbl.ge.trgt.peds[this_ped].GOOD and not API.ent.is.dead(this_ped) and funcs.is.in_grid(funcs.get.GE_start(),API.ent.get.coords(this_ped),g.tbl.ge.trgt.trgt_range) then
						if API.Ped.is.in_veh(this_ped) and g.tbl.ge.trgt.check_visibility(API.Ped.get.veh(this_ped)) then
							if g.tbl.ge.trgt.fov_limits.value== 2 then
								_table[#_table+1]={API.Ped.get.veh(this_ped),this_ped,g.tbl.ge.trgt._screen_pos,funcs.get.vctr_to_pos(API.ent.get.coords(API.Ped.get.veh(this_ped)),funcs.ME._ped())}
							else
								_table[#_table+1]={API.Ped.get.veh(this_ped),this_ped,g.tbl.ge.trgt._screen_pos}
							end
						elseif g.tbl.ge.trgt.check_visibility(this_ped) then
							if g.tbl.ge.trgt.fov_limits.value== 2 then
								_table[#_table+1]={this_ped,this_ped,g.tbl.ge.trgt._screen_pos,funcs.get.vctr_to_pos(API.ent.get.coords(this_ped),funcs.ME._ped())}
							else
								_table[#_table+1]={this_ped,this_ped,g.tbl.ge.trgt._screen_pos}
							end
						end
					end
				end
				if #_table == 0 then
					g.tbl.ge.trgt.trgt_ent = nil
					g.tbl.ge.trgt.trgt_ped = nil
					g.tbl.ge.trgt.trgt_crds = nil
				else
					if g.tbl.ge.trgt.fov_limits.value == 2 then
						_table2={}
						for i=1,#_table do
							if _table[i][3]~= nil then
								_table2[#_table2+1]=_table[i]
							end
						end
						if #_table2 > 0 then
							table.sort(_table2, function(a, b) return mth.abs(a[3].x)+mth.abs(a[3].y) <  mth.abs(b[3].x)+mth.abs(b[3].y) end)
							_table={}
							for i=1,#_table2 do
								_table[i]=_table2[i]
							end
						else
							table.sort(_table, function(a, b) return funcs.get.v3_total_compare(API.cam.get.rot(),a[4])<funcs.get.v3_total_compare(API.cam.get.rot(),b[4])  end)
						end
					else
						table.sort(_table, function(a, b) return mth.abs(a[3].x)+mth.abs(a[3].y) <  mth.abs(b[3].x)+mth.abs(b[3].y) end)
					end
					g.tbl.ge.trgt.trgt_ent = _table[1][1]
					g.tbl.ge.trgt.trgt_ped = _table[1][2]
					g.tbl.ge.trgt.trgt_crds = API.ent.get.coords(g.tbl.ge.trgt.trgt_ped)
				end
			end
			time = TIME_MS() + g.tbl.ge.trgt.max_trgt_swtch.value
			while time > TIME_MS() and g.tbl.ge.feat.on and g.tbl.ge.trgt.good_ents(g.tbl.ge.trgt.trgt_ent,g.tbl.ge.trgt.trgt_ped) and g.tbl.ge.trgt.peds[g.tbl.ge.trgt.trgt_ped] ~= nil and g.tbl.ge.trgt.check_visibility(g.tbl.ge.trgt.trgt_ent) do
				g.tbl.ge.trgt.trgt_crds = API.ent.get.coords(g.tbl.ge.trgt.trgt_ped)
				YIELD(0)
			end
		end
	end, nil)
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		while g.tbl.ge.feat.on or g.tbl.ge.enable_trgtng.on do
			if g.tbl.ge.enable_trgtng.on then
				if g.tbl.ge.trgt.good_ents(g.tbl.ge.trgt.trgt_ent,g.tbl.ge.trgt.trgt_ped) and g.tbl.ge.trgt.peds[g.tbl.ge.trgt.trgt_ped] ~= nil then
					if g.tbl.ge.trgt.check_visibility(g.tbl.ge.trgt.trgt_ent) then
						g.tbl.ge.trgt.show_ped(g.tbl.ge.trgt.trgt_ped)
					end
				end
				if g.tbl.ge.trgt.fov_limits.value == 0 and g.tbl.ge.trgt.fov_show.on then
					g.tbl.ge.trgt.show_fov_box(g.tbl.ge.trgt.box_a.value)
				end
			end
			YIELD(0)
		end
	end, nil)
end

function g.tbl.ge.trgt.good_ents(_trgt,_t_ped)
	return (funcs.is.ent(_trgt) and funcs.is.ent(_t_ped) and not API.ent.is.dead(_t_ped))
end

g.tbl.ge.trgt.prnt=menu_add_feature("Assistance Options","parent",g.prnt.self_weapons_ge.id,function()
	g.tbl.ge.trgt.range_name()
end)

	function g.tbl.ge.trgt.range_name()
		g.tbl.ge.trgt.trgt_range = weap_info.GE_range[g.tbl.ge._weap_hash[g.tbl.ge.feat.value+1]][g.tbl.ge.trgt.speed_type.value][g.tbl.ge.trgt.speed_amnt.value]
		local weap_name = g.tbl.ge._weap_name[g.tbl.ge.feat.value+1]
		local homing = false
		if weap_name == "BZ-Gas" or weap_name == "Grenade Launcher" or weap_name == "Molotov" or weap_name == "Pipebomb" or weap_name == "EMP Launcher" then
			g.tbl.ge.trgt.range_display.name = weap_name.." - Est. direct impact: "..g.tbl.ge.trgt.trgt_range.."m"
			if g.tbl.ge.trgt.speed_type.value == 1 then
				g.tbl.ge.trgt.speed_type.name="Speed boost type: (Homing)"
				homing=true
			else
				g.tbl.ge.trgt.speed_type.name="Speed boost type:"
			end
		elseif weap_name == "Mk2 Sniper" or weap_name == "Railgun" then
			g.tbl.ge.trgt.range_display.name = weap_name.." - Max range: "..g.tbl.ge.trgt.trgt_range.."m (Unaffected by speed)"
			g.tbl.ge.trgt.speed_type.name="Speed boost type:"
		else
			g.tbl.ge.trgt.range_display.name = weap_name.." - Est. max range: "..g.tbl.ge.trgt.trgt_range.."m"
			if g.tbl.ge.trgt.speed_type.value == 1 then
				g.tbl.ge.trgt.speed_type.name="Speed boost type: (Homing)"
				homing=true
			else
				g.tbl.ge.trgt.speed_type.name="Speed boost type:"
			end
		end
		if g.tbl.ge.feat.on then
			if g.tbl.ge.enable_trgtng.on then
				if homing then
					g.tbl.ge.feat.name="Gee-Eye ("..inputs.vk_list[g.tbl.ge.slct_key1.value+1]..") "..g.tbl.ge.trgt.trgt_range.."m (Homing)"
				else
					g.tbl.ge.feat.name="Gee-Eye ("..inputs.vk_list[g.tbl.ge.slct_key1.value+1]..") "..g.tbl.ge.trgt.trgt_range.."m"
				end
			else
				g.tbl.ge.feat.name="Gee-Eye ("..inputs.vk_list[g.tbl.ge.slct_key1.value+1]..") "..weap_info.GE_range[g.tbl.ge._weap_hash[g.tbl.ge.feat.value+1]][2][1].."m"
			end
		else
			g.tbl.ge.feat.name="Gee-Eye"
		end
	end

	g.tbl.ge.trgt.range_display=menu_add_feature("Range","action",g.tbl.ge.trgt.prnt.id)

	g.tbl.ge.trgt.trigger_bot=menu_add_feature("Trigger-bot","toggle",g.tbl.ge.trgt.prnt.id)
	funcs.add_to_S_L(g.tbl.ge.trgt.trigger_bot,"g.tbl.ge.trgt.trigger_bot")

	g.tbl.ge.trgt.show_rtcl=menu_add_feature("Show reticle if no target available","toggle",g.tbl.ge.trgt.prnt.id)
	funcs.add_to_S_L(g.tbl.ge.trgt.show_rtcl,"g.tbl.ge.trgt.show_rtcl")
	g.tbl.ge.trgt.show_rtcl.on=true

	g.tbl.ge.trgt.speed_type=menu_add_feature("Speed boost type:","autoaction_value_str",g.tbl.ge.trgt.prnt.id,function()
		g.tbl.ge.trgt.range_name()
	end)
	new_set_str_data(g.tbl.ge.trgt.speed_type,{"Initial burst","Continuous","None"})
	funcs.add_to_S_L(g.tbl.ge.trgt.speed_type,"g.tbl.ge.trgt.speed_type")
	g.tbl.ge.trgt.speed_type.value=1

	g.tbl.ge.trgt.speed_amnt=menu_add_feature("Speed boost amount:","autoaction_value_i",g.tbl.ge.trgt.prnt.id,function()
		g.tbl.ge.trgt.range_name()
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.speed_amnt,1,10,1,1,"g.tbl.ge.trgt.speed_amnt")

	g.tbl.ge.trgt.fov_limits=menu_add_feature("Limit targets to:","action_value_str",g.tbl.ge.trgt.prnt.id)
	new_set_str_data(g.tbl.ge.trgt.fov_limits,{"Selected FOV limit","Anywhere on screen","Any direction"})
	funcs.add_to_S_L(g.tbl.ge.trgt.fov_limits,"g.tbl.ge.trgt.fov_limits")

	g.tbl.ge.trgt.max_trgt_swtch=menu_add_feature("Target switch time (ms)","action_value_i",g.tbl.ge.trgt.prnt.id)
	funcs.set_feat_i_f(g.tbl.ge.trgt.max_trgt_swtch,25,1000,25,150,"g.tbl.ge.trgt.max_trgt_swtch")

	function g.tbl.ge.trgt.ped_hide()
		g.tbl.ge.trgt.type_csa.hidden=(not g.tbl.ge.trgt.type_npc.on)
		g.tbl.ge.trgt.type_mssn.hidden=(not g.tbl.ge.trgt.type_npc.on)
		g.tbl.ge.trgt.type_othr_npc.hidden=(not g.tbl.ge.trgt.type_npc.on)
		g.tbl.ge.trgt.type_frnd.hidden=(not g.tbl.ge.trgt.type_plyr.on)
		g.tbl.ge.trgt.type_org.hidden=(not g.tbl.ge.trgt.type_plyr.on)
		g.tbl.ge.trgt.type_othr_plyr.hidden=(not g.tbl.ge.trgt.type_plyr.on)
	end

	g.tbl.ge.trgt.type_prnt=menu_add_feature("Target Selection","parent",g.tbl.ge.trgt.prnt.id,function(f)
		g.tbl.ge.trgt.ped_hide()
	end)

	g.tbl.ge.trgt.type_npc=menu_add_feature("NPC", "toggle", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.ped_hide()
		if not f.on and not g.tbl.ge.trgt.type_plyr.on then
			g.tbl.ge.trgt.type_plyr.on=true
		end
	end)
	funcs.add_to_S_L(g.tbl.ge.trgt.type_npc,"g.tbl.ge.trgt.type_npc")

	function g.tbl.ge.trgt.npc_no_option(_bool,_feat)
		if _bool and g.tbl.ge.trgt.type_csa.value==1 and g.tbl.ge.trgt.type_mssn.value==1 and g.tbl.ge.trgt.type_othr_npc.value==1 then
			_feat.value = 0
		end
	end

	g.tbl.ge.trgt.type_csa=menu_add_feature("Cops/Security/Army", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.npc_no_option(f.value==1,g.tbl.ge.trgt.type_mssn)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_csa,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_csa,"g.tbl.ge.trgt.type_csa")

	g.tbl.ge.trgt.type_mssn=menu_add_feature("Mission/Angry", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.npc_no_option(f.value==1,g.tbl.ge.trgt.type_othr_npc)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_mssn,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_mssn,"g.tbl.ge.trgt.type_mssn")

	g.tbl.ge.trgt.type_othr_npc=menu_add_feature("All other NPC", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.npc_no_option(f.value==1,g.tbl.ge.trgt.type_csa)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_othr_npc,{"Include","Exclude"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_othr_npc,"g.tbl.ge.trgt.type_othr_npc")

	g.tbl.ge.trgt.type_plyr=menu_add_feature("Players", "toggle", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.ped_hide()
		if not f.on and not g.tbl.ge.trgt.type_npc.on then
			g.tbl.ge.trgt.type_npc.on=true
		end
	end)
	funcs.add_to_S_L(g.tbl.ge.trgt.type_plyr,"g.tbl.ge.trgt.type_plyr")

	function g.tbl.ge.trgt.plyr_show_or_hide(_bool,_feat)
		if _bool and g.tbl.ge.trgt.type_frnd.value==0 and g.tbl.ge.trgt.type_org.value==0 and g.tbl.ge.trgt.type_othr_plyr.value==0 then
			_feat.value = 1
		end
	end


	g.tbl.ge.trgt.type_frnd=menu_add_feature("My Friends", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.plyr_show_or_hide(f.value==0,g.tbl.ge.trgt.type_org)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_frnd,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_frnd,"g.tbl.ge.trgt.type_frnd")

	g.tbl.ge.trgt.type_org=menu_add_feature("My ORG/MC", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.plyr_show_or_hide(f.value==0,g.tbl.ge.trgt.type_othr_plyr)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_org,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_org,"g.tbl.ge.trgt.type_org")

	g.tbl.ge.trgt.type_othr_plyr=menu_add_feature("All other players", "autoaction_value_str", g.tbl.ge.trgt.type_prnt.id,function(f)
		g.tbl.ge.trgt.plyr_show_or_hide(f.value==0,g.tbl.ge.trgt.type_frnd)
	end)
	new_set_str_data(g.tbl.ge.trgt.type_othr_plyr,{"Exclude","Include"})
	funcs.add_to_S_L(g.tbl.ge.trgt.type_othr_plyr,"g.tbl.ge.trgt.type_othr_plyr")


	g.tbl.ge.trgt.type_npc.on=true
	g.tbl.ge.trgt.type_plyr.on=true
	g.tbl.ge.trgt.type_othr_plyr.value=1

g.tbl.ge.trgt.trgt_optns_prnt=menu_add_feature("Target Information","parent",g.tbl.ge.trgt.prnt.id)

	g.tbl.ge.trgt.mrkr_show=menu_add_feature("Show target icon on screen","toggle",g.tbl.ge.trgt.trgt_optns_prnt.id)
	funcs.add_to_S_L(g.tbl.ge.trgt.mrkr_show,"g.tbl.ge.trgt.mrkr_show")
	g.tbl.ge.trgt.mrkr_show.on=true

	g.tbl.ge.trgt.show_name=menu_add_feature("Show name on screen","toggle",g.tbl.ge.trgt.trgt_optns_prnt.id)
	funcs.add_to_S_L(g.tbl.ge.trgt.show_name,"g.tbl.ge.trgt.show_name")
	g.tbl.ge.trgt.show_name.on=true

	function g.tbl.ge.trgt.start_test_display()
		if  g.var.GS_has_loaded then
			g.tbl.ge.trgt.test_display=true
			g.tbl.ge.trgt.test_display_feat.on=true
		end
	end

	g.tbl.ge.trgt.test_display=false
	g.tbl.ge.trgt.test_display_feat=og_menu_add_feature("Show icon/name HIDDEN", "toggle", g.tbl.ge.trgt.trgt_optns_prnt.id,function(f)
		local time,ent,alpha = TIME_MS() + 3000
		while time > TIME_MS() do
			if g.tbl.ge.trgt.test_display then
				g.tbl.ge.trgt.test_display=false
				time = TIME_MS() + 3000
			end
			g.tbl.ge.trgt.show_that_marker(funcs.vec(0,0),mth.flr((time-TIME_MS())/3000*g.tbl.ge.trgt.mrkr_a.value))
			g.tbl.ge.trgt.show_that_name(funcs.ME._ped(),funcs.vec(0,0),funcs.get.pid_name(funcs.ME._id()),mth.flr((time-TIME_MS())/3000*g.tbl.ge.trgt.name_a.value))
			YIELD(5)
		end
		f.on=false
	end)
	g.tbl.ge.trgt.test_display_feat.hidden=true

	g.tbl.ge.trgt.mrkr_prnt=menu_add_feature("Icon Options","parent",g.tbl.ge.trgt.trgt_optns_prnt.id,function()
		g.tbl.ge.trgt.icon_rot_hide()
	end)

		function g.tbl.ge.trgt.icon_rot_hide()
			g.tbl.ge.trgt.mrkr_wbl.hidden=(g.tbl.ge.trgt.mrkr_rot.value~=0 or not g.tbl.ge.trgt.mrkr_rot.on)
			g.tbl.ge.trgt.mrkr_rot_spd.hidden=(not g.tbl.ge.trgt.mrkr_rot.on)
		end

		g.tbl.ge.trgt.slct = menu_add_feature("Select icon", "autoaction_value_i", g.tbl.ge.trgt.mrkr_prnt.id, function(f)
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.slct,1,#g.tbl.reticle_files,1,41,"g.tbl.ge.trgt.slct")

		g.tbl.ge.trgt.mrkr_s = menu_add_feature("Icon size", "autoaction_value_f",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_s,0,3,0.01,1,"g.tbl.ge.trgt.mrkr_s")

		g.tbl.ge.trgt.mrkr_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_r,0,255,1,255,"g.tbl.ge.trgt.mrkr_r")

		g.tbl.ge.trgt.mrkr_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_g,0,255,1,172,"g.tbl.ge.trgt.mrkr_g")

		g.tbl.ge.trgt.mrkr_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_b,0,255,1,28,"g.tbl.ge.trgt.mrkr_b")

		g.tbl.ge.trgt.mrkr_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_a,0,255,1,255,"g.tbl.ge.trgt.mrkr_a")

		g.tbl.ge.trgt.mrkr_val = 0
		g.tbl.ge.trgt.mrkr_rot = menu_add_feature("Icon rotation", "value_str",g.tbl.ge.trgt.mrkr_prnt.id,function(f)
			local flip,f_value,_min,_max = true
			g.tbl.ge.trgt.start_test_display()
			while f.on do
				if f_value ~= f.value+g.tbl.ge.trgt.mrkr_wbl.value+g.tbl.ge.trgt.mrkr_rot_spd.value then
					g.tbl.ge.trgt.start_test_display()
					f_value = f.value+g.tbl.ge.trgt.mrkr_wbl.value+g.tbl.ge.trgt.mrkr_rot_spd.value
					g.tbl.ge.trgt.mrkr_val=0
				end
				if f.value == 0 then
					if flip then
						if g.tbl.ge.trgt.mrkr_val > g.tbl.ge.trgt.mrkr_wbl.value/360*2*mth.pi*-1 then
							g.tbl.ge.trgt.mrkr_val=g.tbl.ge.trgt.mrkr_val-(0.02*g.tbl.ge.trgt.mrkr_rot_spd.value)
						else flip=false
						end
					elseif g.tbl.ge.trgt.mrkr_val < g.tbl.ge.trgt.mrkr_wbl.value/360*2*mth.pi then
						g.tbl.ge.trgt.mrkr_val=g.tbl.ge.trgt.mrkr_val+(0.02*g.tbl.ge.trgt.mrkr_rot_spd.value)
					else flip=true
					end
				elseif g.tbl.ge.trgt.mrkr_val >= (2*mth.pi) then
					g.tbl.ge.trgt.mrkr_val = g.tbl.ge.trgt.mrkr_val - (2*mth.pi)
				elseif g.tbl.ge.trgt.mrkr_val <= (-2*mth.pi) then
					g.tbl.ge.trgt.mrkr_val = g.tbl.ge.trgt.mrkr_val+ (2*mth.pi)
				elseif f.value == 1 then
					g.tbl.ge.trgt.mrkr_val=g.tbl.ge.trgt.mrkr_val+(0.02*g.tbl.ge.trgt.mrkr_rot_spd.value)
				else
					g.tbl.ge.trgt.mrkr_val=g.tbl.ge.trgt.mrkr_val-(0.02*g.tbl.ge.trgt.mrkr_rot_spd.value)
				end
				g.tbl.ge.trgt.icon_rot_hide()
				YIELD(25)
			end
			g.tbl.ge.trgt.mrkr_wbl.hidden=true
			g.tbl.ge.trgt.mrkr_rot_spd.hidden=true
		end)
		new_set_str_data(g.tbl.ge.trgt.mrkr_rot,{"Wobble","Clockwise","Counter-Clockwise"})
		funcs.add_to_S_L(g.tbl.ge.trgt.mrkr_rot,"g.tbl.ge.trgt.mrkr_rot")
		g.tbl.ge.trgt.mrkr_rot.on=true
		g.tbl.ge.trgt.mrkr_rot.value=2

		g.tbl.ge.trgt.mrkr_wbl = menu_add_feature("Wobble range", "autoaction_value_i",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
			g.tbl.ge.trgt.mrkr_val=0
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_wbl,0,360,5,15,"g.tbl.ge.trgt.mrkr_wbl")

		g.tbl.ge.trgt.mrkr_rot_spd = menu_add_feature("Rotation speed", "autoaction_value_f",g.tbl.ge.trgt.mrkr_prnt.id,function()
			g.tbl.ge.trgt.start_test_display()
		end)
		funcs.set_feat_i_f(g.tbl.ge.trgt.mrkr_rot_spd,0.1,3,0.1,3,"g.tbl.ge.trgt.mrkr_rot_spd")

g.tbl.ge.trgt.name_prnt=menu_add_feature("Name Options","parent",g.tbl.ge.trgt.trgt_optns_prnt.id)

g.tbl.ge.trgt.name_flags=(1<<1)+(1<<0)
g.tbl.ge.trgt.name_x_flag=(2/3)

function g.tbl.ge.trgt.name_flags_do()
	if g.tbl.ge.trgt.name_just.value == 0 then
		g.tbl.ge.trgt.name_flags=(1<<1)
		g.tbl.ge.trgt.name_x_flag=1
	elseif g.tbl.ge.trgt.name_just.value == 1 then
		g.tbl.ge.trgt.name_flags=(1<<1)+(1<<0)
		g.tbl.ge.trgt.name_x_flag=(2/3)
	else
		g.tbl.ge.trgt.name_flags=(1<<1)+(1<<4)
		g.tbl.ge.trgt.name_x_flag=1
	end
end

function  g.tbl.ge.trgt.show_ped(_ped,alpha)
	local screen_pos = funcs.get.screen_pos_3d(API.ent.get.coords(_ped))
	if screen_pos then
		g.tbl.ge.trgt.show_that_marker(screen_pos,alpha)
		if  g.tbl.ge.trgt.peds[_ped] ~= nil then
			g.tbl.ge.trgt.show_that_name( g.tbl.ge.trgt.peds[_ped].PED,screen_pos, g.tbl.ge.trgt.peds[_ped].NAME,alpha)
		end
	end
end

function  g.tbl.ge.trgt.show_that_marker(pos,alpha)
	if  g.tbl.ge.trgt.mrkr_show.on then
		alpha = alpha or g.tbl.ge.trgt.mrkr_a.value
		if g.tbl.ge.trgt.mrkr_rot.on then
			API.SD.draw_sprt( g.tbl.reticle_sprites[ g.tbl.ge.trgt.slct.value],pos,1* g.tbl.ge.trgt.mrkr_s.value, g.tbl.ge.trgt.mrkr_val, funcs.get.rgba_to_int( g.tbl.ge.trgt.mrkr_r.value, g.tbl.ge.trgt.mrkr_g.value, g.tbl.ge.trgt.mrkr_b.value,alpha))
		else
			API.SD.draw_sprt( g.tbl.reticle_sprites[ g.tbl.ge.trgt.slct.value],pos,1* g.tbl.ge.trgt.mrkr_s.value,0, funcs.get.rgba_to_int( g.tbl.ge.trgt.mrkr_r.value, g.tbl.ge.trgt.mrkr_g.value, g.tbl.ge.trgt.mrkr_b.value,alpha))
		end
	end
end

function g.tbl.ge.trgt.show_that_name(ent,pos,name,alpha)
	if g.tbl.ge.trgt.show_name.on then
		alpha = alpha or g.tbl.ge.trgt.name_a.value
		pos.x=pos.x*g.tbl.ge.trgt.name_x_flag
		pos.x=pos.x+g.tbl.ge.trgt.name_x.value
		pos.y=pos.y+g.tbl.ge.trgt.name_y.value
		local _r,_g,_b = g.tbl.ge.trgt.name_r.value,g.tbl.ge.trgt.name_g.value,g.tbl.ge.trgt.name_b.value
		if funcs.is.ent(ent) and API.ent.is.ped(ent) and API.Ped.is.plyr(ent) and glbls.team_rgb_int(API.plyr.get.plyr_from_ped(ent)) > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.get.plyr_from_ped(ent)+1,nil)
		end
		API.SD.draw_text(name,pos,pos,g.tbl.ge.trgt.name_s.value,funcs.get.rgba_to_int(_r,_g,_b,mth.flr(alpha/255*g.tbl.ge.trgt.name_a.value)),g.tbl.ge.trgt.name_flags,nil)
	end
end

-- function g.tbl.ge.trgt.name_xy_do()
	-- g.tbl.ge.trgt.name_x.name = "X Pos Offset: "..funcs.get._3_dec(g.tbl.ge.trgt.name_x.value)
	-- g.tbl.ge.trgt.name_y.name = "Y Pos Offset: "..funcs.get._3_dec(g.tbl.ge.trgt.name_y.value)
-- end

g.tbl.ge.trgt.name_just = menu_add_feature("Justification", "autoaction_value_str",g.tbl.ge.trgt.name_prnt.id,function(f)
	g.tbl.ge.trgt.name_flags_do()
end)
new_set_str_data(g.tbl.ge.trgt.name_just,{"Left","Center","Right"})
funcs.add_to_S_L(g.tbl.ge.trgt.name_just,"g.tbl.ge.trgt.name_just")
g.tbl.ge.trgt.name_just.value=1

g.tbl.ge.trgt.name_s=menu_add_feature("Size","autoaction_value_f",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_s,0,3,0.01,1,"g.tbl.ge.trgt.name_s")

g.tbl.ge.trgt.name_x=menu_add_feature("X Pos Offset","autoaction_value_f",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_x,-1,1,0.0025,0,"g.tbl.ge.trgt.name_x")


g.tbl.ge.trgt.name_y=menu_add_feature("Y Pos Offset","autoaction_value_f",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_y,-1,1,0.0025,-0.025,"g.tbl.ge.trgt.name_y")


g.tbl.ge.trgt.name_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_r,0,255,1,255,"g.tbl.ge.trgt.name_r")

g.tbl.ge.trgt.name_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_g,0,255,1,255,"g.tbl.ge.trgt.name_g")

g.tbl.ge.trgt.name_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_b,0,255,1,255,"g.tbl.ge.trgt.name_b")

g.tbl.ge.trgt.name_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.ge.trgt.name_prnt.id)
funcs.set_feat_i_f(g.tbl.ge.trgt.name_a,0,255,1,255,"g.tbl.ge.trgt.name_a")


	g.tbl.ge.trgt.fov_prnt=menu_add_feature("FOV Limit","parent",g.tbl.ge.trgt.prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
		g.tbl.ge.trgt.hand_fov_hide()
	end)

	function g.tbl.ge.trgt.test_fov_start(_bool)
		if _bool then
			g.tbl.ge.trgt.test_fov_show=true
			g.tbl.ge.trgt.test_fov.on=true
		end
	end

	function g.tbl.ge.trgt.hand_fov_hide()
		g.tbl.ge.trgt.box_r.hidden=(not g.tbl.ge.trgt.fov_show.on)
		g.tbl.ge.trgt.box_g.hidden=(not g.tbl.ge.trgt.fov_show.on)
		g.tbl.ge.trgt.box_b.hidden=(not g.tbl.ge.trgt.fov_show.on)
		g.tbl.ge.trgt.box_a.hidden=(not g.tbl.ge.trgt.fov_show.on)
	end

	g.tbl.ge.trgt.fov_x=menu_add_feature("FOV X limit","autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.fov_x,1,100,1,18,"g.tbl.ge.trgt.fov_x")

	g.tbl.ge.trgt.fov_y=menu_add_feature("FOV Y limit","autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.fov_y,1,100,1,32,"g.tbl.ge.trgt.fov_y")

	g.tbl.ge.trgt.fov_show=menu_add_feature("Show FOV box","toggle",g.tbl.ge.trgt.fov_prnt.id,function(f)
		g.tbl.ge.trgt.test_fov_start(f.on)
		g.tbl.ge.trgt.hand_fov_hide()
	end)
	funcs.add_to_S_L(g.tbl.ge.trgt.fov_show,"g.tbl.ge.trgt.fov_show")

	g.tbl.ge.trgt.box_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.box_r,0,255,1,255,"g.tbl.ge.trgt.box_r")

	g.tbl.ge.trgt.box_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.box_g,0,255,1,172,"g.tbl.ge.trgt.box_g")

	g.tbl.ge.trgt.box_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.box_b,0,255,1,28,"g.tbl.ge.trgt.box_b")

	g.tbl.ge.trgt.box_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.ge.trgt.fov_prnt.id,function()
		g.tbl.ge.trgt.test_fov_start(g.tbl.ge.trgt.fov_show.on)
	end)
	funcs.set_feat_i_f(g.tbl.ge.trgt.box_a,0,255,1,255,"g.tbl.ge.trgt.box_a")

	g.tbl.ge.trgt.test_fov_show=false
	g.tbl.ge.trgt.test_fov=og_menu_add_feature("Show  fov box HIDDEN", "toggle", g.tbl.ge.trgt.fov_prnt.id,function(f)
		if g.var.GS_has_loaded then
			local time = TIME_MS() + 3000
			local fov_time = TIME_MS()-1
			while time > TIME_MS() do
				if g.tbl.ge.trgt.test_fov_show then
					g.tbl.ge.trgt.test_fov_show=false
					time = TIME_MS() + 3000
					fov_time = TIME_MS() + 3000
				end
				if fov_time > TIME_MS() then
					g.tbl.ge.trgt.show_fov_box(mth.flr((fov_time-TIME_MS()) /3000*g.tbl.ge.trgt.box_a.value))
				end
				YIELD(5)
			end
		end
		f.on=false
	end)
	g.tbl.ge.trgt.test_fov.hidden=true
	g.tbl.ge.trgt.fov_show.on=true

	function g.tbl.ge.trgt.show_fov_box(alpha)
		if g.tbl.ge.trgt.fov_show.on then
			alpha = alpha or g.tbl.ge.trgt.box_a.value
			local x_size,y_size,color = g.tbl.ge.trgt.fov_x.value*0.01, g.tbl.ge.trgt.fov_y.value*0.01,funcs.get.rgba_to_int(g.tbl.ge.trgt.box_r.value,g.tbl.ge.trgt.box_g.value,g.tbl.ge.trgt.box_b.value,alpha)
			API.SD.draw_line(funcs.vec(-x_size,y_size),funcs.vec(x_size,y_size), 1, color)
			API.SD.draw_line(funcs.vec(x_size,y_size),funcs.vec(x_size,-y_size), 1, color)
			API.SD.draw_line(funcs.vec(x_size,-y_size),funcs.vec(-x_size,-y_size), 1, color)
			API.SD.draw_line(funcs.vec(-x_size,-y_size),funcs.vec(-x_size,y_size), 1,color)
		end
	end

g.tbl.ge.delay=menu_add_feature("Gee-Eye fire-rate delay (ms)","autoaction_value_i",g.prnt.self_weapons_ge.id)
funcs.set_feat_i_f(g.tbl.ge.delay,25,500,25,100,"g.tbl.ge.delay")

g.tbl.ge.spread=menu_add_feature("Gee-Eye spread","autoaction_slider",g.prnt.self_weapons_ge.id)
funcs.set_feat_i_f(g.tbl.ge.spread,25,1000,25,25,"g.tbl.ge.spread")

g.tbl.ge.spread_type=menu_add_feature("Gee-Eye spread type","autoaction_value_str",g.prnt.self_weapons_ge.id)
new_set_str_data(g.tbl.ge.spread_type,{"Circular", "Horizontal", "Vertical"})
funcs.add_to_S_L(g.tbl.ge.spread_type,"g.tbl.ge.spread_type")

g.tbl.ge.blame=menu_add_feature("Gee-Eye blame","autoaction_value_str",g.prnt.self_weapons_ge.id)
new_set_str_data(g.tbl.ge.blame,{"Me", "No-One"})
funcs.add_to_S_L(g.tbl.ge.blame,"g.tbl.ge.blame")

g.tbl.ge.vis=menu_add_feature("Gee-Eye visible?","autoaction_value_str",g.prnt.self_weapons_ge.id)
new_set_str_data(g.tbl.ge.vis,{"False", "True"})
funcs.add_to_S_L(g.tbl.ge.vis,"g.tbl.ge.vis")

g.tbl.ge.aud=menu_add_feature("Gee-Eye audible?","autoaction_value_str",g.prnt.self_weapons_ge.id)
new_set_str_data(g.tbl.ge.aud,{"False", "True"})
funcs.add_to_S_L(g.tbl.ge.aud,"g.tbl.ge.aud")

g.tbl.ge.slct_key1=og_menu_add_feature("Key1 for Gee-Eye HIDDEN","autoaction_value_str",g.prnt.self_weapons_ge.id)
g.tbl.ge.slct_key1:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.tbl.ge.slct_key1,"g.tbl.ge.slct_key1")
g.tbl.ge.slct_key1.hidden=true
g.tbl.ge.slct_key1.value=23

menu_add_feature("Set key for Gee-Eye","action",g.prnt.self_weapons_ge.id,function()
	funcs.doo.set_keybinds(1,"Gee-Eye",g.tbl.ge.slct_key1)
end)


g.tbl.ge.flare_feat=menu_add_feature("Gee-Flare","slider",g.prnt.self_weapons_ge_gf.id,function(f) --GTA will only display 5 flares you shoot. I tried making flares anonymous but this bypasses the 5 flare limit and can cause you to crash
	if funcs.is.GS_loaded() and f.on then
		g.N_P(2,"Press "..inputs.vk_list[g.tbl.ge.flare_key_slct.value+1].." to shoot Gee-Flare",__GV__,7,"Blue")
	end
	local delay_table={750,650,550,450,350,250}
	local v3_start,v3_end = v3(),v3()
	while f.on do
		YIELD(0)
		f.name="Gee-Flare ("..inputs.vk_list[g.tbl.ge.flare_key_slct.value+1]..")"
		while funcs.is.vk_key_down(inputs.vk_list[g.tbl.ge.flare_key_slct.value+1]) and not ntv.is.chat_active() do
			YIELD(0)
			API.wpn.ped_give_comp(API.plyr.get.ped(API.plyr.my_id()),1198879012, 1000)
			v3_start,v3_end = funcs.get.GE_calc(false)
			if API.cntrl.get.normal(0,25)==0.0 then
				gameplay.shoot_single_bullet_between_coords(v3_start, v3_end, 1, 1198879012, API.plyr.get.ped(API.plyr.my_id()), true, false, 1000)
				funcs.doo.delay(delay_table[f.value])
			end
		end
	end
	f.name="Gee-Flare"
end)
funcs.set_feat_i_f(g.tbl.ge.flare_feat,1,6,1,1,"g.tbl.ge.flare_feat")

g.tbl.ge.flare_key_slct=og_menu_add_feature("Key1 for Gee-Flare HIDDEN","autoaction_value_str",g.prnt.self_weapons_ge_gf.id)
g.tbl.ge.flare_key_slct:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g.tbl.ge.flare_key_slct,"g.tbl.ge.flare_key_slct")
g.tbl.ge.flare_key_slct.hidden=true
g.tbl.ge.flare_key_slct.value=63

menu_add_feature("Set key for Gee-Flare","action",g.prnt.self_weapons_ge_gf.id,function()
	funcs.doo.set_keybinds(1,"Gee-Flare",g.tbl.ge.flare_key_slct)
end)

g.tbl.veh_gun={}

g.tbl.veh_gun.prnt=menu_add_feature("Vehicle gun", "parent", g.prnt.self_weapons.id)

g.tbl.veh_gun.feat=menu_add_feature("Weaponize nearby vehicles", "value_str", g.tbl.veh_gun.prnt.id, function(f)
	if f.on and funcs.is.GS_loaded() then
		g.N_P(2,"When shooting, nearby vehicles will launch at the target",__GV__,4,"Blue")
	end
	local continue,pos,all_veh,count,aim_ent,bypass,veh
	local function _ign_ent()
		if funcs.ME._in_veh() then
			return API.plyr.get.veh(API.plyr.my_id())
		end
		return API.plyr.get.ped(API.plyr.my_id())
	end
	local function in_grid(my_pos,ent_pos,_max)
		if mth.abs(my_pos.x - ent_pos.x) > _max or mth.abs(my_pos.y - ent_pos.y) > _max or mth.abs(my_pos.z - ent_pos.z) > _max then
			return false
		end
		return true
	end
	local function good_ent(_ent)
		if funcs.is.ent(_ent) and _ent ~= _ign_ent() and not in_grid(API.plyr.get.coords(API.plyr.my_id()),API.ent.get.coords(_ent),10) then
			if f.value == 2 then
				if API.ent.is.ped(_ent) and API.Ped.is.in_veh(_ent) then return true, API.Ped.get.veh(_ent)
				elseif API.ent.is.veh(_ent) then return true, _ent end
				return true, nil
			elseif API.ent.is.ped(_ent) then
				if f.value == 1 then
					if API.Ped.is.in_veh(_ent) then return API.Ped.is.plyr(_ent), API.Ped.get.veh(_ent) end
					return API.Ped.is.plyr(_ent), nil
				end
				if API.Ped.is.in_veh(_ent) then return true, API.Ped.get.veh(_ent)	end
				return true, nil
			end
		end
		return false, nil
	end
	local function get_pos_ent()
		local good,ent,skip,target_pos
		ent=API.plyr.get.aim_at(API.plyr.my_id())
		good, skip = good_ent(ent)
		if good then return true, API.ent.get.coords(ent), skip, ent end
		if f.value == 2 then
			good,target_pos = API.Ped.get.last_weap_impact(API.plyr.get.ped(API.plyr.my_id()))
			if good and not in_grid(API.plyr.get.coords(API.plyr.my_id()),target_pos,10) then return true, target_pos, nil, nil end
		end
		good,target_pos,ent = funcs.get.ray_vctr_all()
		if good then
			good, skip = good_ent(ent)
			if good then return true, API.ent.get.coords(ent), skip, ent end
			if f.value == 2 and not in_grid(API.plyr.get.coords(API.plyr.my_id()),target_pos,10) then return true, target_pos,nil, nil end
		end
		return false,nil,nil, nil
	end
	local function good_veh(_veh)
		if _veh ~= bypass and not API.veh.get.been_owned(_veh) then
			if g.tbl.veh_gun.type.value == 3 and _veh == veh then
				return false
			end
			return true
		end
		return false
	end
	while f.on do
		YIELD(0)
		if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then
			continue,pos,bypass,aim_ent = get_pos_ent()
			if continue then
				all_veh = API.veh.get.all()
				if g.tbl.veh_gun.select.value == 0 then
					funcs.sort.ent_pos_v3(all_veh,pos)
				else
					funcs.sort.ent_pos_v3(all_veh,API.plyr.get.coords(API.plyr.my_id()))
				end
				count =0
				for i=1,#all_veh do
					if count == 5 then
						break
					elseif good_veh(all_veh[i]) and funcs.ntwrk.ask_long(all_veh[i],25) then
						veh = all_veh[i]
						count=count+1
						if funcs.is.ent(aim_ent) then pos = API.ent.get.coords(aim_ent) end
						if g.tbl.veh_gun.type.value == 0 then
							API.ent.set.coords(all_veh[i],pos+v3(mth.rndm(-mth.flr(g.tbl.veh_gun.spwn_rng.value*.5),mth.flr(g.tbl.veh_gun.spwn_rng.value*.5)),mth.rndm(mth.flr(-g.tbl.veh_gun.spwn_rng.value*.5),mth.flr(g.tbl.veh_gun.spwn_rng.value*.5)),g.tbl.veh_gun.spwn_rng.value))
						elseif g.tbl.veh_gun.type.value == 1 then
							API.ent.set.coords(all_veh[i],pos+v3(mth.rndm(-g.tbl.veh_gun.spwn_rng.value,g.tbl.veh_gun.spwn_rng.value),mth.rndm(-g.tbl.veh_gun.spwn_rng.value,g.tbl.veh_gun.spwn_rng.value),mth.rndm(0,mth.flr(g.tbl.veh_gun.spwn_rng.value*.5))))
						elseif g.tbl.veh_gun.type.value == 3 then
							API.ent.set.coords(all_veh[i],funcs.get.front_of_pos(API.plyr.get.coords(API.plyr.my_id()), API.plyr.get.heading(API.plyr.my_id()), 5+(g.tbl.veh_gun.safe_zone.value*.5), 180, 0))
						end
						API.veh.set.out_of_control(all_veh[i], true, true)
						API.ent.set.rotation(all_veh[i], funcs.get.vctr_to_pos(pos,all_veh[i]))
						API.ent.set.coords(all_veh[i],API.ent.get.coords(all_veh[i]))
						API.veh.set.forward_speed(all_veh[i],g.tbl.veh_gun.veh_speed.value)
						if g.tbl.veh_gun.type.value == 3 then
							funcs.doo.delay(mth.flr(g.tbl.veh_gun.delay.value/2))
							count=5
						else
							funcs.doo.delay(mth.flr(g.tbl.veh_gun.delay.value/10))
						end
					end
				end
				funcs.doo.delay(g.tbl.veh_gun.delay.value)
			end
		end
	end
end)
new_set_str_data(g.tbl.veh_gun.feat,{"Shooting any ped", "Shooting a player","Shooting anything"})
funcs.add_to_S_L(g.tbl.veh_gun.feat,"g.tbl.veh_gun.feat")

g.tbl.veh_gun.type=menu_add_feature("Select type", "action_value_str", g.tbl.veh_gun.prnt.id)
new_set_str_data(g.tbl.veh_gun.type,{"Spawn on top", "Spawn all around","Fly in","Bullets"})
funcs.add_to_S_L(g.tbl.veh_gun.type,"g.tbl.veh_gun.type")

g.tbl.veh_gun.spwn_rng=menu_add_feature("Spawn range", "action_value_i", g.tbl.veh_gun.prnt.id)
funcs.set_feat_i_f(g.tbl.veh_gun.spwn_rng,5,25,1,10,"g.tbl.veh_gun.spwn_rng")

g.tbl.veh_gun.safe_zone=menu_add_feature("Safe zone size", "action_value_i", g.tbl.veh_gun.prnt.id)
funcs.set_feat_i_f(g.tbl.veh_gun.safe_zone,5,50,1,10,"g.tbl.veh_gun.safe_zone")

g.tbl.veh_gun.delay=menu_add_feature("Artificial delay (ms)", "action_value_i", g.tbl.veh_gun.prnt.id)
funcs.set_feat_i_f(g.tbl.veh_gun.delay,50,250,25,125,"g.tbl.veh_gun.delay")

g.tbl.veh_gun.select=menu_add_feature("Use vehicles", "action_value_str", g.tbl.veh_gun.prnt.id)
new_set_str_data(g.tbl.veh_gun.select,{"Closest to target", "Closest to me"})
funcs.add_to_S_L(g.tbl.veh_gun.select,"g.tbl.veh_gun.select")

g.tbl.veh_gun.veh_speed=menu_add_feature("Vehicle speed", "action_value_i", g.tbl.veh_gun.prnt.id)
funcs.set_feat_i_f(g.tbl.veh_gun.veh_speed,25,500,25,100,"g.tbl.veh_gun.veh_speed")

g.prnt.magic_bullets=menu_add_feature("Magic Bullets", "parent", g.prnt.self_weapons.id)




function funcs.is.magic_bullet_ped(_ped,me,my_ped,target_value,friends_value,orgmc_value)
	if _ped == my_ped then
		return false
	end
	if API.Ped.is.plyr(_ped) then
		if target_value == 1 then
			return false
		end
		local pid = API.plyr.get.plyr_from_ped(_ped)
		if glbls.is_pid_passive(pid) then
			return false
		end
		if friends_value == 0 and API.plyr.is.friend(pid) then
			return false
		end
		if orgmc_value == 0 and funcs.is.same_orgmc(me,pid) then
			return false
		end
	elseif target_value == 0 then
		return false
	end
	return true
end

function funcs.is.magic_bullet_aim(_ped,ped_coords,my_ped,aim_ent,direction_value,los_value)
	if los_value == 0 and not ntv.is.ents_in_los(my_ped,_ped,17,true) then
		return false
	end
	local screen_pos = funcs.get.screen_pos_3d(ped_coords)
	if not screen_pos then
		return false
	end
	if direction_value == 0 then
		if aim_ent ~= _ped and not funcs.is.in_grid_ratio_square(screen_pos,funcs.vec(0,0),0.05) then
			return false
		end
	end
	return true
end

g.feat.magic_bullets=menu_add_feature("Enable", "toggle", g.prnt.magic_bullets.id, function(f)
	local all_peds,aiming_value,my_ped,me,is_plyr,target_value,friends_value,orgmc_value,direction_value,los_value,aim_ent,my_weap,have_shot,invisible,audible
    while f.on do
		aiming_value = g.feat.magic_bullets_trigger.value
		me = API.plyr.my_id()
		my_ped = API.plyr.get.ped(me)
		if aiming_value == 2 or API.Ped.is.shooting(my_ped) or (aiming_value == 1 and funcs.ME._aim(me)) then
			all_peds = API.Ped.get.all()
			target_value=g.feat.magic_bullets_target.value
			friends_value = g.feat.magic_bullets_friends.value
			orgmc_value = g.feat.magic_bullets_orgmc.value
			direction_value=g.feat.magic_bullets_direction.value
			los_value=g.feat.magic_bullets_los.value
			aim_ent = API.plyr.get.aim_at(me)
			my_weap = API.Ped.get.weapon(my_ped)
			invisible = g.feat.magic_bullets_invisible.value==1
			audible = g.feat.magic_bullets_silent.value==0
			have_shot = false
			for k,v in pairs(all_peds) do
				if not API.ent.is.dead(v) then
					if funcs.is.magic_bullet_ped(v,me,my_ped,target_value,friends_value,orgmc_value) then
						ped_coords = API.ent.get.coords(v)
						if funcs.is.magic_bullet_aim(v,ped_coords,my_ped,aim_ent,direction_value,los_value) then
							have_shot=true
							gameplay.shoot_single_bullet_between_coords(ped_coords+funcs.vec(mth.rndm(-10,10)*0.01,mth.rndm(-10,10)*0.01,0.5),
							ped_coords, 1000, my_weap, my_ped, audible, invisible, 1000)
						end
					end
				end
			end
			if have_shot then
				YIELD(g.feat.magic_bullets_delay.value)
			end
		end
		YIELD(0)
	end
end)
funcs.add_to_S_L(g.feat.magic_bullets,"g.feat.magic_bullets")

g.feat.magic_bullets_target=menu_add_feature("Targets", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_target,{"Players", "Peds", "Peds & players"})
funcs.add_to_S_L(g.feat.magic_bullets_target,"g.feat.magic_bullets_target")

g.feat.magic_bullets_friends=menu_add_feature("My Friends", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_friends,{"Exclude", "Include"})
funcs.add_to_S_L(g.feat.magic_bullets_friends,"g.feat.magic_bullets_friends")

g.feat.magic_bullets_orgmc=menu_add_feature("My ORG/MC", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_orgmc,{"Exclude", "Include"})
funcs.add_to_S_L(g.feat.magic_bullets_orgmc,"g.feat.magic_bullets_orgmc")

g.feat.magic_bullets_silent=menu_add_feature("Silent", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_silent,{"False", "True"})
funcs.add_to_S_L(g.feat.magic_bullets_silent,"g.feat.magic_bullets_silent")

g.feat.magic_bullets_invisible=menu_add_feature("Invisible", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_invisible,{"False", "True"})
funcs.add_to_S_L(g.feat.magic_bullets_invisible,"g.feat.magic_bullets_invisible")

g.feat.magic_bullets_trigger=menu_add_feature("Trigger", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_trigger,{"Shooting", "Aiming", "Always"})
funcs.add_to_S_L(g.feat.magic_bullets_trigger,"g.feat.magic_bullets_trigger")

g.feat.magic_bullets_direction=menu_add_feature("Aim filter", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_direction,{"Who I aim at", "Anywhere on screen"})
funcs.add_to_S_L(g.feat.magic_bullets_direction,"g.feat.magic_bullets_direction")

g.feat.magic_bullets_los=menu_add_feature("Line of sight", "action_value_str", g.prnt.magic_bullets.id)
new_set_str_data(g.feat.magic_bullets_los,{"Required", "Not required"})
funcs.add_to_S_L(g.feat.magic_bullets_los,"g.feat.magic_bullets_los")

g.feat.magic_bullets_delay=menu_add_feature("Delay (ms)", "action_value_i", g.prnt.magic_bullets.id)
funcs.set_feat_i_f(g.feat.magic_bullets_delay,25,500,25,100,"g.feat.magic_bullets_delay")

g.feat.sniper_enhnc_strafe=menu_add_feature("Enhanced sniper strafe speed", "value_i", g.prnt.self_weapons.id, function(f) -- i made this before i knew about the rad/deg math
	local me_id,my_ped,pos,heading,left,right,decimals,north,north_head,count,south_head,west,west_head,east,east_head,force_mod,x_force,y_force
    while f.on do
		YIELD(0)
		me_id=API.plyr.my_id()
		my_ped = API.plyr.get.ped(me_id)
		if funcs.is.key_active(114,1) and not funcs.ME._in_veh() and weap_info.sniper_true[API.Ped.get.weapon(my_ped)] then
			pos=API.plyr.get.coords(API.plyr.my_id())
			heading=API.plyr.get.heading(me_id)
			left,right=false,false
			if funcs.is.key_active(34,1) then
				heading=heading+95
				if heading > 180 then
					heading = heading - 360
				end
				left=true
			elseif funcs.is.key_active(35,1) then
				right=true
				heading=heading-95
				if heading < -180 then
					heading = heading + 360
				end
			end
			if left or right then
				north=0
				if (heading >= -90) and (heading <= 90) then
					north_head=mth.abs(heading)
					decimals=north_head-mth.flr(north_head)
					north_head=mth.flr(north_head)
					count=90
					for i=1, north_head do
						if 	north_head == i then
							north=count/90
							north=north+decimals
						else
							count=count-1
						end
					end
				end
				south=0
				if (heading <= -90) or (heading >= 90) then
					south_head=mth.abs(heading)
					south_head=south_head-90
					south=south_head/90
				end
				west=0
				if (heading >= 0) and (heading <= 180) then
					if heading >=90 then
						decimals=heading-mth.flr(heading)
						west_head=mth.flr(heading)
						count=90
						for i=90, west_head do
							if 	west_head == i then
								west=count/90
								west=west+decimals
							else
								count=count-1
							end
						end
					else
						west=heading/90
					end
				end
				east=0
				if (heading <= 0) and (heading >= -180) then
					east_head=mth.abs(heading)
					if east_head >=90 then
						decimals=east_head-mth.flr(east_head)
						east_head=mth.flr(east_head)
						count=90
						for i=90, east_head do
							if 	east_head == i then
								east=count/90
								east=east+decimals
							else
								count=count-1
							end
						end
					else
						east=east_head/90
					end
				end
				south=south*-1
				west=west*-1
				force_mod=f.value+3
				force_mod=force_mod*.069 --nice
				x_force=west+east
				x_force=x_force*force_mod
				y_force=north+south
				y_force=y_force*force_mod
				if left then
					while funcs.is.key_active(34,1) do
						YIELD(0)
						API.ent.force(my_ped, 1, x_force,y_force,0.001, 0,0,0, false, true)
					end
				elseif right then
					while funcs.is.key_active(35,1) do
						YIELD(0)
						API.ent.force(my_ped, 1, x_force,y_force,0.001, 0,0,0, false, true)
					end
				end
				YIELD(100)
			end
		end
	end
end)
funcs.set_feat_i_f(g.feat.sniper_enhnc_strafe,1,15,1,1,"g.feat.sniper_enhnc_strafe")

g.feat.sniper_enhnc_zoom=menu_add_feature("Auto sniper zoom %", "value_i", g.prnt.self_weapons.id, function(f)
	local time = TIME_MS()
    while f.on do
		YIELD(0)
		time = TIME_MS()
		while funcs.is.key_active(114,1) and not funcs.ME._in_veh() and weap_info.sniper_true[API.Ped.get.weapon(API.plyr.get.ped(API.plyr.my_id()))] do
			YIELD(0)
			if TIME_MS() - time <= f.value/100*2000 then
				controls.set_control_normal(0,40, 1.0)
				controls.set_control_normal(0,42, 1.0)
				controls.set_control_normal(0,274, 1.0)
				controls.set_control_normal(0,276, 1.0)
			end
		end
	end
end)
funcs.set_feat_i_f(g.feat.sniper_enhnc_zoom,10,100,10,100,"g.feat.sniper_enhnc_zoom")

g.feat.bullets_hijack=menu_add_feature("Hijack driver bullets", "toggle", g.prnt.self_weapons.id, function(f)
	while f.on do
		YIELD(0)
		funcs.doo.bullets("hijack")
	end
end)
funcs.add_to_S_L(g.feat.bullets_hijack,"g.feat.bullets_hijack")

g.feat.bullets_orbital=menu_add_feature("Orbital cannon bullets", "value_str", g.prnt.self_weapons.id, function(f)
	while f.on do
		YIELD(0)
		funcs.doo.bullets("orbital",f.value)
	end
end)
funcs.add_to_S_L(g.feat.bullets_orbital,"g.feat.bullets_orbital")
new_set_str_data(g.feat.bullets_orbital,{"Shooting entity","Shooting anything"})

function funcs.doo.bullets(_action,_val)
	local my_ped = API.plyr.get.ped(API.plyr.my_id())
	if API.Ped.is.shooting(my_ped) then
		local aim_ent=API.plyr.get.aim_at(API.plyr.my_id())
		if _action == "orbital" then
			if not weap_info.veh.obj[ntv.get.ped_veh_weap(my_ped)] and not weap_info.hand.obj[funcs.ME._weap()] then
				if _val == 0 then
					if funcs.is.ent(aim_ent) then
						funcs.doo.orb_explo_ptfx_n_audio(funcs.get.ent_vel_pos(aim_ent,0.1),my_ped)
					end
				else
					local good,target_pos = API.Ped.get.last_weap_impact(my_ped)
					target_pos = good and target_pos or nil
					if not target_pos then
						if weap_info.veh.type[ntv.get.ped_veh_weap(my_ped)] == "MG" then
							local my_veh = funcs.ME._veh()
							local veh_hash = API.ent.get.model_hash(my_veh)
							local rot = API.ent.get.rotation(my_veh)
							if weap_info.veh.mg_pitch_ofst[veh_hash] ~= nil then
								rot.x=rot.x+weap_info.veh.mg_pitch_ofst[veh_hash]
							end
							good,target_pos = funcs.get.ray_vctr_all(nil,false,funcs.ME._veh_crds(),rot)
						else
							good,target_pos = funcs.get.ray_vctr_all(nil,false)
						end
						target_pos = good and target_pos or nil
					end
					if target_pos then
						funcs.doo.orb_explo_ptfx_n_audio(target_pos,my_ped)
					end
				end
			end
		else
			if funcs.is.veh(aim_ent) then
				if _action == "fuck" then
					funcs.doo.veh_fuck(aim_ent, 1000)
				elseif  _action == "hijack" then
					funcs.doo.veh_tp_into_hijack(aim_ent,false)
				end
			elseif API.ent.is.ped(aim_ent) and API.Ped.is.in_veh(aim_ent) then
				if funcs.is.veh(API.Ped.get.veh(aim_ent)) then
					if _action == "fuck" then
						funcs.doo.veh_fuck(API.Ped.get.veh(aim_ent), 1000)
					elseif  _action == "hijack" then
						funcs.doo.veh_tp_into_hijack(API.Ped.get.veh(aim_ent),true)
					elseif  _action == "veh_kick" then
						funcs.doo.kick_all_from_veh(API.Ped.get.veh(aim_ent),_val)
					end
				end
			end
			if API.ent.is.ped(aim_ent) and API.Ped.is.plyr(aim_ent) then
				if _action == "cayo" then
					glbls.send_to_cayo(API.plyr.get.plyr_from_ped(aim_ent))
					YIELD(500)
				elseif _action == "bounty" then
					glbls.give_bounty(API.plyr.get.plyr_from_ped(aim_ent),_val)
					YIELD(500)
				elseif _action == "wanted" then
					funcs.doo.wntd_all_psngrs(API.plyr.get.plyr_from_ped(aim_ent),_val)
					YIELD(500)
				end
			end
		end
	end
end

g.feat.bullets_fuck=menu_add_feature("Fuck vehicle bullets", "toggle", g.prnt.self_weapons.id, function(f)
	while f.on do
		YIELD(0)
		funcs.doo.bullets("fuck")
	end
end)
funcs.add_to_S_L(g.feat.bullets_fuck,"g.feat.bullets_fuck")


--patched in 1.67
-- g.feat.bullets_cp=menu_add_feature("Cayo Perico bullets", "toggle", g.prnt.self_weapons.id, function(f)--------------
	-- while f.on do
		-- YIELD(0)
		-- funcs.doo.bullets("cayo")
	-- end
-- end)
-- funcs.add_to_S_L(g.feat.bullets_cp,"g.feat.bullets_cp")

g.feat.bullets_bounty=menu_add_feature("Bounty bullets (anonymous)", "value_str", g.prnt.self_weapons.id, function(f)--------------
	while f.on do
		YIELD(0)
		local bounty = 0
		if f.value == 0 then bounty = 10000
		elseif f.value == 1 then bounty = 9000
		elseif f.value == 2 then bounty = 8000
		elseif f.value == 3 then bounty = 7000
		elseif f.value == 4 then bounty = 6000
		elseif f.value == 5 then bounty = 5000
		elseif f.value == 6 then bounty = 4000
		elseif f.value == 7 then bounty = 3000
		elseif f.value == 8 then bounty = 2000
		elseif f.value == 9 then bounty = 1000
		elseif f.value == 10 then bounty = 666
		elseif f.value == 11 then bounty = 420
		elseif f.value == 12 then bounty = 69
		elseif f.value == 13 then bounty = 1
		end
		funcs.doo.bullets("bounty",bounty)
	end
end)
g.feat.bullets_bounty:set_str_data({"$10,000", "$9,000","$8,000","$7,000","$6,000","$5,000","$4,000","$3,000","$2,000","$1,000", "$666", "$420","$69","$1",})
funcs.add_to_S_L(g.feat.bullets_bounty,"g.feat.bullets_bounty")

g.feat.bullets_veh_kick=menu_add_feature("Vehicle kick bullets", "value_str", g.prnt.self_weapons.id, function(f)
	while f.on do
		YIELD(0)
		funcs.doo.bullets("veh_kick",f.value==1)
	end
end)
new_set_str_data(g.feat.bullets_veh_kick,{"Everyone", "Exclude Friends"})
funcs.add_to_S_L(g.feat.bullets_veh_kick,"g.feat.bullets_veh_kick")

g.feat.bullets_wanted=menu_add_feature("Wanted level bullets", "value_i", g.prnt.self_weapons.id, function(f)--------------
	while f.on do
		YIELD(0)
		funcs.doo.bullets("wanted",f.value)
	end
end)
funcs.set_feat_i_f(g.feat.bullets_wanted,0,5,1,5,"g.feat.bullets_wanted")

g.feat.minecraft = menu_add_feature("Minecraft Gun", "value_str", g.prnt.self.id, function(f)
	local bool, pos,temp_block,time,was_shooting
    local spawned_blocks = {}
    local sandblocks = {
        API.get_hash_key("prop_mb_sandblock_01"),
        API.get_hash_key("prop_mb_sandblock_02"),
        API.get_hash_key("prop_mb_sandblock_03_cr"),
        API.get_hash_key("prop_mb_sandblock_04"),
        API.get_hash_key("prop_mb_sandblock_05_cr")
    }
	local block = sandblocks[f.value + 1]
    while f.on do
		if API.Ped.is.shooting(player.player_ped()) then
			bool, pos = funcs.get.ray_vctr_all(temp_block)
			if bool then
				block = sandblocks[f.value + 1]
				funcs.doo.req_model(block)
				temp_block=funcs.doo.spawn_obj(block, pos)
				streaming.set_model_as_no_longer_needed(block)
				time = TIME_MS() + 200
				while time > TIME_MS() do
					YIELD(0)
				end
				spawned_blocks[#spawned_blocks + 1] = temp_block
				temp_block = nil
			end
		end
		while f.on and API.plyr.is.aim(API.plyr.my_id()) do
			if block ~= sandblocks[f.value + 1] then
				funcs.doo.remove_ent_in_thread(temp_block,5000)
				temp_block=nil
				block = sandblocks[f.value + 1]
			end
			bool, pos = funcs.get.ray_vctr_all(temp_block)
			if bool then
				if temp_block == nil then
					funcs.doo.req_model(block)
					temp_block=funcs.doo.spawn_obj(block, pos)
					streaming.set_model_as_no_longer_needed(block)
				elseif API.Ped.is.shooting(player.player_ped()) then
					time = TIME_MS() + 200
					while API.plyr.is.aim(API.plyr.my_id()) and time > TIME_MS() do
						YIELD(0)
					end
					spawned_blocks[#spawned_blocks + 1] = temp_block
					temp_block = nil
				else
					API.ent.set.coords(temp_block,pos)
				end
			end
			YIELD(0)
		end
		funcs.doo.remove_ent_in_thread(temp_block,5000)
		temp_block=nil
        YIELD(0)
    end
	for k,v in pairs(spawned_blocks) do
		funcs.doo.remove_ent_in_thread(v,5000)
	end
end)
new_set_str_data(g.feat.minecraft,{"Singlular", "Row of 3", "Stacked Row of 3", "Corner", "Dead-end"})


-----------------------------------------------------------------------------------------GEE-SKID
---------------------------------------------------------------------------------------------SELF
-----------------------------------------------------------------------------------CurrentVehicle
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------


g.tbl.mk2 = {}



g.tbl.mk2.feat=menu_add_feature("Inverted flight","value_str",g.prnt.self_veh_crrnt_mk2.id,function(f)
	local _shift,_ctrl,_a,_d
	local pitch,roll,yaw = 0,0,0
	local pitch_spd,roll_spd,yaw_spd = 1,1,1
	local pitch_max,roll_max,yaw_max = 25,25,25
	local Table_spd = {}
	local table_int,speed_do = 0,false
	local time = TIME_MS()
	for i=1,3 do
		Table_spd[i]={0,0}
	end
	local do_once=false
	local function range_of_1_to_3(_int,_offset)
		if _int - _offset < 1 then
			return _int - _offset + 3
		end
		return _int - _offset
	end
	local function math_neg(_val,_max,_spd)
		if _val > -_max then
			if _val >= 0 then return (_val - (.269*2*_spd))*.99
			else return (_val - (.269*2*_spd))*1.01
			end
		else return -_max
		end
	end
	local function math_pos(_val,_max,_spd)
		if _val < _max then
			if _val >= 0 then return (_val + (.269*2*_spd))*1.01
			else return (_val + (.269*2*_spd))*.99
			end
		else return _max
		end
	end
	local function to_zero(_val,_spd)
		if _val > 0 then return (_val - (.269*2*_spd))*.99
		else return (_val + (.269*2*_spd))*.99
		end
	end
	local function maths(_val,_input1,_input2,_max,_spd)
		if (funcs.is.key_active(_input1,0) or funcs.is.key_active(_input2,0)) and (funcs.is.key_active(_input1,1) or funcs.is.key_active(_input2,1)) then
			if funcs.is.key_active(_input1,1) then return math_neg(_val,_max,_spd)
			else return math_pos(_val,_max,_spd)
			end
		else return to_zero(_val,_spd)
		end
	end
	while f.on do
		YIELD(250)
		time = TIME_MS()
		do_once=false---------
		if funcs.ME._in_veh() and funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"oppressor2") and not funcs.is.dead(API.plyr.get.veh(API.plyr.my_id())) then
			funcs.doo.tp_ent(API.plyr.get.veh(API.plyr.my_id()),API.plyr.get.coords(API.plyr.my_id()), 2.5 ,false)
			while f.on and funcs.ME._in_veh() and not funcs.is.dead(API.plyr.get.veh(API.plyr.my_id())) do
				YIELD(0)
				if time+200 < TIME_MS() then
					if table_int == 3 then
						table_int = 1
					else
						table_int = table_int + 1
					end
					Table_spd[table_int][1] = API.ent.get.speed(API.plyr.get.veh(API.plyr.my_id()))
					Table_spd[table_int][2] = funcs.get._1_dec(Table_spd[range_of_1_to_3(table_int,1)][1] - Table_spd[table_int][1])
					time = TIME_MS()
				end
				_shift,_ctrl,_a,_d = 88,87,63,64
				if f.value == 0 then
					_shift,_ctrl,_a,_d = 87,88,64,63
				end
				pitch_max,roll_max,yaw_max = g.tbl.mk2.pitch.value,g.tbl.mk2.roll.value,g.tbl.mk2.yaw.value
				pitch_spd,roll_spd,yaw_spd = g.tbl.mk2.pitch_speed.value,g.tbl.mk2.roll_speed.value,g.tbl.mk2.yaw_speed.value
				yaw = maths(yaw,_a,_d,yaw_max,yaw_spd)
				pitch = maths(pitch,_shift,_ctrl,pitch_max,pitch_spd)
				if (funcs.is.key_active(_a,0) or funcs.is.key_active(_d,0)) and (funcs.is.key_active(_a,1) or funcs.is.key_active(_d,1)) then
					if (funcs.is.key_active(_shift,0) or funcs.is.key_active(_ctrl,0)) and (funcs.is.key_active(_shift,1) or funcs.is.key_active(_ctrl,1)) then
						if funcs.is.key_active(_shift,1) then
							if funcs.is.key_active(_a,1) then
								roll = math_pos(roll,roll_max,roll_spd)
							else
								roll = math_neg(roll,roll_max,roll_spd)
							end
						elseif funcs.is.key_active(_a,1) then
							roll = math_neg(roll,roll_max,roll_spd)
						else
							roll = math_pos(roll,roll_max,roll_spd)
						end
					elseif funcs.is.key_active(_a,1) then
						roll = math_pos(roll,roll_max,roll_spd)
					else
						roll = math_neg(roll,roll_max,roll_spd)
					end
				else
					roll = to_zero(roll,roll_spd)
				end
				if g.tbl.mk2.boost.on then
					if Table_spd[1][2] > 0 and Table_spd[2][2] > 0 and Table_spd[3][2] > 0 and funcs.is.key_active(71,1) and funcs.is.key_active(72,0) then
						API.veh.set.forward_speed(API.plyr.get.veh(API.plyr.my_id()),API.ent.get.speed(API.plyr.get.veh(API.plyr.my_id()))*1.01)
					end
				end
				if 	funcs.is.key_active(_a,1) or funcs.is.key_active(_d,1) or funcs.is.num_in_range(yaw,-(yaw_max*1.25),-2) or funcs.is.num_in_range(yaw,2,(yaw_max*1.25)) or
					funcs.is.key_active(_shift,1) or funcs.is.key_active(_ctrl,1) or funcs.is.num_in_range(pitch,-(pitch_max*1.25),-2) or funcs.is.num_in_range(pitch,2,(pitch_max*1.25)) or
					funcs.is.num_in_range(roll,-(roll_max*1.25),-2) or funcs.is.num_in_range(roll,2,(roll_max*1.25)) then
					API.ent.set.rotation(API.plyr.get.veh(API.plyr.my_id()),v3(API.cam.get.rot().x*-1+pitch,180+roll,API.cam.get.rot().z+yaw))
				else
					API.ent.set.rotation(API.plyr.get.veh(API.plyr.my_id()),v3(API.cam.get.rot().x*-1,180,API.cam.get.rot().z))
					pitch,yaw,roll = 0,0,0
					if funcs.is.key_active(71,0) and funcs.is.key_active(72,0) then
						if g.tbl.mk2.brakes.on then
							API.ent.set.velocity(API.plyr.get.veh(API.plyr.my_id()),v3(
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).x*.99,
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).y*.99,
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).z*.4))
						else
							API.ent.set.velocity(API.plyr.get.veh(API.plyr.my_id()),v3(
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).x,
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).y,
							API.ent.get.velocity(API.plyr.get.veh(API.plyr.my_id())).z*.4)) --retarded glitch makes it go up in the air sometimes
						end
					end
				end
			end
		end
	end
end)
new_set_str_data(g.tbl.mk2.feat,{"Inverted controls", "Normal controls"})
funcs.add_to_S_L(g.tbl.mk2.feat,"g.tbl.mk2.feat")

g.tbl.mk2.brakes=menu_add_feature("Auto brakes","toggle",g.prnt.self_veh_crrnt_mk2.id)
funcs.add_to_S_L(g.tbl.mk2.brakes,"g.tbl.mk2.brakes")

g.tbl.mk2.boost=menu_add_feature("Smart torque boost","toggle",g.prnt.self_veh_crrnt_mk2.id)
funcs.add_to_S_L(g.tbl.mk2.boost,"g.tbl.mk2.boost")

g.tbl.mk2.pitch=menu_add_feature("Pitch max","action_value_i",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.pitch,5,50,1,25,"g.tbl.mk2.pitch")

g.tbl.mk2.roll=menu_add_feature("Roll max","action_value_i",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.roll,5,50,1,25,"g.tbl.mk2.roll")

g.tbl.mk2.yaw=menu_add_feature("Yaw max","action_value_i",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.yaw,5,50,1,25,"g.tbl.mk2.yaw")

g.tbl.mk2.pitch_speed=menu_add_feature("Pitch speed","action_value_f",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.pitch_speed,0.05,3,0.05,1,"g.tbl.mk2.pitch_speed")

g.tbl.mk2.roll_speed=menu_add_feature("Roll speed","action_value_f",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.roll_speed,0.05,3,0.05,1,"g.tbl.mk2.roll_speed")

g.tbl.mk2.yaw_speed=menu_add_feature("Yaw speed","action_value_f",g.prnt.self_veh_crrnt_mk2.id)
funcs.set_feat_i_f(g.tbl.mk2.yaw_speed,0.05,3,0.05,1,"g.tbl.mk2.yaw_speed")


-------------------------------------------------------------------------------GeeSkid Gee-flight
g.feat.veh_flight=menu_add_feature("Gee-Flight", "value_i", g.prnt.self_veh_crrnt.id, function(f)
	local my_veh
	local function release_it()
		if funcs.is.veh(my_veh) then
			API.ent.set.max_speed(my_veh, 45000)
			YIELD(20)
			funcs.doo.tp_ent(my_veh,API.ent.get.coords(my_veh), 0 ,true)
			my_veh=nil
		end
	end
	local move = v3()
	while f.on do
		if funcs.ME._driving(funcs.ME._veh()) then
			my_veh=funcs.ME._veh()
			while f.on and API.plyr.is.in_veh(funcs.ME._id()) and my_veh==funcs.ME._veh() do
				funcs.doo.veh_flight(my_veh,3,f.value,move)
				YIELD(0)
			end
			release_it()
		end
		YIELD(100)
	end
	release_it()
end)
funcs.set_feat_i_f(g.feat.veh_flight,50,5000,50,100,"g.feat.veh_flight")

g.feat.veh_xtra_jump=menu_add_feature("Vehicle extra jump height","toggle",g.prnt.self_veh_crrnt.id,function(f)
	while f.on do
		if API.plyr.is.in_veh(API.plyr.my_id()) and ntv.is.veh_can_jump(API.plyr.get.veh(API.plyr.my_id())) then
			ntv.set.veh_high_jump(API.plyr.get.veh(API.plyr.my_id()),1)
		end
		funcs.doo.yield_while_true(f.on,1000)
	end
	if API.plyr.is.in_veh(API.plyr.my_id()) and ntv.is.veh_can_jump(API.plyr.get.veh(API.plyr.my_id())) then
		ntv.set.veh_high_jump(API.plyr.get.veh(API.plyr.my_id()),0)
	end
end)
funcs.add_to_S_L(g.feat.veh_xtra_jump,"g.feat.veh_xtra_jump")

g.feat.lockon_explo = menu_add_feature("Insta-explode lock-on target", "value_str", g.prnt.self_veh_crrnt.id, function(f)
	local ent
	while f.on do
		ent = ntv.get.my_veh_lock_trgt()
		if funcs.is.ent(ent) and not API.ent.is.dead(ent) and not API.ent.get.god(ent) then
			if f.value==1 then
				funcs.doo.orb_explo_ptfx_n_audio(funcs.get.ent_vel_pos(ent,0.1),funcs.ME._ped())
			else
				fire.add_explosion(funcs.get.ent_vel_pos(ent,0.1), 0, true, false, 0, funcs.ME._ped())
			end
		end
		YIELD(100)
	end
end)
new_set_str_data(g.feat.lockon_explo,{"Simple", "Orbital"})
funcs.add_to_S_L(g.feat.lockon_explo,"g.feat.lockon_explo")

g.feat.veh_max_tint = menu_add_feature("Always max tint", "toggle", g.prnt.self_veh_crrnt.id, function(f)
	local my_tint,my_veh = nil
	while f.on do
		if funcs.ME._in_veh() then
			my_veh = funcs.ME._veh()
			if vehicle.get_vehicle_window_tint(my_veh) ~= 1 then
				my_tint = vehicle.get_vehicle_window_tint(my_veh)
				API.veh.set.kit_type(my_veh, 0) -- street cars need this
				vehicle.set_vehicle_window_tint(my_veh,1)
			end
		end
		YIELD(100)
	end
	if my_tint and funcs.is.veh(my_veh) then
		vehicle.set_vehicle_window_tint(my_veh,my_tint)
	end
end)
funcs.add_to_S_L(g.feat.veh_max_tint,"g.feat.veh_max_tint")

g.feat.veh_invncbl_wndws = menu_add_feature("Invincible windows", "toggle", g.prnt.self_veh_crrnt.id, function(f)
	ntv.set.veh_invncbl_wndws(API.plyr.get.veh(API.plyr.my_id()),1)
	while f.on do
		if funcs.ME._in_veh() then
			if not ntv.is.windows_good(API.plyr.get.veh(API.plyr.my_id())) and funcs.ntwrk.ask_long(API.plyr.get.veh(API.plyr.my_id()),1000) then
				API.veh.set.kit_type(API.plyr.get.veh(API.plyr.my_id()), 0)
				ntv.doo.fix_veh_wndws(API.plyr.get.veh(API.plyr.my_id()))
				ntv.set.veh_invncbl_wndws(API.plyr.get.veh(API.plyr.my_id()),1)
			end
		end
		funcs.doo.yield_while_true(f.on,1000)
	end
	if funcs.is.veh(API.plyr.get.veh(API.plyr.my_id())) and funcs.ntwrk.ask_long(API.plyr.get.veh(API.plyr.my_id()),1000) then
		ntv.set.veh_invncbl_wndws(API.plyr.get.veh(API.plyr.my_id()),0)
	end
end)
funcs.add_to_S_L(g.feat.veh_invncbl_wndws,"g.feat.veh_invncbl_wndws")

g.feat.veh_smsh_rpr_wndws=menu_add_feature("Windows", "action_value_str", g.prnt.self_veh_crrnt.id, function(f)
	local t = {"window_smash","window_repair"}
	funcs.doo.veh_current_do(t[f.value+1])
end)
new_set_str_data(g.feat.veh_smsh_rpr_wndws,{"Smash", "Repair"})
funcs.add_to_S_L(g.feat.veh_smsh_rpr_wndws,"g.feat.veh_smsh_rpr_wndws")

g._auto_flip_veh = menu_add_feature("Auto-Flip vehicle if needed", "toggle", g.prnt.self_veh_crrnt_auto.id, function(f)
	local in_veh=false
	while f.on do
		YIELD(50)
		if funcs.ME._in_veh() and (g._self_veh_auto_setting.value == 0 and funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id()))) or g._self_veh_auto_setting.value == 1 then
			if not in_veh then
				funcs.doo.veh_flip(API.plyr.get.veh(API.plyr.my_id()),"if_needed",1000) --flip vehicle upon entry
			end
			in_veh=true
			if funcs.is.my_veh_upside_down(API.plyr.get.veh(API.plyr.my_id())) then
				YIELD(777) --because i like 7
				if funcs.is.my_veh_upside_down(API.plyr.get.veh(API.plyr.my_id())) then
					YIELD(777)
					if funcs.is.my_veh_upside_down(API.plyr.get.veh(API.plyr.my_id())) then
						YIELD(777)
						funcs.doo.veh_flip(API.plyr.get.veh(API.plyr.my_id()),"if_needed",1000)
						funcs.doo.tp_ent(API.plyr.get.veh(API.plyr.my_id()),API.ent.get.coords(API.plyr.get.veh(API.plyr.my_id())), 0 ,true)
					end
				end
			end
		else
			in_veh=false
		end
	end
end)
funcs.add_to_S_L(g._auto_flip_veh,"g._auto_flip_veh")

g._self_veh_auto_upgrade=menu_add_feature("Auto-upgrade performance mods", "toggle", g.prnt.self_veh_crrnt_auto.id, function()
end)
funcs.add_to_S_L(g._self_veh_auto_upgrade,"g._self_veh_auto_upgrade")

g._self_veh_auto_force=menu_add_feature("Auto-upgrade speed/torque %","value_i",g.prnt.self_veh_crrnt_auto.id)
funcs.set_feat_i_f(g._self_veh_auto_force,105,200,5,120,"g._self_veh_auto_force")


g._self_veh_auto_repair=menu_add_feature("Auto-repair", "value_str", g.prnt.self_veh_crrnt_auto.id)
new_set_str_data(g._self_veh_auto_repair,{"Entry", "Exit", "Both"})
funcs.add_to_S_L(g._self_veh_auto_repair,"g._self_veh_auto_repair")

g._self_veh_auto_god=menu_add_feature("Auto-god", "value_str", g.prnt.self_veh_crrnt_auto.id, function(f)
	while f.on do
		if (g._self_veh_auto_setting.value == 0 and g.var.auto__am_i_the_driver) or g._self_veh_auto_setting.value == 1 then
			while f.on and funcs.ME._in_veh() do
				if not API.ent.get.god(funcs.ME._veh()) and funcs.ntwrk.ask_long(funcs.ME._veh(),3000) then
					API.ent.set.god(funcs.ME._veh(), true)
				end
				YIELD(250)
			end
			if f.value == 1 and funcs.ntwrk.ask_long(funcs.ME._veh(),3000) then
				API.ent.set.god(API.plyr.get.veh(API.plyr.my_id()), false)
			end
		end
		YIELD(250)
	end
	if funcs.ntwrk.ask_long(funcs.ME._veh(),3000) then
		API.ent.set.god(funcs.ME._veh(), false)
	end
end)
new_set_str_data(g._self_veh_auto_god,{"Give", "Remove on exit"})
funcs.add_to_S_L(g._self_veh_auto_god,"g._self_veh_auto_god")

g._self_veh_auto_kick=menu_add_feature("Auto-kick others from vehicle", "value_str", g.prnt.self_veh_crrnt_auto.id)
new_set_str_data(g._self_veh_auto_kick,{"Everyone", "Exclude Friends"})
funcs.add_to_S_L(g._self_veh_auto_kick,"g._self_veh_auto_kick")

g._self_veh_auto_setting=menu_add_feature("Only applies when in", "autoaction_value_str", g.prnt.self_veh_crrnt_auto.id)
new_set_str_data(g._self_veh_auto_setting,{"Driver seat", "Any Seat"})
funcs.add_to_S_L(g._self_veh_auto_setting,"g._self_veh_auto_setting")

g.var.auto__am_i_the_driver=false
g.tbl.my_veh_hist = {}
g._self_veh_auto_hidden=og_menu_add_feature("Auto-self veh do hidden", "toggle", g.prnt.self_veh_crrnt_auto.id, function(f)
	local last_do_once=false
	local current_do_once=false
	while f.on do
		YIELD(50)
		if funcs.ME._in_veh() then
			if #g.tbl.my_veh_hist == 0 then
				g.tbl.my_veh_hist[#g.tbl.my_veh_hist+1]=API.plyr.get.veh(API.plyr.my_id())
			elseif g.tbl.my_veh_hist[#g.tbl.my_veh_hist] ~= API.plyr.get.veh(API.plyr.my_id()) then
				g.tbl.my_veh_hist[#g.tbl.my_veh_hist+1]=API.plyr.get.veh(API.plyr.my_id())
			end
			last_do_once=false
			YIELD(50)
			g.var.auto__am_i_the_driver = funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id()))
			if not current_do_once and funcs.doo.self_veh_auto(g.tbl.my_veh_hist[#g.tbl.my_veh_hist]) then
				current_do_once=true
			end
		else
			YIELD(50)
			current_do_once=false
			if not last_do_once then
				if funcs.is.veh(g.tbl.my_veh_hist[#g.tbl.my_veh_hist]) then
					funcs.doo.record_clone_veh(g.tbl.veh_clone,g.tbl.my_veh_hist[#g.tbl.my_veh_hist])
				end
				if g._self_veh_auto_repair.on and g._self_veh_auto_repair.value ~= 0 then
					funcs.doo.veh_repair_all(_veh, 1000,nil,false,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
				end
				last_do_once=true
			end
		end
	end
end)
g._self_veh_auto_hidden.on=true
g._self_veh_auto_hidden.hidden=true

function funcs.doo.self_veh_auto(_veh)
	if (g._self_veh_auto_setting.value == 0 and g.var.auto__am_i_the_driver) or g._self_veh_auto_setting.value == 1 then
		if g._self_veh_auto_kick.on and funcs.is.veh(_veh) then
			funcs.doo.kick_all_from_veh(_veh, (g._self_veh_auto_kick.value ~= 0))
			YIELD(125)
		end
		if g._self_veh_auto_repair.on and funcs.is.veh(_veh) then
			if g._self_veh_auto_repair.value == 0 or g._self_veh_auto_repair.value == 2 then
				funcs.doo.veh_repair_all(_veh, 1000,nil,false,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
				YIELD(125)
			end
		end
		if g._self_veh_auto_upgrade.on and funcs.is.veh(_veh) then
			funcs.doo.veh_action_list(_veh,1000,"perf",nil)
			YIELD(125)
		end
		if g._self_veh_auto_force.on and funcs.is.veh(_veh) then
			funcs.doo.veh_speed(_veh, 1000, funcs.get.veh_ped_name_in_seat(_veh,"first_plyr"), funcs.get.veh_model_name(_veh), true, g._self_veh_auto_force.value/100)
			YIELD(125)
		end
		return true
	end
	return false
end

menu_add_feature("Clone my veh", "action", g.prnt.self_veh_crrnt.id, function()
	if funcs.ME._in_veh() then
		local pos = funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),5 + funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos()))
		funcs.doo.record_clone_veh(g.tbl.veh_clone,funcs.ME._veh())
		funcs.doo.create_clone_veh(g.tbl.veh_clone[funcs.ME._veh()],pos,API.cam.get.rot().z)
	else
		g.N_P(2,"You are not in a vehicle",__GV__,4,"Blue")
	end
end)

menu_add_feature("Repair current vehicle", "action", g.prnt.self_veh_crrnt.id, function()
	funcs.doo.veh_current_do("repair")
end)

g._auto_veh_rpr=menu_add_feature("Auto-repair if less than %", "value_i", g.prnt.self_veh_crrnt.id, function(f)
	while f.on do
		YIELD(100)
		if funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id())) and funcs.get.veh_cmbnd_health_prcnt(API.plyr.get.veh(API.plyr.my_id()),true) < f.value then
			funcs.doo.veh_repair_most(API.plyr.get.veh(API.plyr.my_id()),250,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
		end
	end
end)
funcs.set_feat_i_f(g._auto_veh_rpr,50,100,5,75,"g._auto_veh_rpr")

g._missile_no_lock=menu_add_feature("Vehicle missile anti-lock","action_value_str",g.prnt.self_veh_crrnt.id,function(f)
	funcs.doo.veh_current_do("anti_lock",f.value==1)
end)
new_set_str_data(g._missile_no_lock,{"Give","Remove"})
funcs.add_to_S_L(g._missile_no_lock,"g._missile_no_lock")

g._self_veh_upgrades_action2=menu_add_feature("Vehicle Upgrades","action_value_str",g.prnt.self_veh_crrnt_upgr.id,function(f)
	local t = {"upgrades","perf","wheels","f1","livery","weapons"}
	funcs.doo.veh_current_do(t[f.value+1])
end)
new_set_str_data(g._self_veh_upgrades_action2,{"Everything", "Performance mods","Wheels/Tires","Give F1 Wheels","Livery","Weapons"})
funcs.add_to_S_L(g._self_veh_upgrades_action2,"g._self_veh_upgrades_action2")

g._self_veh_paintjob=menu_add_feature("Random paintjob","action_value_str",g.prnt.self_veh_crrnt_upgr_pnt.id,function(f)
	local t = {"random","random_solid",funcs.get.rand_paint_shade("Dark"),funcs.get.rand_paint_shade("Bright")}
	funcs.doo.veh_current_do("paint",t[f.value+1])
end)
new_set_str_data(g._self_veh_paintjob,{"Non-matching", "Matching","Dark","Bright"})
funcs.add_to_S_L(g._self_veh_paintjob,"g._self_veh_paintjob")

menu_add_feature("Apply custom paintjob","action",g.prnt.self_veh_crrnt_upgr_pnt_rgb.id,function()
	funcs.doo.veh_current_do("paint",(g._veh_custom_paint_r.value * 65536 + g._veh_custom_paint_g.value * 256 + g._veh_custom_paint_b.value ))
end)



g._veh_custom_paint_r=menu_add_feature("Custom Red","autoaction_value_i",g.prnt.self_veh_crrnt_upgr_pnt_rgb.id)
funcs.set_feat_i_f(g._veh_custom_paint_r,0,255,1,0,"g._veh_custom_paint_r")

g._veh_custom_paint_g=menu_add_feature("Custom Green","autoaction_value_i",g.prnt.self_veh_crrnt_upgr_pnt_rgb.id)
funcs.set_feat_i_f(g._veh_custom_paint_g,0,255,1,0,"g._veh_custom_paint_g")

g._veh_custom_paint_b=menu_add_feature("Custom Blue","autoaction_value_i",g.prnt.self_veh_crrnt_upgr_pnt_rgb.id)
funcs.set_feat_i_f(g._veh_custom_paint_b,0,255,1,0,"g._veh_custom_paint_b")

g.tbl.self_paint_saved=menu_add_feature("Saved Paintjobs","parent",g.prnt.self_veh_crrnt_upgr_pnt.id)



g.tbl.saved_paintjobs={}
function funcs.doo.check_paintjob_file()
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.paths._user.."Vehicle Paint Jobs\\")
	funcs.doo.check_create_file(g.paths._user.."Vehicle Paint Jobs\\Saved paintjobs.txt","")
end

function funcs.doo.add_saved_paintjob_feat(values)
	if #values == 7 and not	g.tbl.saved_paintjobs[values[1]] then
		g.tbl.saved_paintjobs[values[1]]=og_menu_add_feature(values[1],"action_value_str",g.tbl.self_paint_saved.id,function(f,data)
			if f.value == 0 then
				if not funcs.ME._in_veh() then
					g.N_P(2,"You are not in a vehicle",__GV__,4,"Blue")
				else
					local _veh = funcs.ME._veh()
					if funcs.ntwrk.ask_long(_veh,1000) then
						--example name|123|456|789|234|567|891
						API.veh.set.kit_type(_veh, 0)
						API.veh.set.colors(_veh,values[2],values[3])
						API.veh.set.extra_colors(_veh, values[6], API.veh.get.wheel_color(_veh))
						API.veh.set.primary_color_custom(_veh, values[4])
						API.veh.set.secondary_color_custom(_veh, values[5])
						API.veh.set.pearl_color_custom(_veh, values[7])
					else
						g.N_P(2,"FAILED to get control of vehicle :(",__GV__,4,"Red")
					end
				end
			else
				funcs.doo.check_paintjob_file()
				local file = io.open(g.paths._user.."Vehicle Paint Jobs\\Saved paintjobs.txt", "r")
				local t = {}
				if file then
					for line in file:lines() do
						if line == nil then
							break
						elseif line~=f.data then
							t[#t+1]=line
						end
					end
					file:close()
				end
				file = io.open(g.paths._user.."Vehicle Paint Jobs\\Saved paintjobs.txt", "w")
				if file then
					local str = table_concat(t,"\n")
					file:write(str)
					file:close()
					g.tbl.saved_paintjobs[values[1]]=nil
					menu.delete_feature(f.id)
				else
					funcs.N_P(2,"Could not access Saved paintjobs.txt\nDo you have that file open??",__GV__,7,"Red")
				end
			end
		end)
		new_set_str_data(g.tbl.saved_paintjobs[values[1]],{"Apply paintjob", "Delete paintjob"})
		g.tbl.saved_paintjobs[values[1]].data=line
	end
end

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	while not g.var.GS_has_loaded do
		YIELD(0)
	end
	funcs.doo.check_paintjob_file()
	local file = io.open(g.paths._user.."Vehicle Paint Jobs\\Saved paintjobs.txt", "r")
	if file then
		for line in file:lines() do
			if line == nil then
				break
			else
				local values = {}
				for value in string.gmatch(line, "([^|]+)") do
					values[#values+1]= tonumber(value) or value
				end
				funcs.doo.add_saved_paintjob_feat(values)
			end
		end
		file:close()
	else
		funcs.N_P(2,"Could not access Saved paintjobs.txt\nDo you have that file open??",__GV__,7,"Red")
	end
end)


menu_add_feature("Save current paintjob","action",g.tbl.self_paint_saved.id,function(f)
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle",__GV__,4,"Blue")
	else
		local _veh = funcs.ME._veh()
		local values = {}
		values[2]=API.veh.get.primary_color(_veh)
		values[3]=API.veh.get.secondary_color(_veh)
		local pB,pG,pR = ntv.get.veh_primary_color_custom_rgb(_veh) --yes its bgr
		values[4] = pB * 65536 + pG * 256 + pR
		local sB,sG,sR = ntv.get.veh_secondary_color_custom_rgb(_veh) --yes its bgr
		values[5] = sB * 65536 + sG * 256 + sR
		values[6] = API.veh.get.pearl_color(_veh)
		values[7] = API.veh.get.pearl_color_custom(_veh)
		--example name|123|456|789|234|567|891
		local status,str = funcs.get.text_input("Enter name for current paintjob","",20,0)
		if status == 0 then
			if	g.tbl.saved_paintjobs[str] then
				funcs.N_P(2,"Already have a saved paintjob with that name.",__GV__,4,"Yellow")
			else
				values[1] = str
				funcs.doo.check_paintjob_file()
				local file = io.open(g.paths._user.."Vehicle Paint Jobs\\Saved paintjobs.txt", "a")
				if file then
					local text = table_concat(values,"|")
					file:write("\n"..text)
					file:close()
					funcs.doo.add_saved_paintjob_feat(values)
				else
					funcs.N_P(2,"Could not access Saved paintjobs.txt\nDo you have that file open??",__GV__,7,"Red")
				end
			end
		end
	end
end)





g.tbl.self_paint_types = {
[0] = "paint",
[1] = "paint_primary",
[2] = "paint_secondary",
[3] = "paint_pearl",
[4] = "paint_extras",
}
g.tbl.self_paint_prnts_new = {}
for k,v in ipairs (g.tbl.paints2) do
	local t = paints[v]
	if type(t) == "table" then
		g.tbl.self_paint_prnts_new[v]=menu_add_feature(v,"parent",g.prnt.self_veh_crrnt_upgr_pnt.id)
		for kk,vv in ipairs (t) do
			local temp=og_menu_add_feature(vv.NAME_IN_COLOR,"action_value_str",g.tbl.self_paint_prnts_new[v].id,function(f)
				funcs.doo.veh_current_do(g.tbl.self_paint_types[f.value],vv.INT)
			end)
			temp:set_str_data({"All","Primary","Secondary","Pearl"}) --
			--new_set_str_data(temp,{"All","Primary","Secondary","Pearl"},true)--,"Extras"})
		end
	end
end



g._self_veh_neons=menu_add_feature("Random neon color","action",g.prnt.self_veh_crrnt_upgr_neons.id,function(f)
	funcs.doo.veh_current_do("neons","random")
end)

for i=1,#veh_stuff.neon_names do
	menu_add_feature(veh_stuff.neon_names[i],"action",g.prnt.self_veh_crrnt_upgr_neons.id,function()
		funcs.doo.veh_current_do("neons",veh_stuff.neon_ints[i])
	end)
end

g._self_veh_headlights=menu_add_feature("Random headlight color","action",g.prnt.self_veh_crrnt_upgr_lights.id,function(f)
	funcs.doo.veh_current_do("headlights","random")
end)

for i=1,#veh_stuff.neon_names do
	menu_add_feature(veh_stuff.neon_names[i],"action",g.prnt.self_veh_crrnt_upgr_lights.id,function()
		funcs.doo.veh_current_do("headlights",i-1)
	end)
end

g._self_veh_force2=menu_add_feature("Vehicle max speed/torque %","action_value_i",g.prnt.self_veh_crrnt_upgr.id,function(f)
	funcs.doo.veh_current_do("speed_torque",f.value/100)
end)
funcs.set_feat_i_f(g._self_veh_force2,0,700,5,100,"g._self_veh_force2")

g._self_veh_accel_fuck=menu_add_feature("Vehicle acceleration is","action_value_str",g.prnt.self_veh_crrnt.id,function(f)
	funcs.doo.veh_current_do("speed_torque",(f.value-10)+(f.value*109))
end)
new_set_str_data(g._self_veh_accel_fuck,{"Fucked", "Normal"})
funcs.add_to_S_L(g._self_veh_accel_fuck,"g._self_veh_accel_fuck")

menu_add_feature("Fuck vehicle", "action", g.prnt.self_veh_crrnt.id, function()
	funcs.doo.veh_current_do("fucked")
end)

menu_add_feature("Remove helicopter rotors", "action", g.prnt.self_veh_crrnt.id, function()
	funcs.doo.veh_current_do("remove_rotor")
end)

menu_add_feature("Flip vehicle upside down", "action", g.prnt.self_veh_crrnt.id, function()
	funcs.doo.veh_current_do("flip_wrong")
end)

menu_add_feature("Put vehicle on wheels", "action", g.prnt.self_veh_crrnt.id, function()
	funcs.doo.veh_current_do("flip_right")
end)

g._veh_self_rand_force=menu_add_feature("Random force", "action_slider", g.prnt.self_veh_crrnt.id, function(f)
	 funcs.doo.veh_current_do("random_force",f.value)
end)
funcs.set_feat_i_f(g._veh_self_rand_force,15,150,15,45,"g._veh_self_rand_force")

function funcs.doo.veh_current_do(_action,_val)
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle",__GV__,4,"Blue")
	elseif not funcs.doo.veh_action_list(funcs.ME._veh(),1000,_action,_val) then
		g.N_P(2,"Action failed or wasn't needed.",__GV__,4,"Yellow")
	end
end

-----------------------------------------------------------------------------------------GEE-SKID
---------------------------------------------------------------------------------------------SELF
-----------------------------------------------------------------------------------CurrentVehicle
------------------------------------------------------------------------------------GeeDriveStuff
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g._GeeBoost=menu_add_feature("Gee-Boost", "toggle", g.prnt.self_veh_crrnt_boost_stop.id, function(f)
	if funcs.is.GS_loaded() and f.on then
		if g._geeboost_set_keys.value == 0 then
			g.N_P(2,"Gee-Boost Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeBoostSelect1.value+1].." to boost.",__GV__,5,"Blue")
		elseif g._geeboost_set_keys.value == 1 then
			g.N_P(2,"Gee-Boost Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeBoostSelect1.value+1].." and "..inputs.vk_list[g._GeeBoostSelect2.value+1].." to boost.",__GV__,6,"Blue")
		else
			g.N_P(2,"Gee-Boost Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeBoostSelect1.value+1].." and "..inputs.vk_list[g._GeeBoostSelect2.value+1].." and "..inputs.vk_list[g._GeeBoostSelect3.value+1].." to boost.",__GV__,7,"Blue")
		end
	end
    while f.on do
		YIELD(0)
		if g._geeboost_set_keys.value == 0 then
			f.name="Gee-Boost: "..inputs.vk_list[g._GeeBoostSelect1.value+1]
		elseif g._geeboost_set_keys.value == 1 then
			f.name="Gee-Boost: "..inputs.vk_list[g._GeeBoostSelect1.value+1].." "..inputs.vk_list[g._GeeBoostSelect2.value+1]
		else
			f.name="Gee-Boost: "..inputs.vk_list[g._GeeBoostSelect1.value+1].." "..inputs.vk_list[g._GeeBoostSelect2.value+1].." "..inputs.vk_list[g._GeeBoostSelect3.value+1]
		end
		if funcs.ME._in_veh() then
			funcs.doo.self_boost_stop_show()
			if funcs.is.feature_keys_down(g._geeboost_set_keys,g._GeeBoostSelect1,g._GeeBoostSelect2,g._GeeBoostSelect3) then
				funcs.doo.veh_self_boost(funcs.ME._veh())
			end
		end
	end
	f.name="Gee-Boost"
end)
funcs.add_to_S_L(g._GeeBoost,"g._GeeBoost")

g._GeeBoostSelect1=og_menu_add_feature("Key1 for Gee-Boost","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeBoostSelect1:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeBoostSelect1,"g._GeeBoostSelect1")
g._GeeBoostSelect1.hidden=true
g._GeeBoostSelect1.value=16

g._GeeBoostSelect2=og_menu_add_feature("Key2 for Gee-Boost","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeBoostSelect2:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeBoostSelect2,"g._GeeBoostSelect2")
g._GeeBoostSelect2.hidden=true
g._GeeBoostSelect2.value=4

g._GeeBoostSelect3=og_menu_add_feature("Key3 for Gee-Boost","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeBoostSelect3:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeBoostSelect3,"g._GeeBoostSelect3")
g._GeeBoostSelect3.hidden=true
g._GeeBoostSelect3.value=53

g._geeboost_set_keys=menu_add_feature("Set key(s) for Gee-Boost","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id,function(f)
	funcs.doo.set_keybinds(f.value+1,"Gee-Boost",g._GeeBoostSelect1,g._GeeBoostSelect2,g._GeeBoostSelect3)
end)
new_set_str_data(g._geeboost_set_keys,{"One", "Two","Three"})
funcs.add_to_S_L(g._geeboost_set_keys,"g._geeboost_set_keys")
g._geeboost_set_keys.value=1

g._self_veh_accel = menu_add_feature("Boost vehicle forward", "action_slider", g.prnt.self_veh_crrnt_boost_stop.id, function()
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle.",__GV__,4,"Blue")
	else
		funcs.doo.veh_self_boost(API.plyr.get.veh(API.plyr.my_id()),10)
	end
end)
funcs.set_feat_i_f(g._self_veh_accel,1,50,1,5,"g._self_veh_accel")

g._GeeStopRvrs=menu_add_feature("Gee-Stop/Reverse", "toggle", g.prnt.self_veh_crrnt_boost_stop.id, function(f)
	if funcs.is.GS_loaded() and f.on then
		if g._geestop_set_keys.value == 0 then
			g.N_P(2,"Gee-Stop/Reverse Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeStopSelect1.value+1].." to stop/reverse.",__GV__,5,"Blue")
		elseif g._geestop_set_keys.value == 1 then
			g.N_P(2,"Gee-Stop/Reverse Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeStopSelect1.value+1].." and "..inputs.vk_list[g._GeeStopSelect2.value+1].." to stop/reverse.",__GV__,6,"Blue")
		else
			g.N_P(2,"Gee-Stop/Reverse Enabled\nWhile in any vehicle hold "..inputs.vk_list[g._GeeStopSelect1.value+1].." and "..inputs.vk_list[g._GeeStopSelect2.value+1].." and "..inputs.vk_list[g._GeeStopSelect3.value+1].." to stop/reverse.",__GV__,7,"Blue")
		end
	end
	local ground=true
    while f.on do
		YIELD(0)
		if g._geestop_set_keys.value == 0 then
			f.name="Gee-Stop/Reverse: "..inputs.vk_list[g._GeeStopSelect1.value+1]
		elseif g._geestop_set_keys.value == 1 then
			f.name="Gee-Stop/Reverse: "..inputs.vk_list[g._GeeStopSelect1.value+1].." "..inputs.vk_list[g._GeeStopSelect2.value+1]
		else
			f.name="Gee-Stop/Reverse: "..inputs.vk_list[g._GeeStopSelect1.value+1].." "..inputs.vk_list[g._GeeStopSelect2.value+1].." "..inputs.vk_list[g._GeeStopSelect3.value+1]
		end
		if funcs.ME._in_veh() then
			funcs.doo.self_boost_stop_show()
			if funcs.is.feature_keys_down(g._geestop_set_keys,g._GeeStopSelect1,g._GeeStopSelect2,g._GeeStopSelect3) then
				funcs.doo.veh_self_stop(funcs.ME._veh(),ground)
				if g._self_veh_revers.value == 0 and ground then
					ground=false
				end
			else
				ground=true
			end
		end
	end
	f.name="Gee-Stop/Reverse"
end)
funcs.add_to_S_L(g._GeeStopRvrs,"g._GeeStopRvrs")

g._GeeStopSelect1=og_menu_add_feature("Key1 for Gee-Stop","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeStopSelect1:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeStopSelect1,"g._GeeStopSelect1")
g._GeeStopSelect1.hidden=true
g._GeeStopSelect1.value=2

g._GeeStopSelect2=og_menu_add_feature("Key2 for Gee-Stop","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeStopSelect2:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeStopSelect2,"g._GeeStopSelect2")
g._GeeStopSelect2.hidden=true
g._GeeStopSelect2.value=2

g._GeeStopSelect3=og_menu_add_feature("Key3 for Gee-Stop","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id)
g._GeeStopSelect3:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeStopSelect3,"g._GeeStopSelect3")
g._GeeStopSelect3.hidden=true
g._GeeStopSelect3.value=2

g._geestop_set_keys=menu_add_feature("Set key(s) for Gee-Stop/Reverse","action_value_str",g.prnt.self_veh_crrnt_boost_stop.id,function(f)
	funcs.doo.set_keybinds(f.value+1,"Gee-Stop/Reverse",g._GeeStopSelect1,g._GeeStopSelect2,g._GeeStopSelect3)
end)
new_set_str_data(g._geestop_set_keys,{"One", "Two","Three"})
funcs.add_to_S_L(g._geestop_set_keys,"g._geestop_set_keys")

g._self_veh_revers = menu_add_feature("Stop/Reverse vehicle", "action_slider", g.prnt.self_veh_crrnt_boost_stop.id, function()
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle.",__GV__,4,"Blue")
	else
		funcs.doo.veh_self_stop(API.plyr.get.veh(API.plyr.my_id()))
	end
end)
funcs.set_feat_i_f(g._self_veh_revers,0,50,1,0,"g._self_veh_revers")

g.var.boost_display_once=false
function funcs.doo.self_boost_stop_show()
	if g._Boost_display.on and not g.var.boost_display_once and (not g.feat.gw_main.on or not funcs.ME._aim()) then
		g.var.boost_display_once=true
		local boost,stop,text="","",""
		_boost = funcs.is.char_check(inputs.vk_list[g._GeeBoostSelect1.value+1])
		if g._geeboost_set_keys.value > 0 then _boost = _boost.." "..funcs.is.char_check(inputs.vk_list[g._GeeBoostSelect2.value+1])
		end
		if g._geeboost_set_keys.value > 1 then _boost = _boost.." "..funcs.is.char_check(inputs.vk_list[g._GeeBoostSelect3.value+1])
		end
		stop = funcs.is.char_check(inputs.vk_list[g._GeeStopSelect1.value+1])
		if g._geestop_set_keys.value > 0 then stop = stop.." "..funcs.is.char_check(inputs.vk_list[g._GeeStopSelect2.value+1])
		end
		if g._geestop_set_keys.value > 1 then stop = stop.." "..funcs.is.char_check(inputs.vk_list[g._GeeStopSelect3.value+1])
		end
		if g._GeeBoost.on and g._GeeStopRvrs.on then text=_boost..":Accel   "..stop..":Stop/Reverse"
		elseif g._GeeBoost.on then text=_boost..":Accel"
		else text=stop..":Stop/Reverse"
		end
		funcs.doo.overlay(text,g._BS__cr.value,g._BS__cg.value,g._BS__cb.value,g._BS__a.value,g._BS__s.value/300,g._BS__f.value,g._BS__x.value/300,g._BS__y.value/300)
		g.var.boost_display_once=false
	end
end

g._Boost_display = menu_add_feature("Gee-Boost display overlay for self", "toggle", g.prnt.self_veh_crrnt_boost_stop_dsply.id, function(f)
	if funcs.is.GS_loaded() then
		g.N_P(2,"Gee-Boost will display an overlay when in a vehicle.",__GV__,4,"Blue")
	end
end)
funcs.add_to_S_L(g._Boost_display,"g._Boost_display")

g._BS__x = menu_add_feature("X Pos", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__x,0,300,1,150,"g._BS__x")

g._BS__y = menu_add_feature("Y Pos", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__y,0,300,1,289,"g._BS__y")

g._BS__s = menu_add_feature("Scale", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__s,75,300,1,170,"g._BS__s")

g._BS__f = menu_add_feature("Font", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__f,0,9,1,6,"g._BS__f")

g._BS__cr = menu_add_feature("Red", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__cr,0,255,1,0,"g._BS__cr")

g._BS__cg = menu_add_feature("Green", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__cg,0,255,1,255,"g._BS__cg")

g._BS__cb = menu_add_feature("Blue", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__cb,0,255,1,0,"g._BS__cb")

g._BS__a = menu_add_feature("Alpha", "action_slider", g.prnt.self_veh_crrnt_boost_stop_dsply.id)
funcs.set_feat_i_f(g._BS__a,30,255,1,105,"g._BS__a")


g._GeeSteer_custom=menu_add_feature("Gee-Steer", "value_str", g.prnt.self_veh_crrnt_drive.id, function(f)
	funcs.doo.GeeSteer_notif()
	while f.on do
		YIELD(50)
		funcs.doo.feat_keys_name("Gee-Steer: ",g._GeeSteer_custom,g._geesteer_set_keys,g._GeeSteerSelect1,g._GeeSteerSelect2,g._GeeSteerSelect3)
		if funcs.ME._in_veh() then
			if funcs.is.feature_keys_down(g._geesteer_set_keys,g._GeeSteerSelect1,g._GeeSteerSelect2,g._GeeSteerSelect3) then
				while funcs.is.feature_keys_down(g._geesteer_set_keys,g._GeeSteerSelect1,g._GeeSteerSelect2,g._GeeSteerSelect3) and funcs.ME._in_veh() do
					YIELD(0)
					funcs.doo.GeeSteer(f.value)
				end
				funcs.doo.tp_ent(API.plyr.get.veh(API.plyr.my_id()),API.ent.get.coords(API.plyr.get.veh(API.plyr.my_id())), 0 ,true)
			end
		end
	end
	f.name="Gee-Steer"
end)
new_set_str_data(g._GeeSteer_custom,{"Partial", "Full"})
funcs.add_to_S_L(g._GeeSteer_custom,"g._GeeSteer_custom")

g._GeeSteerSelect1=og_menu_add_feature("Key1 for Gee-Steer","action_value_str",g.prnt.self_veh_crrnt_drive.id)
g._GeeSteerSelect1:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeSteerSelect1,"g._GeeSteerSelect1")
g._GeeSteerSelect1.hidden=true
g._GeeSteerSelect1.value=0

g._GeeSteerSelect2=og_menu_add_feature("Key2 for Gee-Steer","action_value_str",g.prnt.self_veh_crrnt_drive.id)
g._GeeSteerSelect2:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeSteerSelect2,"g._GeeSteerSelect2")
g._GeeSteerSelect2.hidden=true
g._GeeSteerSelect2.value=22

g._GeeSteerSelect3=og_menu_add_feature("Key3 for Gee-Steer","action_value_str",g.prnt.self_veh_crrnt_drive.id)
g._GeeSteerSelect3:set_str_data(inputs.vk_list)
funcs.add_to_S_L(g._GeeSteerSelect3,"g._GeeSteerSelect3")
g._GeeSteerSelect3.hidden=true
g._GeeSteerSelect3.value=3

g._geesteer_set_keys=menu_add_feature("Set key(s) for Gee-Steer","action_value_str",g.prnt.self_veh_crrnt_drive.id,function(f)
	funcs.doo.set_keybinds(f.value+1,"Gee-Steer",g._GeeSteerSelect1,g._GeeSteerSelect2,g._GeeSteerSelect3)
end)
new_set_str_data(g._geesteer_set_keys,{"One", "Two","Three"})
funcs.add_to_S_L(g._geesteer_set_keys,"g._geesteer_set_keys")
g._geesteer_set_keys.value=2

g._GeeSteer_LC=menu_add_feature("Gee-Steer with Left-Click", "value_str", g.prnt.self_veh_crrnt_drive.id, function(f)
	funcs.doo.GeeSteer_notif()
	while f.on do
		YIELD(50)
		if funcs.ME._in_veh() and funcs.is.key_active(114,0) and funcs.is.GeeSteer_LC_check() then
			while funcs.is.key_active(223,1) and funcs.ME._in_veh() do
				YIELD(0)
				funcs.doo.GeeSteer(f.value)
			end
			funcs.doo.tp_ent(API.plyr.get.veh(API.plyr.my_id()),API.ent.get.coords(API.plyr.get.veh(API.plyr.my_id())), 0 ,true)
		end
	end
end)
new_set_str_data(g._GeeSteer_LC,{"Partial", "Full"})
funcs.add_to_S_L(g._GeeSteer_LC,"g._GeeSteer_LC")

function funcs.is.GeeSteer_LC_check()
	if funcs.is.key_active(223,1) then --left click
		if 	API.veh.get.class(API.plyr.get.veh(API.plyr.my_id())) == 15 or
			API.veh.get.class(API.plyr.get.veh(API.plyr.my_id())) == 16 or
			funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"oppressor2") or
			funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"oppressor") then
			return true
		end
		if funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"rhino") then
			if funcs.ME._in_seat(API.plyr.get.veh(API.plyr.my_id()),-1) then
				return false
			end
			return true
		elseif funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"khanjali") then
			return false
		elseif funcs.is.this_veh(API.plyr.get.veh(API.plyr.my_id()),"apc") then
			if funcs.ME._in_seat(API.plyr.get.veh(API.plyr.my_id()),0) then
				return false
			end
			return true
		else
			return true
		end
	end
end

function funcs.doo.GeeSteer(_val)
	local my_rot = API.ent.get.rotation(API.plyr.get.veh(API.plyr.my_id()))
	local rot = API.cam.get.rot()
	my_rot.z = rot.z
	if funcs.ntwrk.ask_quick(API.plyr.get.veh(API.plyr.my_id())) then
		if _val == 0 then API.ent.set.rotation(API.plyr.get.veh(API.plyr.my_id()),my_rot)
		else API.ent.set.rotation(API.plyr.get.veh(API.plyr.my_id()),API.cam.get.rot())
		end
	end
end


g._GeeSteer_LC_notif=false
function funcs.doo.GeeSteer_notif()
	if funcs.is.GS_loaded() then
		local buttons=""
		local custom=inputs.vk_list[g._GeeSteerSelect1.value+1]
		if g._geesteer_set_keys.value > 0 then
			custom=custom.." "..inputs.vk_list[g._GeeSteerSelect2.value+1]
		end
		if g._geesteer_set_keys.value == 2 then
			custom=custom.." "..inputs.vk_list[g._GeeSteerSelect3.value+1]
		end
		if g._GeeSteer_LC.on and g._GeeSteer_custom.on then
			buttons=buttons.."Left-Click or "..custom
		elseif g._GeeSteer_custom.on then
			buttons=buttons..custom
		else
			buttons=buttons.."Left-Click"
		end
		g.N_P(2,"Gee-Steer Enabled\nWhile in any vehicle hold "..buttons.." to 'steer.'",__GV__,6,"Blue")
		if g._GeeSteer_LC.on and g._GeeSteer_LC_notif == false then
			g.N_P(2,"Gee-Steer with Left-Click may require adjusting your GTA settings to work properly. It also functions differently depending on the vehicle.",__GV__,7,"Yellow")
			g._GeeSteer_LC_notif=true
		end
	end
end

g._GeeDrive_insta=menu_add_feature("Insta-Drive-Stop", "value_str", g.prnt.self_veh_crrnt_drive.id, function(f)
	if funcs.is.GS_loaded()  and f.on then
		g.N_P(2,"Insta-Drive-Stop enabled\nWhile driving your vehicle can instantly start moving, have increased acceleration, or instantly stop.",__GV__,6,"Blue")
	end
	local do_once=true
	local time = TIME_MS() +250
    while f.on do
		YIELD(0)
		if funcs.ME._in_veh() then
			local me_id=API.plyr.my_id()
			local my_veh=API.plyr.get.veh(me_id)
			local class = API.veh.get.class(my_veh)
			if class ~= 15 and class ~= 16 then
				if funcs.ME._driving(my_veh) then
					if funcs.is.key_active(32,1) then
						if do_once then
							if f.value ~= 4 and f.value ~= 5 then
								API.veh.set.forward_speed(my_veh,15)
							end
						end
						if f.value == 0 or f.value == 2 or f.value == 4 then
							if time < TIME_MS() then
								API.veh.set.forward_speed(my_veh,(API.ent.get.speed(my_veh)+1))
								time = TIME_MS() +250
							end
						else
							time = TIME_MS() +250
						end
						do_once = false
					elseif not do_once then
						if f.value == 0 or f.value == 1 or f.value == 5 then
							API.ent.set.velocity(my_veh,funcs.vec(0,0,0))
							API.veh.set.on_ground(my_veh)
						end
						do_once = true
					end
				end
			end
		end
	end
end)
new_set_str_data(g._GeeDrive_insta,{"Start-Accel-Stop","Start-Stop","Start-Accel", "Only Start","Only Accel","Only Stop"})
funcs.add_to_S_L(g._GeeDrive_insta,"g._GeeDrive_insta")

g._GeeDrive_boost_tog=menu_add_feature("GTA-Boost toggle", "toggle", g.prnt.self_veh_crrnt_drive.id, function(f)
	if funcs.is.GS_loaded()  and f.on then
		g.N_P(2,"Boost toggle enabled\nPress the brakes to stop boosting.",__GV__,6,"Blue")
	end
	local active=false
	local my_veh=0
    while f.on do
		YIELD(0)
		if funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id())) then
			my_veh=API.plyr.get.veh(API.plyr.my_id())
			if vehicle.is_vehicle_rocket_boost_active(my_veh) then
				active=true
				vehicle.set_vehicle_rocket_boost_percentage(my_veh,999999.0)
				if funcs.is.key_active(33,1) then --oppressor2 wouldnt respond by using boost key to stop
					vehicle.set_vehicle_rocket_boost_percentage(my_veh,100.0)
					vehicle.set_vehicle_rocket_boost_active(my_veh,false)
				end
			else
				active=false
			end
		elseif active then
			if funcs.is.veh(my_veh) then
				vehicle.set_vehicle_rocket_boost_percentage(my_veh,100.0)
				vehicle.set_vehicle_rocket_boost_active(my_veh,false)
			end
			active=false
		end
	end
end)
funcs.add_to_S_L(g._GeeDrive_boost_tog,"g._GeeDrive_boost_tog")

g._self_veh_up = menu_add_feature("Jump up", "action_slider", g.prnt.self_veh_crrnt_drive.id, function()
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle.",__GV__,4,"Blue")
	else
		funcs.doo.veh_self_up(API.plyr.get.veh(API.plyr.my_id()))
	end
end)
funcs.set_feat_i_f(g._self_veh_up,1,100,1,25,"g._self_veh_up")

g._self_veh_down = menu_add_feature("Boost down", "action_slider", g.prnt.self_veh_crrnt_drive.id, function()
	if not funcs.ME._in_veh() then
		g.N_P(2,"You are not in a vehicle.",__GV__,4,"Blue")
	else
		funcs.doo.veh_self_down(API.plyr.get.veh(API.plyr.my_id()))
	end
end)
funcs.set_feat_i_f(g._self_veh_down,1,100,1,25,"g._self_veh_down")

------------------Vehicle Movement Self
---------------------------------------
function funcs.doo.veh_self_boost(self,amp)
	amp = amp or 1
	if not funcs.ME._driving(self) then
		if funcs.ntwrk.ask_long(self,100) then
			API.ent.set.max_speed(self,45000)
			API.veh.set.forward_speed(self,(API.ent.get.speed(self)+((g._self_veh_accel.value*0.11)*amp)))
		end
	else
		API.ent.set.max_speed(self,45000)
		API.veh.set.forward_speed(self,(API.ent.get.speed(self)+((g._self_veh_accel.value*0.1)*amp)))
	end
end

function funcs.doo.veh_self_stop(self,ground)
	ground = ground or false
	if not funcs.ME._driving(self) then
		if funcs.ntwrk.ask_long(self,1000) then
			API.veh.set.forward_speed(self,-g._self_veh_revers.value)
			if g._self_veh_revers.value == 0 and ground then
				API.veh.set.on_ground(self)
			end
		end
	else
		API.veh.set.forward_speed(self,-g._self_veh_revers.value)
		if g._self_veh_revers.value == 0 and ground then
			API.veh.set.on_ground(self)
		end
	end
end

function funcs.doo.veh_self_up(self)
	if not funcs.ME._driving(self) then
		if funcs.ntwrk.ask_long(self,1000) then
			API.ent.force(self, 1,0,0, g._self_veh_up.value,    0, 0, 0,   false, true)
		end
	else
		API.ent.force(self, 1,0,0, g._self_veh_up.value,    0, 0, 0,   false, true)
	end
end

function funcs.doo.veh_self_down(self)
	if not funcs.ME._driving(self) then
		if funcs.ntwrk.ask_long(self,1000) then
			API.ent.force(self, 1,0,0, -g._self_veh_down.value,    0, 0, 0,   false, true)
		end
	else
		API.ent.force(self, 1,0,0, -g._self_veh_down.value,    0, 0, 0,   false, true)
	end
end

-----------------------------------------------------------------------------------------GEE-SKID
---------------------------------------------------------------------------------------------Peds
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g.tbl.unaffected_ents={}
function funcs.is.good_session_ped(_ped)
	if funcs.is.ent(_ped) and API.ent.is.ped(_ped) and not API.ent.is.dead(_ped) and not API.Ped.is.plyr(_ped) and g.tbl.R_P.ped ~= _ped and not g.tbl.unaffected_ents[_ped] then
		if g._ped_not_nice.on then
			return (not ntv.is.ped_nice(_ped,API.plyr.get.ped(API.plyr.my_id())))
		end
		return true
	end
	return false
end

-------------------Thanks to jhowkNx for including ped weapon options in version 2.17 of
-------------------heist control. Original code included and expanded upon significantly.
g._ped_not_nice=menu_add_feature("*Do not affect any friendly peds*","toggle",g.prnt.sssn_peds.id)
funcs.add_to_S_L(g._ped_not_nice,"g._ped_not_nice")

g._peds_brawl=menu_add_feature("Peds fight","toggle",g.prnt.sssn_peds.id,function(f)
	local group = {ped.create_group(),ped.create_group()}
	ped.set_relationship_between_groups(5, group[1], group[2])
	ped.set_relationship_between_groups(5, group[2], group[1])
	local assigned = {}
	local INT=1
	while f.on do
		all_peds = API.Ped.get.all()
		table.sort(all_peds, function(a, b) return funcs.get.dist_me_ent_3d(a)<funcs.get.dist_me_ent_3d(b)  end)
		for k,v in ipairs(all_peds) do
			if funcs.is.good_session_ped(v) then
				if not assigned[v] or (not funcs.is.ped(assigned[v].TRGT) or API.ent.is.dead(assigned[v].TRGT)) then
					for k2,v2 in ipairs(all_peds) do
						if v2 ~= v and not assigned[v2] and funcs.is.good_session_ped(v2) then
							--ntv.doo.clear_task(v)
							assigned[v]={}
							assigned[v].PED=v
							assigned[v].GRP=group[INT]
							assigned[v].TRGT=v2
							if ped.is_ped_in_group(v) then
								ped.remove_ped_from_group(v)
							end
							ped.set_ped_as_group_member(v,assigned[v].GRP)
							funcs.doo.ped_combat_attrib(v)
							ped.set_ped_never_leaves_group(v, true)
							ai.task_combat_ped(v, v2,0,16)
							INT =((INT == 1 and 2) or 1)
							--ntv.doo.clear_task(v2)
							assigned[v2]={}
							assigned[v2].PED=v2
							assigned[v2].GRP=group[INT]
							assigned[v2].TRGT=v
							if ped.is_ped_in_group(v2) then
								ped.remove_ped_from_group(v2)
							end
							ped.set_ped_as_group_member(v2,assigned[v2].GRP)
							funcs.doo.ped_combat_attrib(v2)
							ped.set_ped_never_leaves_group(v2, true)
							ai.task_combat_ped(v2, v,0,16)
							break
						end
					end
				elseif API.Ped.is.in_veh(assigned[v].PED) and API.Ped.is.in_veh(assigned[v].TRGT) and API.Ped.get.veh(assigned[v].PED) == API.Ped.get.veh(assigned[v].TRGT) then
					ai.task_leave_vehicle(assigned[v].PED, API.Ped.get.veh(assigned[v].PED), 0)
					ai.task_leave_vehicle(assigned[v].TRGT, API.Ped.get.veh(assigned[v].TRGT), 0)
				else
					ai.task_combat_ped(assigned[v].PED, assigned[v].TRGT,0,16)
					ai.task_combat_ped(assigned[v].TRGT, assigned[v].PED,0,16)
				end
			end
		end
		funcs.doo.yield_while_true(f.on,2000)
	end
	ped.set_relationship_between_groups(2, group[1], group[2])
	ped.set_relationship_between_groups(2, group[2], group[1])
end)

local ped_weap_noti = true
g._ped_weap_toggle=menu_add_feature("Change ped weapons to:","value_str",g.prnt.sssn_peds.id,function(f)
	local notifname = {}
	local all_peds,time,ped_weap_do_noti,attrib
	notifname = g._ped_weap_toggle:get_str_data()
	while f.on do
		YIELD(0)
		if ped_weap_noti then
			g.N_P(2,"Weapon changes are applied every 5 seconds. You will be notified only if it's needed.",__GV__,7,"Blue")
			ped_weap_noti = false
		end
		all_peds = API.Ped.get.all()
		ped_weap_do_noti=true
		for i=1,#all_peds do
			attrib=false
			YIELD(0)
			if funcs.is.good_session_ped(all_peds[i]) and funcs.ntwrk.ask_long(all_peds[i],50) then
				if f.value == 0 then
					weapon.remove_all_ped_weapons(all_peds[i])
					attrib=true
				--elseif	API.Ped.get.weapon(all_peds[i]) ~= ped_models.change_weap_list[f.value+1] then -- crash :(
				elseif not API.wpn.ped_has(all_peds[i], ped_models.change_weap_list[f.value+1]) then
					weapon.remove_all_ped_weapons(all_peds[i])
					if funcs.doo.give_ped_weap(all_peds[i],ped_models.change_weap_list[f.value+1]) then
						attrib=true
					end
				end
				if attrib then
					funcs.doo.ped_combat_attrib(all_peds[i])
					if ped_weap_do_noti then
						g.N_P(2,"Altering ped weapons to "..notifname[f.value+1],__GV__,3,"Green")
						ped_weap_do_noti=false
					end
				end
			end
		end
		time = API.util.t_s() + 5
		while f.on and time > API.util.t_s() do
			YIELD(0)
		end
	end
end)
g._ped_weap_toggle:set_str_data({
"Fists",
"Kuckle Dusters",
"Knife",
"Battle Axe",
"Stungun",
"Heavy revolver mk2",
"Machine-Pistol",
"Up-N-Atomizer",
"Unholy Hellbringer",
"Combat MG Mk2",
"Sniper Rifle",
"Widowmaker",
"EMP Launcher",
"Firework Launcher",
"RPG",
"Railgun"
})


g._peds_shooting_do=menu_add_feature("If peds are shooting:","value_str",g.prnt.sssn_peds.id,function(f)
	local all_peds,ped_veh
	while f.on do
		YIELD(0)
		all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			ped_veh = API.Ped.get.veh(all_peds[i])
			if funcs.is.good_session_ped(all_peds[i]) and API.Ped.is.shooting(all_peds[i]) then
				if f.value < 3 and funcs.ntwrk.ask_long(all_peds[i],50) then
					if f.value == 0 then
						if API.Ped.is.in_veh(all_peds[i]) then
							if funcs.ntwrk.ask_long(ped_veh,100) then
								API.veh.set.engine_on(ped_veh, false, false, true)
								API.veh.set.tire_burst(ped_veh, mth.rndm(0,1), false, 1000.0)
								API.veh.set.tire_burst(ped_veh, mth.rndm(2,4), false, 1000.0)
								API.veh.set.engine_health(ped_veh, -1)
								API.veh.set.plate_text(ped_veh,"Mean-Ped")
							end
							ai.task_leave_vehicle(all_peds[i], ped_veh, 4160)
						else
							API.Ped.set.accuracy(all_peds[i], 100)
						end
					elseif f.value == 1 then
						if API.Ped.is.in_veh(all_peds[i]) then
							if funcs.ntwrk.ask_long(ped_veh,100) then
								API.veh.set.engine_on(ped_veh, false, false, true)
								API.veh.set.tire_burst(ped_veh, mth.rndm(0,1), false, 1000.0)
								API.veh.set.tire_burst(ped_veh, mth.rndm(2,4), false, 1000.0)
								API.veh.set.engine_health(ped_veh, 1)
								API.veh.set.plate_text(ped_veh,"Mean-Ped")
							end
							ai.task_leave_vehicle(all_peds[i], ped_veh, 4160)
						elseif mth.rndm(0,4) == 0 then
							API.ent.force(all_peds[i], 1, mth.rndm(-50,50), mth.rndm(-50,50), 50, 0, 0, 0,   false, true)
						elseif mth.rndm(0,4) == 1 then
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 24, true, false, 0, all_peds[i])
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 24, true, false, 0, all_peds[i])
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 24, true, false, 0, all_peds[i])
						elseif mth.rndm(0,4) == 2 then
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 13, true, false, 0, all_peds[i])
						elseif mth.rndm(0,4) == 3 then
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 11, true, false, 0, all_peds[i])
						else
							fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 21, true, false, 0, all_peds[i])
						end
						API.Ped.set.ragdoll(all_peds[i],1000,1000,0)
					else
						funcs.doo.set_ped_health(all_peds[i],101,50)
						fire.add_explosion(API.ent.get.coords(all_peds[i])+funcs.vec(0,0,-1.5), 14, true, false, 0, all_peds[i])
						fire.start_entity_fire(all_peds[i])
					end
				elseif API.Ped.is.in_veh(all_peds[i]) and funcs.ntwrk.ask_long(ped_veh,100) then
					if f.value == 3 then
						API.ent.set.coords(ped_veh, funcs.vec(mth.rndm(-81,-69),mth.rndm(-826,-813), mth.rndm(327,357)))
					else
						API.ent.set.coords(ped_veh, API.ent.get.coords(ped_veh)+funcs.vec(0,0,200))
					end
				elseif funcs.ntwrk.ask_long(all_peds[i],50) then
					if f.value == 3 then
						API.ent.set.coords(all_peds[i], funcs.vec(mth.rndm(-81,-69),mth.rndm(-826,-813), mth.rndm(327,357)))
					else
						API.ent.set.coords(all_peds[i], API.ent.get.coords(all_peds[i])+funcs.vec(0,0,200))
					end
				end
			end
		end
	end
end)
new_set_str_data(g._peds_shooting_do,{"Jam their gun","Troll","Kill","TP to Maze Bank Top","TP High in air"})


g._all_peds_gods=menu_add_feature("Peds GOD","value_str", g.prnt.sssn_peds.id,function(f)
	while f.on do
		YIELD(5)
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) then
				if f.value == 0 then
					if not API.ent.get.god(all_peds[i]) then
						API.ent.set.god(all_peds[i], true)
					end
				elseif f.value == 1 then
					if API.ent.get.god(all_peds[i]) then
						API.ent.set.god(all_peds[i], false)
					end
				end
			end
		end
	end
end)
new_set_str_data(g._all_peds_gods,{
"Give",
"Remove"})


g._all_peds_freeze=menu_add_feature("Peds freeze","value_str", g.prnt.sssn_peds.id,function(f)
	while f.on do
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) then
				funcs.ntwrk.ask_quick(all_peds[i])
				if f.value == 0 then
					API.ent.set.max_speed(all_peds[i], 0)
				elseif f.value == 1 then
					API.ent.set.max_speed(all_peds[i], 45000)
				end
			end
		end
		funcs.doo.yield_while_true(f.on,1000)
	end
end)
new_set_str_data(g._all_peds_freeze,{
"True",
"False"})


g._all_peds_die=menu_add_feature("Peds health","value_str", g.prnt.sssn_peds.id,function(f)
	while f.on do
		YIELD(25)
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) then
				if f.value == 0 then
					funcs.doo.set_ped_health(all_peds[i],101,25)
				elseif f.value == 1 then
					fire.start_entity_fire(all_peds[i])
					fire.add_explosion(API.ent.get.coords(all_peds[i]),3, true, false, 0,all_peds[i])
				elseif f.value == 2 then
					funcs.doo.set_ped_health(all_peds[i],0,25)
				elseif f.value == 3 then
					fire.add_explosion(API.ent.get.coords(all_peds[i]),0, true, false, 0,all_peds[i])
				end
			end
		end
	end
end)
new_set_str_data(g._all_peds_die,{
"Almost dead",
"Burn to death",
"Dead",
"Explode"})

g._peds_up=menu_add_feature("Peds go up","value_str",g.prnt.sssn_peds.id,function(f)
	while f.on do
		YIELD(0)
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) then
				if API.Ped.is.in_veh(all_peds[i]) then
					local ped_veh = API.Ped.get.veh(all_peds[i])
					funcs.ntwrk.ask_long(ped_veh,50)
					ai.task_leave_vehicle(all_peds[i], ped_veh, 4160)
					YIELD(100)
				elseif f.value == 0 then
					API.ent.set.velocity(all_peds[i],funcs.vec(0,0,1))
				elseif f.value == 1 then
					API.ent.set.velocity(all_peds[i],funcs.vec(0,0,100))
				end
			end
		end
	end
end)
new_set_str_data(g._peds_up,{
"Slowly",
"Rapture"})

g._peds_down=menu_add_feature("Peds come down","value_str",g.prnt.sssn_peds.id,function(f)
	while f.on do
		YIELD(0)
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) and API.ent.is.in_air(all_peds[i]) then
				API.ent.set.gravity(all_peds[i], true)
				if f.value == 0 then
					API.ent.set.velocity(all_peds[i],funcs.vec(0,0,-5))
				elseif f.value == 1 then
					API.ent.set.velocity(all_peds[i],funcs.vec(0,0,-100))
				end
			end
		end
	end
end)
new_set_str_data(g._peds_down,{
"Gently",
"YEET"})

menu_add_feature("Peds bail out","toggle",g.prnt.sssn_peds.id,function(a)
	local ped_bail_count = 0
	while a.on do
		ped_bail_count=ped_bail_count+1
		YIELD(0)
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if ped_bail_count < 100 then
				YIELD(0)
				if funcs.is.good_session_ped(all_peds[i]) and API.Ped.is.in_veh(all_peds[i]) then
					ai.task_leave_vehicle(all_peds[i], API.Ped.get.veh(all_peds[i]), 4160)
				end
			end
		end
		if ped_bail_count > 300 then
			ped_bail_count = 0
		end
	end
end)

menu_add_feature("Random force","toggle",g.prnt.sssn_peds.id,function(f)
	while f.on do
		local all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if funcs.is.good_session_ped(all_peds[i]) then
				if API.Ped.is.in_veh(all_peds[i]) then
					if not funcs.is.any_plyr_in_veh(API.Ped.get.veh(all_peds[i])) then
						funcs.ntwrk.ask_quick(API.Ped.get.veh(all_peds[i]))
						funcs.ntwrk.ask_quick(all_peds[i])
						ai.task_leave_vehicle(all_peds[i], API.Ped.get.veh(all_peds[i]), 4160)
					end
				elseif API.ent.is.in_air(all_peds[i]) then
					funcs.ntwrk.ask_quick(all_peds[i])
					API.ent.set.velocity(all_peds[i],funcs.vec(mth.rndm(-50,50),mth.rndm(-50,50),mth.rndm(-25,-15)))
				else
					funcs.ntwrk.ask_quick(all_peds[i])
					API.ent.set.velocity(all_peds[i],funcs.vec(mth.rndm(-50,50),mth.rndm(-50,50),mth.rndm(10,20)))
				end
			end
		end
		funcs.doo.yield_while_true(f.on,1000)
	end
end)

g.feat.auto_kill_peds = menu_add_feature("Peds targeting me", "value_str",g.prnt.sssn_peds.id,function(f)
	local t,found,pos,my_ped,x,y={}
	local function been_damaged(_attacker)
		for k,v in pairs(t) do
			if ntv.is.ent_dmgd_by_ent(k,_attacker) then
				return true
			end
		end
	end
	while f.on do
		my_ped=funcs.ME._ped()
		t[my_ped]=true
		if funcs.ME._in_veh() then
			veh=funcs.ME._veh()
			t[veh]=true
			for i=1,funcs.get.veh_seats(veh) do
				this_ped=API.veh.get.ped_in_seat(veh, i-2)
				if funcs.is.ped(this_ped) and not t[this_ped] then
					t[this_ped]=true
				end
			end
		end
		x,y = mth.rndm(-10,10)*0.01,mth.rndm(-10,10)*0.01
		for k,v in pairs(API.Ped.get.all()) do
			if funcs.is.good_session_ped(v) then
				if t[ntv.get.ped_jack_target(v)] or t[ntv.get.ped_melee_target(v)] or t[ntv.get.ped_combat_target(v)] or been_damaged(v) then
					if f.value ~= 2 then
						found,pos = API.Ped.get.bone_coords(v, 0x796e, funcs.vec(0,0,0))
						if found then
							gameplay.shoot_single_bullet_between_coords(pos+funcs.vec(x,y,0.1), pos, 1000, f.value == 0 and 100416529 or 1834241177, my_ped, true, false, 1000)
							YIELD(0)
						end
					else
						funcs.doo.set_ped_health(v,0,100)
					end
				end
			end
		end
		funcs.doo.yield_while_true2(f,100)
		funcs.doo.wipe_tbl(t)
	end
end)
new_set_str_data(g.feat.auto_kill_peds,{"Shoot","Explode","Death"})

g._shoot_peds_toggle2=menu_add_feature("Gee-Shoot all peds","value_str", g.prnt.sssn_peds.id,function(f)
	local found,pos,my_ped,hash
	local t  = {[0] = 2000,[1] = 5000,[2] = 10000,[3] = 20000,[4] = 999999}
	local time = TIME_MS()
	while f.on and TIME_MS() < time+t[g._shoot_peds_time.value] do
		my_ped = f.value == 0 and funcs.ME._ped() or funcs.get.non_plyr_ped()
		hash = g._shoot_peds_weap.value == 0 and 100416529 or 1834241177
		local x,y = mth.rndm(-10,10)*0.01,mth.rndm(-10,10)*0.01
		for k,v in pairs(API.Ped.get.all()) do
			if funcs.is.good_session_ped(v) then
				found,pos = API.Ped.get.bone_coords(v, 0x796e, funcs.vec(0,0,0))
				if found then
					gameplay.shoot_single_bullet_between_coords(pos+funcs.vec(x,y,0.1), pos, 1000, hash, my_ped, true, false, 1000)
					YIELD(0)
				end
			end
		end
		YIELD(100)
	end
	f.on=false
end)
new_set_str_data(g._shoot_peds_toggle2,{"Blame me","Anonymous"})


g._shoot_peds_time=menu_add_feature("Shoot all peds for:","autoaction_value_str",g.prnt.sssn_peds.id)
new_set_str_data(g._shoot_peds_time,{"2 seconds", "5 seconds","10 seconds","20 seconds","Until I turn it off"})

g._shoot_peds_weap=menu_add_feature("Shoot all peds with:","autoaction_value_str",g.prnt.sssn_peds.id)
g._shoot_peds_weap:set_str_data({"Sniper bullets", "Railgun"})


-----------------------------------------------------------------------------------------GEE-SKID
------------------------------------------------------------------------------------------Options
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------

g.tbl.dist_type_str = {
[0] = "m",
[1] = "km",
[2] = "ft",
[3] = "yard",
[4] = "field",
[5] = "mile",
[6] = "asiandick",
[7] = "bbc"
}

g.var.bounce_size=1
g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	local flip=true
	while true do
		if flip then
			g.var.bounce_size = g.var.bounce_size * .995
			if g.var.bounce_size < 1 then flip = false end
		else
			g.var.bounce_size = g.var.bounce_size * 1.005
			if g.var.bounce_size > 2 then flip = true end
		end
		YIELD(0)
	end
end)

g._waypoint_esp=menu_add_feature("Waypoint ESP","value_str", g.prnt.utils_info_wp.id, function(f)
	local pos,mult,flip,dist_type,wp,size,screen_pos,me,color
	local script_size = funcs.get.SD_size(f.on)
	local color=funcs.get.rgba_to_int(164, 76, 242,255)
	while not g.tbl.RADAR or not g.tbl.RADAR.waypoint do
		YIELD(0)
	end
	while f.on do
		mult = 1
		flip = true
		if g.var.wp_low.x ~=0 and g.var.wp_low.y ~= 0 then
			wp = funcs.vec(g.var.wp_low.x,g.var.wp_low.y,g.var.wp_low.z)
			while g.var.wp_low.x == wp.x and g.var.wp_low.y == wp.y and f.on do
				if not g.feat.map_tp.on and not ntv.is.paused() then
					if g._waypoint_esp_on_screen.on then
						screen_pos = ntv.get.ent_hud_pos(g.var.wp_low)
						screen_pos = funcs.vec(screen_pos.x/0.5-1,(screen_pos.y/0.5-1)*-1)
					else
						screen_pos = funcs.get.screen_pos_3d(g.var.wp_low)
					end
					if screen_pos then
						size = g._waypoint_esp.value == 3 and g.var.bounce_size or (g._waypoint_esp.value+1) *.69
						API.SD.draw_sprt(g.tbl.RADAR.waypoint,screen_pos,1*size*g.RES_H,0,color)
						if g._waypoint_esp_dist.on then
							API.SD.draw_text(funcs.get.dist_to_str(funcs.get.dist_pospos_v3(funcs.ME._crds(),g.var.wp_low),g.tbl.dist_type_str[g._waypoint_esp_dist.value]),
							funcs.vec(screen_pos.x+(0.01*size*g.RES_H),screen_pos.y), screen_pos, .5*size*script_size*g.RES_H, color,1 << 1, 0)
						end
					end
				end
				YIELD(5)
			end
		end
		YIELD(500)
	end
end)
new_set_str_data(g._waypoint_esp,{"Small","Medium","Large","Bounce"})
funcs.add_to_S_L(g._waypoint_esp,"g._waypoint_esp")
g._waypoint_esp.on=true
g._waypoint_esp.value=3

g._waypoint_esp_dist=menu_add_feature("Show waypoint ESP distance","value_str", g.prnt.utils_info_wp.id)
new_set_str_data(g._waypoint_esp_dist,{"Meters","Kilometers","Feet","Yards","Football fields","Miles","Tiny dick","BBC"})
funcs.add_to_S_L(g._waypoint_esp_dist,"g._waypoint_esp_dist")
g._waypoint_esp_dist.on=true

g._waypoint_esp_on_screen=menu_add_feature("Keep waypoint on-screen","toggle", g.prnt.utils_info_wp.id)
funcs.add_to_S_L(g._waypoint_esp_on_screen,"g._waypoint_esp_on_screen")

g._objective_esp=menu_add_feature("Objective ESP","value_str", g.prnt.utils_info_obj.id, function(f)
	local pos,mult,flip,dist_type,wp,size,screen_pos
	local script_size = funcs.get.SD_size(f.on)
	local color=funcs.get.rgba_to_int(240, 200, 80, 255)
	while not g.tbl.RADAR or not g.tbl.RADAR.objective do
		YIELD(0)
	end
	while f.on do
		mult = 1
		flip = true
		while g.var.obj_low.x ~= 0 and g.var.obj_low.y ~= 0 and f.on do
			if not g.feat.map_tp.on and not ntv.is.paused() then
				if g._objective_esp_on_screen.on then
					screen_pos = ntv.get.ent_hud_pos(g.var.obj_low)
					screen_pos = v2(screen_pos.x/0.5-1,(screen_pos.y/0.5-1)*-1)
				else
					screen_pos = funcs.get.screen_pos_3d(g.var.obj_low)
				end

				if screen_pos then
					size = g._objective_esp.value == 3 and g.var.bounce_size or (g._objective_esp.value+1) *.69
					API.SD.draw_sprt(g.tbl.RADAR.objective,screen_pos,0.666*size*g.RES_H,0,color)
					if g._objective_esp_dist.on then
						API.SD.draw_text(
						funcs.get.dist_to_str(funcs.get.dist_pospos_v3(funcs.ME._crds(),g.var.obj_low),g.tbl.dist_type_str[g._objective_esp_dist.value]),
						funcs.vec(screen_pos.x+(0.01*size*g.RES_H),screen_pos.y), screen_pos,
						.5*size*script_size*g.RES_H, color,1 << 1, 0)
					end
				end
			end
			YIELD(5)
		end
		YIELD(500)
	end
end)
new_set_str_data(g._objective_esp,{"Small","Medium","Large","Bounce"})
funcs.add_to_S_L(g._objective_esp,"g._objective_esp")
g._objective_esp.on=true
g._objective_esp.value=3

g._objective_esp_dist=menu_add_feature("Show objective ESP distance","value_str", g.prnt.utils_info_obj.id)
new_set_str_data(g._objective_esp_dist,{"Meters","Kilometers","Feet","Yards","Football fields","Miles","Tiny dick","BBC"})
funcs.add_to_S_L(g._objective_esp_dist,"g._objective_esp_dist")
g._objective_esp_dist.on=true

g._objective_esp_on_screen=menu_add_feature("Keep objective on-screen","toggle", g.prnt.utils_info_obj.id)
funcs.add_to_S_L(g._objective_esp_on_screen,"g._objective_esp_on_screen")

g._pickup_esp=menu_add_feature("Pickup ESP","value_str", g.prnt.utils_info_pckp.id, function(f)
	local pos,size,screen_pos,hash,my_pos,me_at_ship,ship_blip
	local script_size = funcs.get.SD_size(f.on)
	local color=funcs.get.rgba_to_int(114, 204, 114, 255)
	local dont_show={}
	while not g.tbl.RADAR or not g.tbl.RADAR.objective do
		YIELD(0)
	end
	while f.on do
		if not g.feat.map_tp.on and not ntv.is.paused() then
			dont_show[3999186071] = (not g._pickup_esp_show_cash.on)
			dont_show[1374501775] = (not g._pickup_esp_show_PQ.on)
			dont_show[678958360] = (not g._pickup_esp_show_hlth.on)
			dont_show[701173564] = (not g._pickup_esp_show_armr.on)
			my_pos=funcs.ME._crds()
			me_at_ship=funcs.is.v2_in_range(my_pos,2700,3400,-5100,-4200)
			ship_blip=false
			ship_coords=false
			for k,v in pairs(object.get_all_pickups()) do
				if g._pickup_esp_show_weap.on or not ntv.is.pickup_weap_obj_valid(v) then
					if not dont_show[API.ent.get.model_hash(v)] then
						pos = API.ent.get.coords(v)
						ship_coords = funcs.is.v2_in_range(pos,2850,3250,-4950,-4350)
						if me_at_ship or not ship_blip or not ship_coords then
							if ship_coords then
								ship_blip=true
							end
							if g._pickup_esp_on_screen.on then
								screen_pos = ntv.get.ent_hud_pos(pos)
								screen_pos = v2(screen_pos.x/0.5-1,(screen_pos.y/0.5-1)*-1)
							else
								screen_pos = funcs.get.screen_pos_3d(pos)
							end
							if screen_pos then
								size = g._pickup_esp.value == 3 and g.var.bounce_size or (g._pickup_esp.value+1) *.69
								API.SD.draw_sprt(g.tbl.RADAR.objective,screen_pos,0.666*size*g.RES_H,0,color)
								if g._pickup_esp_dist.on then
									API.SD.draw_text(
									funcs.get.dist_to_str(funcs.get.dist_pospos_v3(my_pos,pos),g.tbl.dist_type_str[g._pickup_esp_dist.value]),
									funcs.vec(screen_pos.x+(0.01*size*g.RES_H),screen_pos.y), screen_pos,
									.5*size*script_size*g.RES_H, color,1 << 1, 0)
								end
							end
						end
					end
				end
			end
		end
		YIELD(0)
	end
end)
new_set_str_data(g._pickup_esp,{"Small","Medium","Large","Bounce"})
funcs.add_to_S_L(g._pickup_esp,"g._pickup_esp")
g._pickup_esp.on=true
g._pickup_esp.value=3

g._pickup_esp_dist=menu_add_feature("Show pickup ESP distance","value_str", g.prnt.utils_info_pckp.id)
new_set_str_data(g._pickup_esp_dist,{"Meters","Kilometers","Feet","Yards","Football fields","Miles","Tiny dick","BBC"})
funcs.add_to_S_L(g._pickup_esp_dist,"g._pickup_esp_dist")
g._pickup_esp_dist.on=true

g._pickup_esp_on_screen=menu_add_feature("Keep pickup on-screen","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_on_screen,"g._pickup_esp_on_screen")

g._pickup_esp_show_weap=menu_add_feature("Show dropped weapons","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_show_weap,"g._pickup_esp_show_weap")

g._pickup_esp_show_cash=menu_add_feature("Show dropped cash","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_show_cash,"g._pickup_esp_show_cash")

g._pickup_esp_show_PQ=menu_add_feature("Show P's & Q's","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_show_PQ,"g._pickup_esp_show_PQ")

g._pickup_esp_show_hlth=menu_add_feature("Show health","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_show_hlth,"g._pickup_esp_show_hlth")

g._pickup_esp_show_armr=menu_add_feature("Show armor","toggle", g.prnt.utils_info_pckp.id)
funcs.add_to_S_L(g._pickup_esp_show_armr,"g._pickup_esp_show_armr")


g._pickup_tp=menu_add_feature("TP pickups to me","action",g.prnt.self_teleport_pickups.id, function(f)
	local dont_tp={}
	local tp,tp2,tp3,found={},{},{},{}
	local my_ped = funcs.ME._ped()
	local my_veh = funcs.ME._in_veh() and funcs.ME._veh() or nil
	dont_tp[3999186071] = (not g._pickup_tp_cash.on)
	dont_tp[1374501775] = (not g._pickup_tp_PQ.on)
	dont_tp[678958360] = (not g._pickup_tp_hlth.on)
	dont_tp[701173564] = (not g._pickup_tp_armr.on)
	for k,v in pairs(object.get_all_pickups()) do
		if g._pickup_tp_weap.on or not ntv.is.pickup_weap_obj_valid(v) then
			if not dont_tp[API.ent.get.model_hash(v)] then
				if API.ent.is.attached(v) then
					local ent = API.ent.get.attached(v)
					if ent ~= my_veh and ent ~= my_ped and not found[ent] then--vehicles  have 2 pickups sometimes
						if funcs.is.ped(ent) then
							if API.Ped.is.in_veh(ent) then
								tp3[#tp3+1]=API.Ped.get.veh(ent)
								found[ent]=true
							elseif not API.Ped.is.plyr(ent) then
								tp3[#tp3+1]=ent
								found[ent]=true
							end
						else
							tp3[#tp3+1]=ent
							found[ent]=true
						end
					end
				else
					tp[#tp+1]=v
				end
			end
		end
	end
	local my_pos =  funcs.ME._crds()
	for k,v in pairs(tp) do
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			if funcs.ntwrk.ask_long(v,1500) then
				API.ent.set.coords(v,my_pos+funcs.vec(mth.rndm(-20,20)*0.1,mth.rndm(-20,20)*0.1,0.25))
				API.ent.set.visible(v,true)
			end
		end)
	end
	if #tp3>0 then
		local points=funcs.get.spawn_points(my_pos,#tp3)
		for k,v in pairs(tp3) do
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				if funcs.ntwrk.ask_long(v,1500) then
					if funcs.is.ped(v) then
						API.ent.set.coords(v,my_pos+funcs.vec(mth.rndm(-20,20)*0.1,mth.rndm(-20,20)*0.1,0.25))
					else
						API.ent.set.coords(v,points[k])
					end
					API.ent.set.visible(v,true)
				end
			end)
		end
	end
end)

g._pickup_tp_weap=menu_add_feature("Weapons","toggle", g.prnt.self_teleport_pickups.id)
funcs.add_to_S_L(g._pickup_tp_weap,"g._pickup_tp_weap")

g._pickup_tp_cash=menu_add_feature("Cash","toggle", g.prnt.self_teleport_pickups.id)
funcs.add_to_S_L(g._pickup_tp_cash,"g._pickup_tp_cash")

g._pickup_tp_PQ=menu_add_feature("P's & Q's","toggle", g.prnt.self_teleport_pickups.id)
funcs.add_to_S_L(g._pickup_tp_PQ,"g._pickup_tp_PQ")

g._pickup_tp_hlth=menu_add_feature("Health drops","toggle", g.prnt.self_teleport_pickups.id)
funcs.add_to_S_L(g._pickup_tp_hlth,"g._pickup_tp_hlth")

g._pickup_tp_armr=menu_add_feature("Armor drops","toggle", g.prnt.self_teleport_pickups.id)
funcs.add_to_S_L(g._pickup_tp_armr,"g._pickup_tp_armr")

g._show_otr_blips=menu_add_feature("Show off-the-radar blips","toggle", g.prnt.utils_info.id, function(f)
	if not f.on then
		for i=1,#g.tbl.PID_INFO.otr_blip do
			if g.tbl.PID_INFO.otr_blip[i] >-1 then -- remove any green otr blips
				ui.remove_blip(g.tbl.PID_INFO.otr_blip[i])
				g.tbl.PID_INFO.otr_blip[i] = -1
			end
		end
	end
end)
funcs.add_to_S_L(g._show_otr_blips,"g._show_otr_blips")
g._show_otr_blips.on=true

g._show_undead_blips=menu_add_feature("Show un-dead blips","toggle", g.prnt.utils_info.id, function(f)
	if not f.on then
		for i=1,#g.tbl.PID_INFO.undead_blip do
			if g.tbl.PID_INFO.undead_blip[i] >-1 then -- remove any black undead blips
				ui.remove_blip(g.tbl.PID_INFO.undead_blip[i])
				g.tbl.PID_INFO.undead_blip[i] = -1
			end
		end
	end
end)
funcs.add_to_S_L(g._show_undead_blips,"g._show_undead_blips")
g._show_undead_blips.on=true

g.feat.ped_blips = menu_add_feature("Add blips to mean peds", "value_str",g.prnt.utils_info.id,function(f)
	local t,veh,this_ped,blip={}
	local cop_hash = API.get_hash_key("COP")
	while f.on do
		t[funcs.ME._ped()]=true
		if funcs.ME._in_veh() then
			veh=funcs.ME._veh()
			t[veh]=true
			if f.value == 1 then
				for i=1,funcs.get.veh_seats(veh) do
					this_ped=API.veh.get.ped_in_seat(veh, i-2)
					if funcs.is.ped(this_ped) and not t[this_ped] then
						t[this_ped]=true
					end
				end
			end
		end
		for k,v in pairs(API.Ped.get.all()) do
			if not API.Ped.is.plyr(v) and ui.get_blip_from_entity(v) == 0 and API.Ped.get.rel_group_hash(v) ~= cop_hash then
				if not API.Ped.is.in_veh(v) or ui.get_blip_from_entity(API.Ped.get.veh(v)) == 0 then
					if t[ntv.get.ped_jack_target(v)] or t[ntv.get.ped_melee_target(v)] or t[ntv.get.ped_combat_target(v)] then
						blip = ui.add_blip_for_entity(v)
						ntv.set.blip_sprite(blip,270)
						ui.set_blip_colour(blip, 1)
						ntv.set.blip_scale(blip,0.75)
						g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
							local blip,PED = blip,v
							while funcs.is.ped(PED) and not API.ent.is.dead(PED) do
								if API.Ped.is.in_veh(PED) and ui.get_blip_from_entity(API.Ped.get.veh(v)) ~= 0 then
									break
								else
									YIELD(500)
								end
							end
							ui.remove_blip(blip)
						end)
					end
				end
			end
		end
		funcs.doo.yield_while_true2(f,1000)
		funcs.doo.wipe_tbl(t)
	end
end)
new_set_str_data(g.feat.ped_blips,{"Targeting me","Anyone in my vehicle"})
funcs.add_to_S_L(g.feat.ped_blips,"g.feat.ped_blips")

g.feat.force_ceo_mc_blip_heading2=menu_add_feature("Force CEO/MC blip heading", "toggle",g.prnt.utils_info.id,function(f)
	while f.on do
		for pid=0,31 do
			if API.plyr.is.valid(pid) and ntv.get.blip_sprite(ui.get_blip_from_entity(API.plyr.get.ped(pid)))== 364 then
				ntv.doo.force_blip_heading(ui.get_blip_from_entity(API.plyr.get.ped(pid)),1)
			end
		end
		funcs.doo.yield_while_true2(f,1000)
	end
	for pid=0,31 do
		if API.plyr.is.valid(pid) and ntv.get.blip_sprite(ui.get_blip_from_entity(API.plyr.get.ped(pid)))== 364 then
			ntv.doo.force_blip_heading(ui.get_blip_from_entity(API.plyr.get.ped(pid)),0)
		end
	end
end)
funcs.add_to_S_L(g.feat.force_ceo_mc_blip_heading2,"g.feat.force_ceo_mc_blip_heading2")
g.feat.force_ceo_mc_blip_heading2.on=true

menu_add_feature("Show all modder info", "action", g.prnt.utils_info.id, function(f)
	--thank you toph
	local flag,list = 1,{}
	while flag < player.get_modder_flag_ends() do
		local name = player.get_modder_flag_text(flag)
		list[flag]=player.get_modder_flag_text(flag)
		flag = flag * 2
	end
	local name,count = ""
	for pid=0,31 do
		if funcs.is.valid_pid(pid) and API.plyr.is.modder(pid,-1) then
			name = name .. funcs.get.pid_name(pid)..": "
			count = 0
			for k,v in pairs(list) do
				if API.plyr.is.modder(pid,k) then
					count=count+1
					if count > 1 then
						name=name..","
					end
					name=name.." "..v
				end
			end
			name=name.."\n"
		end
	end
	if name ~= "" then
		g.N_P(2,name,__GV__,10,"Blue")
	else
		g.N_P(2,"No modders in session.",__GV__,3,"Blue")
	end
end)

g._show_voidkot=menu_add_feature("Splash screen","toggle", g.prnt.optns.id)
funcs.add_to_S_L(g._show_voidkot,"g._show_voidkot")
g._show_voidkot.on=true

g.tbl.veh_info_entry = {}
g.tbl.veh_info_entry.feat=menu_add_feature("Display vehicle info upon entry", "toggle", g.prnt.self_veh_crrnt_info.id, function(f)
	local my_veh
	while f.on do
		YIELD(100)
		if funcs.ME._in_veh() then
			if my_veh ~= API.plyr.get.veh(API.plyr.my_id()) then
				YIELD(125)
				my_veh=API.plyr.get.veh(API.plyr.my_id())
				funcs.doo.display_veh_info(
				my_veh,
				g.tbl.veh_info_entry.speed.on,
				g.tbl.veh_info_entry.speed.value==0,
				g.tbl.veh_info_entry.dmnsns.on,
				g.tbl.veh_info_entry.dmnsns.value==0,
				g.tbl.veh_info_entry.god.on,
				g.tbl.veh_info_entry.hlth.on,
				g.tbl.veh_info_entry.hlth.value==0,
				g.tbl.veh_info_entry.weap.on,
				g.tbl.veh_info_entry.hash.on,
				g.tbl.veh_info_entry.gtaid.on,
				false,
				false,
				g.tbl.veh_info_entry.occpnts.on
				)
			end
		end
	end
end)
funcs.add_to_S_L(g.tbl.veh_info_entry.feat,"g.tbl.veh_info_entry.feat")

g.tbl.veh_info_entry.speed=menu_add_feature("Show max speed", "value_str", g.prnt.self_veh_crrnt_info.id)
new_set_str_data(g.tbl.veh_info_entry.speed,{"MPH","KPH"})
funcs.add_to_S_L(g.tbl.veh_info_entry.speed,"g.tbl.veh_info_entry.speed")

g.tbl.veh_info_entry.dmnsns=menu_add_feature("Show dimensions", "value_str", g.prnt.self_veh_crrnt_info.id)
new_set_str_data(g.tbl.veh_info_entry.dmnsns,{"Meters","Feet"})
funcs.add_to_S_L(g.tbl.veh_info_entry.dmnsns,"g.tbl.veh_info_entry.dmnsns")

g.tbl.veh_info_entry.god=menu_add_feature("Show god", "toggle", g.prnt.self_veh_crrnt_info.id)
funcs.add_to_S_L(g.tbl.veh_info_entry.god,"g.tbl.veh_info_entry.god")

g.tbl.veh_info_entry.weap=menu_add_feature("Show weapons", "toggle", g.prnt.self_veh_crrnt_info.id)
funcs.add_to_S_L(g.tbl.veh_info_entry.weap,"g.tbl.veh_info_entry.weap")

g.tbl.veh_info_entry.hlth=menu_add_feature("Show health", "value_str", g.prnt.self_veh_crrnt_info.id)
new_set_str_data(g.tbl.veh_info_entry.hlth,{"Total health","Engine and body"})
funcs.add_to_S_L(g.tbl.veh_info_entry.hlth,"g.tbl.veh_info_entry.hlth")

g.tbl.veh_info_entry.hash=menu_add_feature("Show hash", "toggle", g.prnt.self_veh_crrnt_info.id)
funcs.add_to_S_L(g.tbl.veh_info_entry.hash,"g.tbl.veh_info_entry.hash")

g.tbl.veh_info_entry.gtaid=menu_add_feature("Show vehicle ID#", "toggle", g.prnt.self_veh_crrnt_info.id)
funcs.add_to_S_L(g.tbl.veh_info_entry.gtaid,"g.tbl.veh_info_entry.gtaid")

g.tbl.veh_info_entry.occpnts=menu_add_feature("Show occupants", "toggle", g.prnt.self_veh_crrnt_info.id)
funcs.add_to_S_L(g.tbl.veh_info_entry.occpnts,"g.tbl.veh_info_entry.occpnts")

g.tbl.veh_info_entry.scnds=menu_add_feature("Notification seconds", "action_value_i", g.prnt.self_veh_crrnt_info.id)
funcs.set_feat_i_f(g.tbl.veh_info_entry.scnds,1,15,1,10,"g.tbl.veh_info_entry.scnds")

function funcs.doo.display_veh_info(_veh,_speed,_speed_type,_size,_size_type,_god,_health,_health_cmbnd,_weap,_hash,_gtaid,_dist,_dist_type,_occpnts)

	local msg=""
	if API.veh.get.brand(_veh) == nil then
		msg=msg..funcs.get.veh_model_name(_veh)
	else
		msg=msg..API.veh.get.brand(_veh).."   " .. funcs.get.veh_model_name(_veh)
	end
	msg=msg.."\n"..API.veh.get.class_name(_veh).."  "..vehicle.get_vehicle_wheel_count(_veh).."-Wheels  "..funcs.get.veh_seats(_veh).."-Seats"
	local owner = decorator.decor_get_int(_veh, "Player_Vehicle")
	if owner > 0 then
		for i=1,32 do
			if g.tbl.PID_INFO.net_hash[i]==owner then
				if funcs.is.valid_pid(i-1) then
					msg=msg.."\nOwner: "..funcs.get.pid_name(i-1)
				else
					msg=msg.."\nUnknown personal vehicle"
				end
				break
			end
		end
	end
	if _speed then
		if _speed_type then
			msg=msg.."\nEstimated max-speed: "..tostring(funcs.get._1_dec(vehicle.get_vehicle_estimated_max_speed(_veh)*2.65).." mph") --idk why gta reports the values different
		else
			msg=msg.."\nEstimated max-speed: "..tostring(funcs.get._1_dec(vehicle.get_vehicle_estimated_max_speed(_veh)*4.2647).." kph") -- but max speed requires different math than entity speed
		end
	end
	if _size then
		local _min,_max = API.ent.get.dimensions(_veh)
		if _min ~= nil and _max ~= nil then
			if _size_type then
				msg=msg.."\nL:"..funcs.get.dist_to_str(_max.y+mth.abs(_min.y),"m").."   W:"..funcs.get.dist_to_str(_max.x+mth.abs(_min.x),"m").."   H:"..funcs.get.dist_to_str(_max.z+mth.abs(_min.z),"m")
			else
				msg=msg.."\nL:"..funcs.get.dist_to_str(_max.y+mth.abs(_min.y),"ft").."   W:"..funcs.get.dist_to_str(_max.x+mth.abs(_min.x),"ft").."   H:"..funcs.get.dist_to_str(_max.z+mth.abs(_min.z),"ft")
			end
		end
	end
	if _god or _weap then
		msg=msg.."\n"
		if _god then
			msg=msg.."God: "..string.upper(tostring(API.ent.get.god(_veh)))
		end
		if _weap then
			if _god then
				msg=msg.."  "
			end
			msg=msg.."Weapons: "..string.upper(tostring(ntv.is.veh_have_weap(_veh)))
		end
	end
	if _health then
		if _health_cmbnd then
			msg=msg.."\nVehicle health: "..funcs.get._1_dec(funcs.get.veh_cmbnd_health_prcnt(_veh,true)).."%"
		else
			msg=msg.."\nEngine: "..funcs.get._1_dec(ntv.get.veh_engine_health(_veh,true)).."%".."  Body: "..funcs.get._1_dec(ntv.get.veh_body_health(_veh,true)).."%"
		end
	end
	if _hash or _gtaid then
		msg=msg.."\n"
		if _hash then
			msg=msg.."Hash: "..API.ent.get.model_hash(_veh)
		end
		if _gtaid then
			if _hash then
				msg=msg.."  "
			end
			msg=msg.."Veh# ".._veh
		end
	end
	if _dist and not funcs.ME._in_that_veh(_veh) then
		if _dist_type then
			msg=msg.."\nDistance: "..funcs.get.dist_to_str(funcs.get.dist_me_ent_3d(_veh),"m")
		else
			msg=msg.."\nDistance: "..funcs.get.dist_to_str(funcs.get.dist_me_ent_3d(_veh),"ft")
		end
	end
	if _occpnts then
		local plyrs,plyr_count="",0
		local ped_count=0
		for s = 1, funcs.get.veh_seats(_veh) do
			if funcs.is.ent(API.veh.get.ped_in_seat(_veh, s-2)) then
				if API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, s-2)) then
					plyr_count=plyr_count+1
					plyrs=plyrs..funcs.get.pid_name(API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(_veh, s-2))).." "
				else
					ped_count=ped_count+1
				end
			end
		end
		if plyr_count > 0 or ped_count > 0 then
			msg=msg.."\n"
			if ped_count > 0 then
				msg=msg.."Peds: "..ped_count.."  "
			end
			if plyr_count > 0 then
				msg=msg.."Players: "..plyrs
			end
		end
	end
	g.N_P(2,msg,__GV__,g.tbl.veh_info_entry.scnds.value,"Blue")
end

-----------------------------Driftmod---------------Idk who made this but its one of my favorites -- it was sfinktah and proddy
-----------------------------------------------------------I didnt change a thing on how it works
------------------------------------------------------------------------i just added some options
g.tbl.drift_main = {}

g.tbl.drift_main.feat = menu_add_feature("Driftmod v1.1", "toggle", g.prnt.self_veh_crrnt_drift.id, function(f)
	if funcs.is.GS_loaded() and f.on then
		g.N_P(2,"Driftmod v1.1\nCredit to sfinktah and proddy. I just added some options.\nHold shift/duck to drift",__GV__,7,"Blue")
	end
	local gs_driftMinSpeed,gs_driftMaxAngle = 8.0,50.0
	local ControlVehicleBrake,ControlVehicleSelectNextWeapon = 72,99
	local isDrifting,prevGripState,oldGripState = 0,0,0
	local isDriftFinished,lastDriftAngle = 1,0.0
	local veh,driftKeyPressed,driftAngle,zeroBasedDriftAngle,style
	local function get_driftAngle()
		driftAngle = API.ent.get.heading(veh) - mth.fmod(270.0 + mth.deg(mth.atan(API.ent.get.velocity(veh).y, API.ent.get.velocity(veh).x)), 360.0)
		if driftAngle and lastDriftAngle and driftAngle - lastDriftAngle ~= 180.0 then -- this doesnt seem necessary and works without it
			driftAngle = driftAngle - 360.0
		end
		while (driftAngle < 0.0) do
			driftAngle = driftAngle + 360.0
		end
		while (driftAngle > 360.0) do
			driftAngle = driftAngle - 360.0
		end
	end
	local function get_zeroBasedDriftAngle()
		zeroBasedDriftAngle = 360 - driftAngle
		if zeroBasedDriftAngle > 180 then
			zeroBasedDriftAngle = 0 - (360 - zeroBasedDriftAngle)
		end
	end
	local function driftmod_ontick()
		local kmh = API.ent.get.speed(veh) * 3.6
		gs_driftMaxAngle = g.tbl.drift_main.angle_feat.value
		style = g.tbl.drift_main.style_feat.value
		if style == 2 then
			vehicle.set_vehicle_reduce_grip(veh, false)
		end
		if not isDrifting and not isDriftFinished then
			isDriftFinished = true
		end
		driftKeyPressed = g.tbl.drift_main.key_pressed()
		if driftKeyPressed then
			if vehicle.get_vehicle_current_gear(veh) > 2 then -- this doesnt seem to change anything but i guess i'll keep it
				vehicle.set_vehicle_current_gear(veh, 2)
				vehicle.set_vehicle_next_gear(veh, 2)
			end
			if (API.cntrl.get.normal(2, ControlVehicleBrake) > 0.1) then
				controls.set_control_normal(0, ControlVehicleBrake, 0)
				local neg = -0.3
				if (controls.is_control_pressed(2, ControlVehicleSelectNextWeapon)) then
					neg = 10
				end
				if (API.veh.is.on_all_wheels(veh) and not API.ent.is.in_air(veh)) then
					API.ent.force(veh,1,0,0,(neg * 1 * API.cntrl.get.normal(2, ControlVehicleBrake)),0,0,0,true,true)
				end
			end
			get_driftAngle()
			lastDriftAngle = driftAngle
			get_zeroBasedDriftAngle()
			local done = false
			if ((isDrifting or kmh > gs_driftMinSpeed) and (mth.abs(driftAngle - 360.0) < gs_driftMaxAngle) or (driftAngle < gs_driftMaxAngle)) then
				isDrifting,isDriftFinished = 1,1
				if style ~= 2 and driftKeyPressed and driftKeyPressed ~= oldGripState then
					vehicle.set_vehicle_reduce_grip(veh, driftKeyPressed)
					oldGripState = driftKeyPressed
				end
				done = true
			end
			if not done and kmh < gs_driftMinSpeed then
				if style ~= 2 and driftKeyPressed and driftKeyPressed ~= oldGripState then
					vehicle.set_vehicle_reduce_grip(veh, driftKeyPressed)
					oldGripState = driftKeyPressed
				end
				done = true
			end
			if not done then
				if style ~= 2 and driftKeyPressed == oldGripState then
					vehicle.set_vehicle_reduce_grip(veh, false)
					oldGripState = 0
				end
				if g.tbl.drift_main.style_feat.value ~= 1 and  mth.abs(zeroBasedDriftAngle) > gs_driftMaxAngle then
					vehicle.set_vehicle_steer_bias(veh, mth.rad(zeroBasedDriftAngle * 0.69))
					if zeroBasedDriftAngle > 0 then
						if g.tbl.drift_main.cntr_notif_feat.on then
							g.N_P(2,"Driftmod v1.1 Counter-steering left",__GV__,1,"Blue")
						end
						if g.tbl.drift_main.blnkrs_feat.on then
							vehicle.set_vehicle_indicator_lights(veh, 0, true)
							vehicle.set_vehicle_indicator_lights(veh, 1, false)
						end
					else
						if g.tbl.drift_main.blnkrs_feat.on then
							vehicle.set_vehicle_indicator_lights(veh, 1, true)
							vehicle.set_vehicle_indicator_lights(veh, 0, false)
						end
						if g.tbl.drift_main.cntr_notif_feat.on then
							g.N_P(2,"Driftmod v1.1 Counter-steering right",__GV__,1,"Blue")
						end
					end
				end
			else
				vehicle.set_vehicle_indicator_lights(veh, 0, false)
				vehicle.set_vehicle_indicator_lights(veh, 1, false)
			end
		end
		if not driftKeyPressed and prevGripState then
			isDrifting,isDriftFinished,lastDriftAngle = 0,0,0
			if style ~= 2 and driftKeyPressed ~= oldGripState then
				vehicle.set_vehicle_reduce_grip(veh, driftKeyPressed)
				oldGripState = driftKeyPressed
			end
		end
		prevGripState = driftKeyPressed
	end
	while f.on do
		YIELD(100)
		if g.tbl.drift_main.key_pressed() and g.tbl.drift_main.good_veh() then
			while f.on and g.tbl.drift_main.key_pressed() and funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id())) and funcs.ntwrk.ask_have(API.plyr.get.veh(API.plyr.my_id())) do
				YIELD(0)
				veh = API.plyr.get.veh(API.plyr.my_id())
				driftmod_ontick()
			end
		elseif funcs.is.veh(veh) then
			vehicle.set_vehicle_indicator_lights(veh, 0, false)
			vehicle.set_vehicle_indicator_lights(veh, 1, false)
			vehicle.set_vehicle_reduce_grip(veh, false)
			veh = nil
		end
	end
end)
funcs.add_to_S_L(g.tbl.drift_main.feat,"g.tbl.drift_main.feat")
-----------------------------------------------------------------------------------------GEE-SKID
------------------------------------------------------------------------------------------Options
------------------------------------------------------------------------------------------Drift_O
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
g.tbl.drift_main.test_bool=false

function g.tbl.drift_main.good_veh()

	if funcs.ME._driving(API.plyr.get.veh(API.plyr.my_id())) and not API.ent.is.in_air(API.plyr.get.veh(API.plyr.my_id())) then
		local class = API.veh.get.class(API.plyr.get.veh(API.plyr.my_id()))
		if class ~= 8 and class ~= 14 and class ~= 15 and class ~= 16 and class ~= 21 then --bikes,motorcycles,planes,helos,trains
			return true
		end
	end
	return false
end

function g.tbl.drift_main.key_pressed()
	local ControlVehicleDuck,L_shift,ControlVehicleBrake = 73,209,72
	if g.tbl.drift_main.rvrs_feat.on and (controls.is_control_pressed(2, ControlVehicleBrake) or controls.is_disabled_control_pressed(2, ControlVehicleBrake)) then
		return false
	elseif g.tbl.drift_main.key_feat.value == 0 then
		return (controls.is_control_pressed(2, ControlVehicleDuck) or controls.is_disabled_control_pressed(2, ControlVehicleDuck) or controls.is_control_pressed(0, L_shift) or controls.is_disabled_control_pressed(0, L_shift))
	elseif g.tbl.drift_main.key_feat.value == 1 then
		return (controls.is_control_pressed(0, L_shift) or controls.is_disabled_control_pressed(0, L_shift))
	end
	return (controls.is_control_pressed(2, ControlVehicleDuck) or controls.is_disabled_control_pressed(2, ControlVehicleDuck))
end

g.tbl.drift_main.rec_feat = menu_add_feature("Apply recommended settings?", "action", g.prnt.self_veh_crrnt_drift_optns.id, function()
g.tbl.drift_main.rec_do()
end)

g.tbl.drift_main.style_feat = menu_add_feature("Drift style", "autoaction_value_str", g.prnt.self_veh_crrnt_drift_optns.id, function(f)
	if f.value == 1 then
		g.tbl.drift_main.cntr_notif_test_feat.hidden=true
		g.tbl.drift_main.cntr_notif_feat.hidden=true
		g.tbl.drift_main.blnkrs_feat.hidden=true
	else
		g.tbl.drift_main.cntr_notif_test_feat.hidden=false
		g.tbl.drift_main.cntr_notif_feat.hidden=false
		g.tbl.drift_main.blnkrs_feat.hidden=false
	end
end)
new_set_str_data(g.tbl.drift_main.style_feat,{"Both", "Reduced grip","Counter-steer"})
funcs.add_to_S_L(g.tbl.drift_main.style_feat,"g.tbl.drift_main.style_feat")

g.tbl.drift_main.angle_feat = menu_add_feature("Drift angle", "action_value_i", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.angle_feat,40,70,1,40,"g.tbl.drift_main.angle_feat")

g.tbl.drift_main.key_feat = menu_add_feature("Drift key", "action_value_str", g.prnt.self_veh_crrnt_drift_optns.id)
new_set_str_data(g.tbl.drift_main.key_feat,{"Both", "Left shift","Duck"})
funcs.add_to_S_L(g.tbl.drift_main.key_feat,"g.tbl.drift_main.key_feat")

g.tbl.drift_main.rvrs_feat = menu_add_feature("Ignore reverse/brakes", "toggle", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.add_to_S_L(g.tbl.drift_main.rvrs_feat,"g.tbl.drift_main.rvrs_feat")

g.tbl.drift_main.blnkrs_feat = menu_add_feature("Counter-steer indicator lights", "toggle", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.add_to_S_L(g.tbl.drift_main.blnkrs_feat,"g.tbl.drift_main.blnkrs_feat")

g.tbl.drift_main.cntr_notif_feat = menu_add_feature("Counter-steer notifications", "toggle", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.add_to_S_L(g.tbl.drift_main.cntr_notif_feat,"g.tbl.drift_main.cntr_notif_feat")

g.tbl.drift_main.cntr_notif_test_feat = menu_add_feature("Display counter-steer test notification?", "action", g.prnt.self_veh_crrnt_drift_optns.id, function()
	g.N_P(2,"Driftmod v1.1 counter-steer test notification",__GV__,1,"Blue")
end)

g.tbl.drift_main.overlays_feat = menu_add_feature("Ready/Active overlay", "value_str", g.prnt.self_veh_crrnt_drift_optns.id, function(f)
	g.tbl.drift_main.sett_hide(false)
	local alpha,switch,less,more = g.tbl.drift_main.ovrly_ca.value,false
	local function rand_rgb(_val,_ofst,_bool)
		local _less,_more
		if _val-_ofst < 0 then
			_less = 0
			_more = 0+(2*_ofst)
		elseif _val+_ofst > 255 then
			_less = 255-(2*_ofst)
			_more = 255
		else
			_less = _val-_ofst
			_more = _val +_ofst
		end
		if _bool then
			return mth.rndm(_less,_more)
		end
		return _less,_more
	end
	while f.on do
		YIELD(100)
		while f.on and g.tbl.drift_main.feat.on and g.tbl.drift_main.good_veh() and not g.tbl.drift_main.test_bool do
			YIELD(0)
			if g.tbl.drift_main.key_pressed() and f.value ~= 1 then
				funcs.doo.overlay("DRIFT ACTIVE",rand_rgb(g.tbl.drift_main.ovrly_cr.value,50,true),rand_rgb(g.tbl.drift_main.ovrly_cg.value,50,true),rand_rgb(g.tbl.drift_main.ovrly_cb.value,50,true),g.tbl.drift_main.ovrly_ca.value,(g.tbl.drift_main.ovrly_s.value/300*0.99),g.tbl.drift_main.ovrly_f.value,g.tbl.drift_main.ovrly_x.value/mth.rndm(297,303),g.tbl.drift_main.ovrly_y.value/300)
			elseif f.value ~= 2 then
				less,more = rand_rgb(g.tbl.drift_main.ovrly_ca.value,25,false)
				if switch then
					alpha = alpha -.25
					if alpha < less then
						switch = false
					end
				else
					alpha = alpha +.25
					if alpha > more then
						switch = true
					end
				end
				funcs.doo.overlay("DriftMod Ready",g.tbl.drift_main.ovrly_cr.value,g.tbl.drift_main.ovrly_cg.value,g.tbl.drift_main.ovrly_cb.value,mth.flr(alpha),g.tbl.drift_main.ovrly_s.value/300,g.tbl.drift_main.ovrly_f.value,g.tbl.drift_main.ovrly_x.value/300,g.tbl.drift_main.ovrly_y.value/300)
			end
		end
	end
	g.tbl.drift_main.sett_hide(true)
end)
new_set_str_data(g.tbl.drift_main.overlays_feat,{"Both", "Driftmod ready","Driftmod active"})
funcs.add_to_S_L(g.tbl.drift_main.overlays_feat,"g.tbl.drift_main.overlays_feat")

g.tbl.drift_main.ovrly_test_feat = menu_add_feature("Display test overlay?", "action", g.prnt.self_veh_crrnt_drift_optns.id, function(f)
	f.hidden=true
	g.tbl.drift_main.test_bool=true
	g.N_P(2,"Driftmod v1.1 test overlay will display for 15 seconds",__GV__,3,"Blue")
	local time = TIME_MS() + 15000
	while time > TIME_MS() do
		funcs.doo.overlay("DRIFT DRIFT DRIFT",g.tbl.drift_main.ovrly_cr.value,g.tbl.drift_main.ovrly_cg.value,g.tbl.drift_main.ovrly_cb.value,g.tbl.drift_main.ovrly_ca.value,g.tbl.drift_main.ovrly_s.value/300,g.tbl.drift_main.ovrly_f.value,g.tbl.drift_main.ovrly_x.value/300,g.tbl.drift_main.ovrly_y.value/300)
		YIELD(0)
	end
	g.N_P(2,"Driftmod v1.1 test overlay is finished",__GV__,3,"Blue")
	g.tbl.drift_main.test_bool=false
	f.hidden=false
end)

g.tbl.drift_main.ovrly_x = menu_add_feature("X Pos", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_x,0,300,1,1,"g.tbl.drift_main.ovrly_x")

g.tbl.drift_main.ovrly_y = menu_add_feature("Y Pos", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_y,0,300,1,1,"g.tbl.drift_main.ovrly_y")

g.tbl.drift_main.ovrly_s = menu_add_feature("Scale", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_s,75,300,1,1,"g.tbl.drift_main.ovrly_s")

g.tbl.drift_main.ovrly_f = menu_add_feature("Font", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_f,0,9,1,1,"g.tbl.drift_main.ovrly_f")

g.tbl.drift_main.ovrly_cr = menu_add_feature("Red", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_cr,0,255,5,0,"g.tbl.drift_main.ovrly_cr")

g.tbl.drift_main.ovrly_cg = menu_add_feature("Green", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_cg,0,255,5,0,"g.tbl.drift_main.ovrly_cg")

g.tbl.drift_main.ovrly_cb = menu_add_feature("Blue", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_cb,0,255,5,0,"g.tbl.drift_main.ovrly_cb")

g.tbl.drift_main.ovrly_ca = menu_add_feature("Alpha", "action_slider", g.prnt.self_veh_crrnt_drift_optns.id)
funcs.set_feat_i_f(g.tbl.drift_main.ovrly_ca,0,255,5,0,"g.tbl.drift_main.ovrly_ca")

function g.tbl.drift_main.rec_do()
	g.tbl.drift_main.overlays_feat.on=true
	g.tbl.drift_main.overlays_feat.value=0
	g.tbl.drift_main.cntr_notif_feat.on=true
	g.tbl.drift_main.blnkrs_feat.on=true
	g.tbl.drift_main.rvrs_feat.on=true
	g.tbl.drift_main.style_feat.value=0
	g.tbl.drift_main.angle_feat.value=50
	g.tbl.drift_main.ovrly_x.value=26.0
	g.tbl.drift_main.ovrly_y.value=293.0
	g.tbl.drift_main.ovrly_s.value=120.0
	g.tbl.drift_main.ovrly_f.value=0.0
	g.tbl.drift_main.ovrly_cr.value=0.0
	g.tbl.drift_main.ovrly_cg.value=255.0
	g.tbl.drift_main.ovrly_cb.value=0.0
	g.tbl.drift_main.ovrly_ca.value=105.0
end
g.tbl.drift_main.rec_do()

function g.tbl.drift_main.sett_hide(_bool)
	g.tbl.drift_main.ovrly_test_feat.hidden=_bool
	g.tbl.drift_main.ovrly_x.hidden=_bool
	g.tbl.drift_main.ovrly_y.hidden=_bool
	g.tbl.drift_main.ovrly_s.hidden=_bool
	g.tbl.drift_main.ovrly_f.hidden=_bool
	g.tbl.drift_main.ovrly_cr.hidden=_bool
	g.tbl.drift_main.ovrly_cg.hidden=_bool
	g.tbl.drift_main.ovrly_cb.hidden=_bool
	g.tbl.drift_main.ovrly_ca.hidden=_bool
end

g._mods_detex_notify=menu_add_feature("Notify when marked","toggle",g.prnt.utils_mod_dtx.id)
funcs.add_to_S_L(g._mods_detex_notify,"g._mods_detex_notify")
g._mods_detex_notify.on=true

g._mods_detex_otr_tog=menu_add_feature("Off-the-radar > 3 Min","toggle",g.prnt.utils_mod_dtx.id)
funcs.add_to_S_L(g._mods_detex_otr_tog,"g._mods_detex_otr_tog")
g._mods_detex_otr_tog.on=true

g._mods_detex_kd_tog=menu_add_feature("K/D above:","value_f", g.prnt.utils_mod_dtx.id)
funcs.set_feat_i_f(g._mods_detex_kd_tog,3.0,10.0,0.1,5.0,"g._mods_detex_kd_tog")
g._mods_detex_kd_tog.on=true

g._mods_detex_kd_neg_tog=menu_add_feature("Negative K/D","toggle",g.prnt.utils_mod_dtx.id)
funcs.add_to_S_L(g._mods_detex_kd_neg_tog,"g._mods_detex_kd_neg_tog")
g._mods_detex_kd_neg_tog.on=true

g._mods_detex_money_tog=menu_add_feature("Money above:","value_str", g.prnt.utils_mod_dtx.id)
new_set_str_data(g._mods_detex_money_tog,{"500 Million","750 million","1 Billion","1.25 Billion","1.5 Billion","1.75 Billion","2 Billion"})
funcs.add_to_S_L(g._mods_detex_money_tog,"g._mods_detex_money_tog")
g._mods_detex_money_tog.value=2
g._mods_detex_money_tog.on=true

g._mods_detex_rank_tog=menu_add_feature("Rank above:","value_i", g.prnt.utils_mod_dtx.id)
funcs.set_feat_i_f(g._mods_detex_rank_tog,500,7000,50,1000,"g._mods_detex_rank_tog")
g._mods_detex_rank_tog.on=true

g._mods_detex_god_shoot_tog=menu_add_feature("God-Mode","toggle",g.prnt.utils_mod_dtx.id, function(f)
	while not g.var.GS_has_loaded do
		YIELD(500)
	end
	while f.on do
		YIELD(25)
		if funcs.is.good_modder_flag(mddrs.god_flag) then
			for i=0,31 do
				if funcs.is.valid_pid(i) and player.can_player_be_modder(i) and not API.plyr.is.modder(i,mddrs.god_flag) then
					if funcs.is.pid_god_check(i) then
						player.set_player_as_modder(i, mddrs.god_flag)
						if g._mods_detex_notify.on then
							g.N_P(2,funcs.get.pid_name(i).."\nGod-mode.\n --Marking as Modder--",__GV__,7,"Yellow")
						end
					end
					YIELD(25)
				end
			end
		end
	end
end)
funcs.add_to_S_L(g._mods_detex_god_shoot_tog,"g._mods_detex_god_shoot_tog")
g._mods_detex_god_shoot_tog.on=true

function funcs.is.pid_god_check(_pid)
	if g.tbl.PID_INFO.plyr_god[_pid+1] and not g.tbl.PID_INFO.loading[_pid+1] and not g.tbl.PID_INFO.interior[_pid+1] and (API.ent.get.speed(API.plyr.get.ped(_pid)) > 3 or g.tbl.PID_INFO.plyr_moving[_pid+1]) then
		if funcs.is.pid_god_check_params(_pid) then
			return true
		end
	end
	return false
end

function funcs.is.pid_god_check_params(_pid)
	local function veh_dist_check(_pid)
		if not g.tbl.PID_INFO.in_veh[_pid+1] and g.tbl.PID_OSD.dist_table[_pid+1][1] > 250 then
			return false
		elseif g.tbl.PID_INFO.in_veh[_pid+1] and (funcs.is.this_veh(g.tbl.PID_INFO.veh[_pid+1],"minitank") or funcs.is.this_veh(g.tbl.PID_INFO.veh[_pid+1],"rcbandito")) then
			return false
		end
		return true
	end
	local function god(_pid)
		if g.tbl.PID_INFO.plyr_god[_pid+1] and not g.tbl.PID_INFO.loading[_pid+1] and not g.tbl.PID_INFO.interior[_pid+1] then
			return true
		end
		return false
	end
	local function moving(_pid)
		if (API.ent.get.speed(API.plyr.get.ped(_pid)) > 3 or g.tbl.PID_INFO.plyr_moving[_pid+1]) then
			return true
		end
		return false
	end
	YIELD(1000)
	for i=1,50 do
		YIELD(100)
		if not funcs.is.valid_pid(_pid) or not god(_pid) or not veh_dist_check(_pid) or not moving(_pid) then
			return false
		elseif API.Ped.is.shooting(API.plyr.get.ped(_pid)) then
			return true
		end
	end
	return (funcs.is.valid_pid(_pid) and god(_pid))
end

g._mods_detex_undead_tog=menu_add_feature("Un-Dead","toggle",g.prnt.utils_mod_dtx.id)
funcs.add_to_S_L(g._mods_detex_undead_tog,"g._mods_detex_undead_tog")
g._mods_detex_undead_tog.on=true

g.tbl.veh_grief_protex={}
g.tbl.veh_grief_protex.STR ={"Kick from veh",	 "Destroy","Freeze","TP away",		"Fuck their veh","Random force", "Launch"}
g.tbl.veh_grief_protex.A = 	{"kick_pid_from_veh","destroy","freeze","tp",	  		"fucked",		 "random_force", "float"}
g.tbl.veh_grief_protex.V = 	{[0]=pid,					   [2]=0,   [3]="anywhere",					 [5]=25,		 [6]=500}
g.tbl.veh_grief_protex.msg = {}
for i=1,#g.tbl.veh_grief_protex.STR do
	g.tbl.veh_grief_protex.msg[g.tbl.veh_grief_protex.A[i]]=g.tbl.veh_grief_protex.STR[i]
end

g._VehProtexFeat=menu_add_feature("Vehicle grief", "toggle", g.prnt.utils_prtx_veh_grf.id, function(f,pid)
	local pid_history = {}
	local action,val
	local function should_grief(_pid)
		if pid_history[_pid]==nil then
			pid_history[_pid]={TIME = TIME_MS()-1, FAILS = 0}
		end
		if not API.plyr.is.valid(_pid) or not API.plyr.is.in_veh(_pid) or not g.tbl.veh_grief_protex[API.ent.get.model_hash(API.plyr.get.veh(_pid))] or API.ent.is.dead(API.plyr.get.veh(_pid)) then
			pid_history[_pid]={TIME = TIME_MS(), FAILS = 0}
			return false
		elseif pid_history[_pid].TIME > TIME_MS() or API.plyr.my_id() == _pid then
			pid_history[_pid]={TIME = TIME_MS()+1500, FAILS = 0}
			return false
		elseif g._VehProtexPlyrs.value == 2 then
			return true
		elseif API.plyr.is.friend(_pid) then
			pid_history[_pid]={TIME = TIME_MS()+1500, FAILS = 0}
			return false
		elseif g._VehProtexPlyrs.value == 0 and	funcs.is.same_orgmc(_pid,API.plyr.my_id()) then
			pid_history[_pid]={TIME = TIME_MS()+1500, FAILS = 0}
			return false
		end
		return true
	end
	while f.on do
		for pid=0,31 do
			if f.on then
				if should_grief(pid) then
					action = g.tbl.veh_grief_protex[API.ent.get.model_hash(API.plyr.get.veh(pid))].A
					if action ~= "tp" or funcs.get.dist_me_pid_3d(pid) < 500 then
						if action == "kick_pid_from_veh" then
							val = pid
						else
							val =  g.tbl.veh_grief_protex[API.ent.get.model_hash(API.plyr.get.veh(pid))].V
						end
						if funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,action,val) then
							pid_history[pid]={TIME = TIME_MS()+2500, FAILS = 0}
						else
							pid_history[pid].TIME= TIME_MS() + pid_history[pid].FAILS
							if pid_history[pid].FAILS == 0 then
								g.N_P(2,funcs.get.pid_name(pid).."\n"..g.tbl.veh_grief_protex.msg[action].." FAILED :(",__GV__,5,"Red")
							end
							pid_history[pid].FAILS=pid_history[pid].FAILS+1500
						end
					else
						pid_history[pid]={TIME = TIME_MS()+2500, FAILS = 0}
					end
				end
				YIELD(10)
			end
		end
		funcs.doo.yield_while_true(f.on,1000)
	end
end)
funcs.add_to_S_L(g._VehProtexFeat,"g._VehProtexFeat")

g._VehProtexPlyrs=menu_add_feature("Players for grief", "action_value_str", g.prnt.utils_prtx_veh_grf.id)
new_set_str_data(g._VehProtexPlyrs,{"Not Friends/ORG/MC","Not Friends","Anyone"})
funcs.add_to_S_L(g._VehProtexPlyrs,"g._VehProtexPlyrs")

g._VehProtexSetAll=menu_add_feature("Set all to:", "action_value_str", g.prnt.utils_prtx_veh_grf.id,function(f)
	for i=1,#g.tbl.veh_grief_feat_list do
		g.tbl.veh_grief_feat_list[i].value=f.value
	end
	g._VehProtexRamp.value=f.value
	g._VehProtexAvng.value=f.value
end)
new_set_str_data(g._VehProtexSetAll,g.tbl.veh_grief_protex.STR)
funcs.add_to_S_L(g._VehProtexSetAll,"g._VehProtexSetAll")

g._VehProtexTogAll=menu_add_feature("Toggle all", "toggle", g.prnt.utils_prtx_veh_grf.id,function(f)
	for i=1,#g.tbl.veh_grief_feat_list do
		g.tbl.veh_grief_feat_list[i].on=f.on
	end
	g._VehProtexRamp.on=f.on
	g._VehProtexAvng.on=f.on
end)
funcs.add_to_S_L(g._VehProtexTogAll,"g._VehProtexTogAll")

function funcs.doo.sssn_veh_grief_set(_bool,_hash,_f_val)
	if _bool then
		g.tbl.veh_grief_protex[_hash]={
			A = g.tbl.veh_grief_protex.A[_f_val+1],
			V = g.tbl.veh_grief_protex.V[_f_val]
		}
	else
		g.tbl.veh_grief_protex[_hash]=false
	end

end

g._VehProtexAvng=og_menu_add_feature("Avenger", "value_str", g.prnt.utils_prtx_veh_grf.id,function(f)
	funcs.doo.sssn_veh_grief_set(f.on,API.get_hash_key("avenger"),f.value)
	funcs.doo.sssn_veh_grief_set(f.on,API.get_hash_key("avenger2"),f.value)
end)
new_set_str_data(g._VehProtexAvng,g.tbl.veh_grief_protex.STR)
funcs.add_to_S_L(g._VehProtexAvng,"g._VehProtexAvng")

g.tbl.veh_grief_feat_list={}
for i=1,#veh_stuff.grief-2 do
	if i ~= 1 and i ~= 2 then
		g.tbl.veh_grief_feat_list[#g.tbl.veh_grief_feat_list+1]=og_menu_add_feature(veh_stuff.grief[i][3], "value_str", g.prnt.utils_prtx_veh_grf.id,function(f)
			funcs.doo.sssn_veh_grief_set(f.on,veh_stuff.grief[i][1],f.value)
		end)
		new_set_str_data(g.tbl.veh_grief_feat_list[#g.tbl.veh_grief_feat_list],g.tbl.veh_grief_protex.STR)
	end
end

g._VehProtexRamp=og_menu_add_feature("Ramp Buggy", "value_str", g.prnt.utils_prtx_veh_grf.id,function(f)
	funcs.doo.sssn_veh_grief_set(f.on,API.get_hash_key("dune4"),f.value)
	funcs.doo.sssn_veh_grief_set(f.on,API.get_hash_key("dune5"),f.value)
end)
new_set_str_data(g._VehProtexRamp,g.tbl.veh_grief_protex.STR)
funcs.add_to_S_L(g._VehProtexRamp,"g._VehProtexRamp")


g.tbl.aim_grief={}
g.tbl.aim_grief.feats={}
g.tbl.aim_grief.main=menu_add_feature("Aim response grief", "value_str", g.prnt.utils_prtx_aim.id, function(f)
	g.tbl.aim_grief.pid={}
	local function should_grief(_pid)
		if not API.plyr.is.valid(_pid) then
			g.tbl.aim_grief.pid[_pid]=false
			return false
		elseif g.tbl.aim_grief.pid[_pid] then
			return false
		elseif f.value == 2 then
			return true
		elseif API.plyr.is.friend(_pid) then
			return false
		elseif f.value == 0 and	funcs.is.same_orgmc(_pid,API.plyr.my_id()) then
			return false
		end
		return true
	end
	while f.on do
		for pid=0,31 do
			if should_grief(pid) and API.plyr.get.aim_at(pid) == funcs.ME._ped() then
				g.tbl.aim_grief.pid[pid]=true
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local _pid = pid
					local _weap,_weap_once = API.Ped.get.weapon(API.plyr.get.ped(_pid)),false
					local til_death,dead,bitch,helo
					local time = TIME_MS() + 3000
					while API.plyr.is.valid(_pid) and not dead and time > TIME_MS() do
						local distance,head,pos = funcs.get.plyr_moving_pos(_pid)
						pos = funcs.get.front_of_pos(pos,head,distance,180,0.25)
						if g.tbl.aim_grief.feats.kick.on and funcs.doo.kick_plyr(_pid) then
							time = TIME_MS()
						else
							if g.tbl.aim_grief.feats.weap.on then
								if not _weap_once then
									_weap_once=true
									if g.tbl.aim_grief.feats.weap.value == 0 then
										API.wpn.ped_remove(API.plyr.get.ped(_pid), _weap)
									else
										menu.get_feature_by_hierarchy_key("online.online_players.player_".._pid..".weapons.remove_all_weapons"):toggle()
									end
								elseif not til_death then
									g.N_P(2,funcs.get.pid_name(_pid).."\nWeapon(s) removed :)",__GV__,5,"Green")
									time = TIME_MS()
								end
							end
							if g.tbl.aim_grief.feats.burn.on then
								til_death=true
								fire.add_explosion(pos, 3, true, false, 0, _pid)
							end
							if g.tbl.aim_grief.feats.boom.on then
								til_death=true
								fire.add_explosion(pos, 2, true, false, 0, _pid)
							end
							if g.tbl.aim_grief.feats.bitch.on and not funcs.is.ent(bitch) then
								til_death=true
								funcs.doo.req_model(API.get_hash_key("a_f_m_fatcult_01"))
								bitch=funcs.doo.spawn_ped_angry(pos+funcs.vec(1,1,0),API.get_hash_key("a_f_m_fatcult_01"),API.get_hash_key("weapon_machinepistol"),API.get_hash_key("weapon_gusenberg"),_pid,nil)
								YIELD(0)
								if funcs.is.ent(bitch) then
									funcs.doo.set_ped_health(bitch,2500,50)
									funcs.doo.ped_attack_ped_thread(bitch,API.plyr.get.ped(_pid),true,true)
								end
							end
							if g.tbl.aim_grief.feats.helo.on and not funcs.is.ent(helo) then
								til_death=true
								funcs.doo.req_model(1229411063)
								helo = funcs.doo.spawn_veh(pos+funcs.vec(0,0,30),1229411063)
								YIELD(0)
								if funcs.is.ent(helo) then
									g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
										local _helo,__pid = helo,_pid
										API.veh.set.engine_health(_helo, -4000)
										ntv.set.veh_body_health(_helo,0)
										API.veh.set.out_of_control(_helo, false, true)
										funcs.doo.ent_seek_pid(_helo,__pid,60)
										funcs.doo.remove_ent(_helo,1000)
									end)
								end
							end
						end
						YIELD(250)
						dead=(til_death and API.plyr.is.valid(_pid) and API.ent.is.dead(API.plyr.get.ped(_pid)))
						if dead then
							g.N_P(2,funcs.get.pid_name(_pid).."\nMurdered :)",__GV__,5,"Green")
						end
					end
					g.tbl.aim_grief.pid[_pid]=false
				end)
			end
		end
		YIELD(25)
	end
end)
new_set_str_data(g.tbl.aim_grief.main,{"Not Friends/ORG/MC","Not Friends","Anyone"})
funcs.add_to_S_L(g.tbl.aim_grief.main,"g.tbl.aim_grief.main")

function g.tbl.aim_grief.tog(_bool,_feat1,_feat2)
	if _bool then
		local found = false
		for _, feat in pairs(g.tbl.aim_grief.feats) do
			if feat ~= _feat1 and feat.on then
				found = true
			end
		end
		if not found then
			_feat2.on = true
		end
	end
end

g.tbl.aim_grief.feats.boom=menu_add_feature("Explode player","toggle",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.boom,g.tbl.aim_grief.feats.burn)
end)
funcs.add_to_S_L(g.tbl.aim_grief.feats.boom,"g.tbl.aim_grief.feats.boom")

g.tbl.aim_grief.feats.burn=menu_add_feature("Burn player","toggle",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.burn,g.tbl.aim_grief.feats.helo)
end)
funcs.add_to_S_L(g.tbl.aim_grief.feats.burn,"g.tbl.aim_grief.feats.burn")

g.tbl.aim_grief.feats.helo=menu_add_feature("Drop sparrow on player","toggle",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.helo,g.tbl.aim_grief.feats.bitch)
end)
funcs.add_to_S_L(g.tbl.aim_grief.feats.helo,"g.tbl.aim_grief.feats.helo")

g.tbl.aim_grief.feats.bitch=menu_add_feature("Spawn angry fat bitch on player","toggle",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.bitch,g.tbl.aim_grief.feats.weap)
end)
funcs.add_to_S_L(g.tbl.aim_grief.feats.bitch,"g.tbl.aim_grief.feats.bitch")

g.tbl.aim_grief.feats.weap=menu_add_feature("Remove weapons","value_str",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.weap,g.tbl.aim_grief.feats.kick)
end)
new_set_str_data(g.tbl.aim_grief.feats.weap,{"Current weapon", "All weapons"})
funcs.add_to_S_L(g.tbl.aim_grief.feats.weap,"g.tbl.aim_grief.feats.weap")

g.tbl.aim_grief.feats.kick=menu_add_feature("Kick player","toggle",g.prnt.utils_prtx_aim.id,function(f)
	g.tbl.aim_grief.tog(not f.on,g.tbl.aim_grief.feats.kick,g.tbl.aim_grief.feats.boom)
end)
funcs.add_to_S_L(g.tbl.aim_grief.feats.kick,"g.tbl.aim_grief.feats.kick")

g.tbl.aim_grief.feats.boom.on=true




menu_add_feature("Kick all modders only","action",g.prnt.sssn_kicks.id, function()
funcs.doo.sssn_pids_kick("kick",true)
end)

menu_add_feature("Kick selected players below","action",g.prnt.sssn_kicks.id, function()
funcs.doo.sssn_pids_kick("kick")
end)

menu_add_feature("Show selected players below","action",g.prnt.sssn_kicks.id, function()
funcs.doo.sssn_pids_kick("list")
end)

g._kick_plyr_same_orgmc=menu_add_feature("My ORG/MC","toggle",g.prnt.sssn_kicks.id, function(f)
	if not f.on and not g._kick_plyr_my_friend.on and not g._kick_plyr_mddr.on and not g._kick_plyr_others.on then
		g._kick_plyr_my_friend.on=true
	end
end)
funcs.add_to_S_L(g._kick_plyr_same_orgmc,"g._kick_plyr_same_orgmc")

g._kick_plyr_my_friend=menu_add_feature("My Friends","toggle",g.prnt.sssn_kicks.id, function(f)
	if not f.on and not g._kick_plyr_same_orgmc.on and not g._kick_plyr_mddr.on and not g._kick_plyr_others.on then
		g._kick_plyr_mddr.on=true
	end
end)
funcs.add_to_S_L(g._kick_plyr_my_friend,"g._kick_plyr_my_friend")

g._kick_plyr_mddr=menu_add_feature("Modders","toggle",g.prnt.sssn_kicks.id, function(f)
	if not f.on and not g._kick_plyr_my_friend.on and not g._kick_plyr_same_orgmc.on and not g._kick_plyr_others.on then
		g._kick_plyr_others.on=true
	end
end)
funcs.add_to_S_L(g._kick_plyr_mddr,"g._kick_plyr_mddr")

g._kick_plyr_others=menu_add_feature("All other players","toggle",g.prnt.sssn_kicks.id, function(f)
	if not f.on and not g._kick_plyr_my_friend.on and not g._kick_plyr_mddr.on and not g._kick_plyr_same_orgmc.on then
		g._kick_plyr_same_orgmc.on=true
	end
end)
funcs.add_to_S_L(g._kick_plyr_others,"g._kick_plyr_others")
g._kick_plyr_others.on=true

g._kick_plyr_dist=menu_add_feature("Only within distance","value_i",g.prnt.sssn_kicks.id)
funcs.set_feat_i_f(g._kick_plyr_dist,15,1000,15,300,"g._kick_plyr_dist")

function funcs.doo.sssn_pids_kick(_type,_modder)
	local me=API.plyr.my_id()
	local kick_table = {}
	local function should_kick(_pid)
		if _modder then
			return API.plyr.is.modder(_pid,-1)
		elseif API.plyr.is.friend(_pid) then
			if funcs.is.same_orgmc(me,_pid) and not g._kick_plyr_same_orgmc.on then
				return false
			elseif API.plyr.is.modder(_pid,-1) and not g._kick_plyr_mddr.on then
				return false
			end
			return g._kick_plyr_my_friend.on
		elseif funcs.is.same_orgmc(me,_pid) then
			if API.plyr.is.modder(_pid,-1) and not g._kick_plyr_mddr.on then
				return false
			end
			return g._kick_plyr_same_orgmc.on
		elseif API.plyr.is.modder(_pid,-1) then
			return g._kick_plyr_mddr.on
		end
		return g._kick_plyr_others.on
	end
	for pid=0,31 do
		if API.plyr.is.valid(pid) and pid ~= me and should_kick(pid) then
			if _modder or (not g._kick_plyr_dist.on) or (funcs.get.dist_me_pid_3d(pid) < g._kick_plyr_dist.value) then
				kick_table[#kick_table+1]=pid
			end
		end
	end
	if #kick_table == 0 then
		g.N_P(2,"No available players to kick.",__GV__,4,"Blue")
	elseif _type == "list" then
		local message = #kick_table.." player(s) to kick: "
		for i=1,#kick_table do
			message=message..funcs.get.pid_name(kick_table[i])
			if kick_table[i+1] ~= nil then
				message=message..",  "
			end
		end
		g.N_P(2,message,__GV__,7,"Blue")
	elseif _type == "kick" then
		for i=1,#kick_table do
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				funcs.doo.kick_plyr(kick_table[i])
			end)
			YIELD(100)
		end
	end
end



g.print_load_info("Main file contents",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)-------------------------------------------MAIN ENDS
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------UTILS START
g.var.feat_loading_str = "2T1 Radar 2.0"

g.tbl.RADAR = {}
local RADAR_2 = g.tbl.RADAR
RADAR_2.loaded=false


RADAR_2.ents = {}
RADAR_2.ped_colors = {}
RADAR_2.wp_true = false
RADAR_2.wp_pos = v2(10000,10000)
RADAR_2.wp_dist = 10000

function RADAR_2.ents_default(i)
	RADAR_2.ents[i]={PLYR = false,PID=-1,PED=false,DIST = 10000,FRND=false,COLR=0,DEAD = false,D_TIME=TIME_MS(),SHOOT=TIME_MS(),ALPHA=255}
end

function RADAR_2.pos(_pos,_dist)
	_pos = funcs.get.front_of_pos(API.plyr.get.coords(API.plyr.my_id()),funcs.get.vctr_to_pos_z2(_pos,API.plyr.get.coords(API.plyr.my_id()))+API.cam.get.rot().z*-1,_dist, 0, 0)
	_pos.x = (API.plyr.get.coords(API.plyr.my_id()).x-_pos.x)/RADAR_2.range.value
	_pos.y = (API.plyr.get.coords(API.plyr.my_id()).y-_pos.y)/RADAR_2.range.value
	return funcs.vec((RADAR_2.x.value+(_pos.x*RADAR_2.r_size.value*0.124*RADAR_2.xT.value*g.RES_W)),(RADAR_2.y.value+(_pos.y*RADAR_2.r_size.value*0.22*RADAR_2.yT.value*g.RES_H)))
end

-- function RADAR_2.my_cam_pos(_pos)
	-- _pos = funcs.get.front_of_pos(_pos, funcs.get.vctr_to_pos_z2(API.plyr.get.coords(API.plyr.my_id()),_pos)+API.cam.get.rot().z*-1,
	-- mth.abs(v2(API.cam.get.pos().x,API.cam.get.pos().y):magnitude(v2(API.plyr.get.coords(API.plyr.my_id()).x,API.plyr.get.coords(API.plyr.my_id()).y))), 0, 0)
	-- _pos.x = (API.cam.get.pos().x-_pos.x)/RADAR_2.range.value
	-- _pos.y = (API.cam.get.pos().y-_pos.y)/RADAR_2.range.value
	-- return v2((RADAR_2.x.value+(_pos.x*RADAR_2.r_size.value*0.124*RADAR_2.xT.value)),(RADAR_2.y.value+(_pos.y*RADAR_2.r_size.value*0.22*RADAR_2.yT.value)))
-- end



function RADAR_2.head(PID)
	return funcs.get.sprt_rot_calc(API.plyr.get.heading(PID)+API.cam.get.rot().z*-1)
end

function RADAR_2.head2(_PED)
	return funcs.get.sprt_rot_calc(API.ent.get.heading(_PED)+API.cam.get.rot().z*-1)
end

function RADAR_2.dead_chk(_PED)
	if RADAR_2.ents[_PED+1].DEAD then
		return (RADAR_2.ents[_PED+1].D_TIME > TIME_MS())
	end
	return true
end

RADAR_2.feat=menu_add_feature("Show radar", "toggle", g.prnt.utils_info_radar.id, function(f)
	funcs.doo.yield_while_true(not RADAR_2.loaded,2000)
	local flip_time,flip,_r,_g,_b,rings,ring_size,ring_f,ring_color,all_peds,_PED,_PID = TIME_MS()+669,true
	local grey,white,rdr_plyr_name_size = funcs.get.rgba_to_int(100,100,100,255),funcs.get.rgba_to_int(255,255,255,255)
	local function show_self(_bool)
		if RADAR_2.self.on and flip == _bool then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.my_id()+1)
			if API.Ped.is.shooting(API.plyr.get.ped(API.plyr.my_id())) then
				API.SD.draw_sprt(RADAR_2.boom,funcs.vec(RADAR_2.x.value,RADAR_2.y.value),RADAR_2.r_size.value*RADAR_2.p_size.value*.1*.25*g.RES,RADAR_2.head(API.plyr.my_id()),funcs.get.rgba_to_int(255,255,255,RADAR_2.s_a.value))
			end
			API.SD.draw_sprt(RADAR_2.arrow3,funcs.vec(RADAR_2.x.value,RADAR_2.y.value),RADAR_2.r_size.value*RADAR_2.p_size.value*0.1*g.RES,RADAR_2.head(API.plyr.my_id()),funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.s_a.value))
			--API.SD.draw_sprt(RADAR_2.arrow3,RADAR_2.my_cam_pos(API.cam.get.pos()),RADAR_2.r_size.value*RADAR_2.p_size.value*0.1,RADAR_2.head(API.plyr.my_id()),funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.s_a.value))
		end
	end
	local function show_wp(_bool)
		if RADAR_2.wp_true and flip == _bool then
			if glbls.is_mission_active(API.plyr.my_id()) and g.tbl.PID_INFO.color[API.plyr.my_id()+1] > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.my_id()+1) else _r,_g,_b = 164, 76, 242 end
			API.SD.draw_sprt(RADAR_2.waypoint,RADAR_2.pos(RADAR_2.wp_pos,RADAR_2.wp_dist),RADAR_2.r_size.value*RADAR_2.wp_size.value*1.5*g.RES,0,funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.wp_a.value))
		end
	end
	local function show_pers(_bool)
		if RADAR_2.pers_true and flip == _bool then
			if g.tbl.PID_INFO.color[API.plyr.my_id()+1] > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.my_id()+1) else _r,_g,_b = 255, 255, 255 end
			API.SD.draw_sprt(RADAR_2.pers_blip,RADAR_2.pos(RADAR_2.pers_pos,RADAR_2.pers_dist),RADAR_2.r_size.value*RADAR_2.veh_size.value*1.5*g.RES,RADAR_2.pers_rot,funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.veh_a.value))
		end
	end
	local function show_veh(_bool)
		if RADAR_2.veh_true and flip == _bool then
			if g.tbl.PID_INFO.color[API.plyr.my_id()+1] > -1 then
			_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.my_id()+1) else _r,_g,_b = 255, 255, 255 end
			API.SD.draw_sprt(RADAR_2.veh_blip,RADAR_2.pos(RADAR_2.veh_pos,RADAR_2.veh_dist),RADAR_2.r_size.value*RADAR_2.veh_size.value*1.5*g.RES,RADAR_2.veh_rot,funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.veh_a.value))
		end
	end
	local function get_ring()
		if ring_size >= 0.75 then
			return RADAR_2.ring1
		elseif ring_size >= 0.5 then
			return RADAR_2.ring2
		elseif ring_size >= 0.25 then
			return RADAR_2.ring3
		end
		return RADAR_2.ring4
	end
	while f.on do
		RADAR_2.info.on=f.on
		YIELD(5)
		rdr_plyr_name_size = RADAR_2.r_size.value*RADAR_2.p_size.value*RADAR_2.name_s.value*g.RES
		if TIME_MS() > flip_time then
			flip = funcs.get.opp_bool(flip)
			flip_time = TIME_MS()+669
		end
		API.SD.draw_sprt(RADAR_2.circle1,funcs.vec(RADAR_2.x.value,RADAR_2.y.value),RADAR_2.r_size.value*.25*g.RES,0,funcs.get.rgba_to_int(RADAR_2.r.value,RADAR_2.g.value,RADAR_2.b.value,RADAR_2.a.value))
		if RADAR_2.rings_show.on then
			rings = mth.flr(RADAR_2.range.value/RADAR_2.rings_rng.value)
			if rings > 0 then
				ring_size = RADAR_2.rings_rng.value/RADAR_2.range.value
				ring_f = ring_size
				if RADAR_2.rings_opp_color.on then
					ring_color = funcs.get.rgba_to_int((255-RADAR_2.r.value),(255-RADAR_2.g.value),(255-RADAR_2.b.value),RADAR_2.r_a.value)
				else
					ring_color = funcs.get.rgba_to_int(RADAR_2.r_r.value,RADAR_2.r_g.value,RADAR_2.r_b.value,RADAR_2.r_a.value)
				end
				for i=1,rings do
					API.SD.draw_sprt(get_ring(),funcs.vec(RADAR_2.x.value,RADAR_2.y.value),RADAR_2.r_size.value*.25*ring_size*g.RES,0,ring_color)
					ring_size=ring_size+ring_f
				end
			end
		end
		show_self(true)
		show_wp(true)
		show_pers(false)
		show_veh(false)
		all_peds = API.Ped.get.all()
		for i=1,#all_peds do
			_PED = all_peds[i]
			if RADAR_2.ents[_PED+1] ~= nil and funcs.is.ent(_PED) then
				if API.Ped.is.shooting(_PED) then
					RADAR_2.ents[_PED+1].SHOOT = TIME_MS() + 100
				end
				if RADAR_2.ents[_PED+1].DEAD then
					if RADAR_2.dead_chk(_PED) then
						API.SD.draw_sprt(RADAR_2.dead_x,RADAR_2.pos(API.ent.get.coords(_PED),RADAR_2.ents[_PED+1].DIST),RADAR_2.r_size.value*.15*RADAR_2.p_size.value*.1*g.RES,0,grey)
					end
				elseif RADAR_2.ents[_PED+1].PLYR and API.plyr.is.valid(RADAR_2.ents[_PED+1].PID) then
					_PID = RADAR_2.ents[_PED+1].PID
					_POS = RADAR_2.pos(API.plyr.get.coords(_PID),RADAR_2.ents[_PED+1].DIST)
					if RADAR_2.ents[_PED+1].SHOOT  > TIME_MS() then
						API.SD.draw_sprt(RADAR_2.boom,_POS,RADAR_2.r_size.value*RADAR_2.p_size.value*.1*.25*g.RES,RADAR_2.head(_PID),funcs.get.rgba_to_int(255,255,255,RADAR_2.ents[_PED+1].ALPHA))
					end
					API.SD.draw_sprt(RADAR_2.arrow3,_POS,RADAR_2.r_size.value*RADAR_2.p_size.value*.1*g.RES,RADAR_2.head(_PID),RADAR_2.ents[_PED+1].COLR)
					if RADAR_2.name.on then
						if RADAR_2.name_j.value == 1 then
							API.SD.draw_text(funcs.get.pid_name(_PID),_POS+funcs.vec(rdr_plyr_name_size*0.01+RADAR_2.name_x.value,rdr_plyr_name_size*0.007+RADAR_2.name_y.value),_POS,rdr_plyr_name_size,RADAR_2.ents[_PED+1].COLR,(1<<1)+(1<<4),nil)
						else
							API.SD.draw_text(funcs.get.pid_name(_PID),_POS+funcs.vec(rdr_plyr_name_size*0.01+RADAR_2.name_x.value,rdr_plyr_name_size*0.007+RADAR_2.name_y.value),_POS,rdr_plyr_name_size,RADAR_2.ents[_PED+1].COLR,(1<<1),nil)
						end
					end
				elseif RADAR_2.ents[_PED+1].PED then
					_POS = RADAR_2.pos(API.ent.get.coords(_PED),RADAR_2.ents[_PED+1].DIST)
					if RADAR_2.ents[_PED+1].SHOOT > TIME_MS() then
						API.SD.draw_sprt(RADAR_2.boom,_POS,RADAR_2.r_size.value*RADAR_2.p_size.value*.1*.25*g.RES,RADAR_2.head2(_PED),funcs.get.rgba_to_int(255,255,255,RADAR_2.ents[_PED+1].ALPHA))
					end
					API.SD.draw_sprt(RADAR_2.arrow3,_POS,RADAR_2.r_size.value*RADAR_2.p_size.value*.1*g.RES,RADAR_2.head2(_PED),RADAR_2.ents[_PED+1].COLR)
				end
			end
		end
		show_self(false)
		show_wp(false)
		show_pers(true)
		show_veh(true)
	end
end)
funcs.add_to_S_L(g.tbl.RADAR.feat,"g.tbl.RADAR.feat")

RADAR_2.info=og_menu_add_feature("Show radar HIDDEN", "toggle", g.prnt.utils_info_radar.id, function(f)
	local good,_dist,_r,_g,_b,all_peds,_PED,PID,ped_type,wp
	local cops = ped_models.rltshp_csa
	local others = ped_models.rltshp_mssn
	local animals = ped_models.rltshp_anml
	local animals_hash = ped_models.rltshp_anml_hash
	local v2zero = v2(10000,10000)
	local temp_vec,my_veh
	local function get_type(_hash)
		if RADAR_2.csa_show.on and cops[_hash] then return 1
		elseif RADAR_2.mssn_show.on and (others[_hash] or ntv.is.ped_dislikes(_PED,API.plyr.get.ped(API.plyr.my_id())) or ntv.is.ped_attack_ped(_PED,API.plyr.get.ped(API.plyr.my_id()))) then return 2
		elseif RADAR_2.anml_show.on and (animals[_hash] or animals_hash[API.ent.get.model_hash(_PED)]) then return 3
		elseif RADAR_2.nice_show.on and ntv.is.ped_nice(_PED,API.plyr.get.ped(API.plyr.my_id())) then return 4
		end
		return 0
	end
	local function player_check()
		if API.plyr.is.valid(PID) and PID ~= API.plyr.my_id() then
			if g.tbl.PID_INFO.interior[API.plyr.my_id()+1] or (not g.tbl.PID_INFO.interior[PID+1]) then
				return funcs.is.in_grid_xy(API.plyr.get.coords(API.plyr.my_id()),API.plyr.get.coords(PID),RADAR_2.range.value)
			end
		end
		return false
	end
	local ped_alpha = {}
	while f.on do
		YIELD(25)
		RADAR_2.ped_colors[1]=funcs.get.rgba_to_int(RADAR_2.csa_r.value,RADAR_2.csa_g.value,RADAR_2.csa_b.value,RADAR_2.csa_a.value)
		RADAR_2.ped_colors[2]=funcs.get.rgba_to_int(RADAR_2.mssn_r.value,RADAR_2.mssn_g.value,RADAR_2.mssn_b.value,RADAR_2.mssn_a.value)
		RADAR_2.ped_colors[3]=funcs.get.rgba_to_int(RADAR_2.anml_r.value,RADAR_2.anml_g.value,RADAR_2.anml_b.value,RADAR_2.anml_a.value)
		RADAR_2.ped_colors[4]=funcs.get.rgba_to_int(RADAR_2.nice_r.value,RADAR_2.nice_g.value,RADAR_2.nice_b.value,RADAR_2.nice_a.value)
		ped_alpha[1]=RADAR_2.csa_a.value
		ped_alpha[2]=RADAR_2.mssn_a.value
		ped_alpha[3]=RADAR_2.anml_a.value
		ped_alpha[4]=RADAR_2.nice_a.value
		good = false
		if ntv.is.waypoint() then
			wp = ui.get_waypoint_coord()
			if wp.x < 16000 then
				_dist = funcs.get.dist_pospos_v2(wp,funcs.ME._crds())
				good = true
				if _dist <= RADAR_2.range.value then
					RADAR_2.wp_dist = _dist
					RADAR_2.wp_pos = wp
				else
					RADAR_2.wp_dist = RADAR_2.range.value
					temp_vec = funcs.get.vctr_to_pos3(funcs.vec(wp.x,wp.y,0),funcs.ME._crds())
					temp_vec,RADAR_2.wp_pos = funcs.get.ray_pos(funcs.ME._crds(),temp_vec,_dist)
				end
				RADAR_2.wp_true = true
			end
		end
		if not good then
			RADAR_2.wp_true = false
			RADAR_2.wp_dist = 10000
			RADAR_2.wp_pos = v2zero
		end
		my_veh = API.plyr.pers_veh()
		good = false
		if RADAR_2.veh_pers_show.on and my_veh ~= 0 and funcs.is.veh(my_veh) and (not funcs.ME._in_veh() or funcs.ME._veh() ~= my_veh) then
			if g.tbl.veh_esp.png_true[API.ent.get.model_hash(my_veh)] or g.tbl.veh_esp.png_true[API.veh.get.class_name(my_veh)] then
				_dist = funcs.get.dist_me_ent_3d(my_veh)
				good = true
				if g.tbl.veh_esp.png_true[API.ent.get.model_hash(my_veh)] then
					RADAR_2.pers_blip=g.tbl.veh_esp.png_int[API.ent.get.model_hash(my_veh)]
					if g.tbl.veh_esp.png_rot_true[API.ent.get.model_hash(my_veh)] then
						RADAR_2.pers_rot=RADAR_2.head2(my_veh)
					else
						RADAR_2.pers_rot=0
					end
				else
					RADAR_2.pers_blip=g.tbl.veh_esp.png_int[API.veh.get.class_name(my_veh)]

					if g.tbl.veh_esp.png_rot_true[API.veh.get.class_name(my_veh)] then
						RADAR_2.pers_rot=RADAR_2.head2(my_veh)
					else
						RADAR_2.pers_rot=0
					end
				end
				if _dist <= RADAR_2.range.value then
					RADAR_2.pers_dist = _dist
					RADAR_2.pers_pos = API.ent.get.coords(my_veh)
				else
					RADAR_2.pers_dist = RADAR_2.range.value
					temp_vec = funcs.get.vctr_to_pos3(API.ent.get.coords(my_veh),funcs.ME._crds())
					temp_vec,RADAR_2.pers_pos = funcs.get.ray_pos(funcs.ME._crds(),temp_vec,_dist)
				end
				RADAR_2.pers_true = true
			end
		end
		if not good then
			RADAR_2.pers_true = false
			RADAR_2.pers_dist = 10000
			RADAR_2.pers_pos = v2(10000,10000)
		end
		my_veh = funcs.ME._veh()
		good = false
		if RADAR_2.veh_veh_show.on and my_veh ~= 0 and funcs.is.veh(my_veh) and not funcs.ME._in_veh() and (not RADAR_2.veh_pers_show.on or my_veh ~= API.plyr.pers_veh()) then
			if g.tbl.veh_esp.png_true[API.ent.get.model_hash(my_veh)] or g.tbl.veh_esp.png_true[API.veh.get.class_name(my_veh)] then
				_dist = funcs.get.dist_me_ent_3d(my_veh)
				good = true
				if g.tbl.veh_esp.png_true[API.ent.get.model_hash(my_veh)] then
					RADAR_2.veh_blip=g.tbl.veh_esp.png_int[API.ent.get.model_hash(my_veh)]
					if g.tbl.veh_esp.png_rot_true[API.ent.get.model_hash(my_veh)] then
						RADAR_2.veh_rot=RADAR_2.head2(my_veh)
					else
						RADAR_2.veh_rot=0
					end
				else
					RADAR_2.veh_blip=g.tbl.veh_esp.png_int[API.veh.get.class_name(my_veh)]
					if g.tbl.veh_esp.png_rot_true[API.veh.get.class_name(my_veh)] then
						RADAR_2.veh_rot=RADAR_2.head2(my_veh)
					else
						RADAR_2.veh_rot=0
					end
				end
				if _dist <= RADAR_2.range.value then
					RADAR_2.veh_dist = _dist
					RADAR_2.veh_pos = API.ent.get.coords(my_veh)
				else
					RADAR_2.veh_dist = RADAR_2.range.value
					temp_vec = funcs.get.vctr_to_pos3(API.ent.get.coords(my_veh),funcs.ME._crds())
					temp_vec,RADAR_2.veh_pos = funcs.get.ray_pos(funcs.ME._crds(),temp_vec,_dist)
				end
				RADAR_2.veh_true = true
			end
		end
		if not good then
			RADAR_2.veh_true = false
			RADAR_2.veh_dist = 10000
			RADAR_2.veh_pos = v2(10000,10000)
		end
		all_peds = API.Ped.get.all()
		for i=1,#all_peds do
			_PED = all_peds[i]
			good = false
			if funcs.is.ent(_PED) then
				if RADAR_2.ents[_PED+1] == nil then
					RADAR_2.ents_default(_PED+1)
				end
				if API.Ped.is.plyr(_PED) then
					PID = API.plyr.get.plyr_from_ped(_PED)
					good = player_check()
					if good then
						_dist = funcs.get.dist_me_pid_2d(PID)
						--_dist = mth.abs(v2(API.cam.get.pos().x,API.cam.get.pos().y):magnitude(v2(API.plyr.get.coords(PID).x,API.plyr.get.coords(PID).y)))
						good = (_dist <= RADAR_2.range.value)
						if good then
							RADAR_2.ents[_PED+1].DIST = _dist
							RADAR_2.ents[_PED+1].FRND = API.plyr.is.friend(PID)
							_r,_g,_b = g.tbl.PID_OSD.plyr_rgb(PID+1)
							if RADAR_2.ents[_PED+1].FRND then
								RADAR_2.ents[_PED+1].COLR = funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.f_a.value)
								RADAR_2.ents[_PED+1].ALPHA = RADAR_2.f_a.value
							else
								RADAR_2.ents[_PED+1].COLR = funcs.get.rgba_to_int(_r,_g,_b,RADAR_2.o_a.value)
								RADAR_2.ents[_PED+1].ALPHA = RADAR_2.o_a.value
							end
							RADAR_2.ents[_PED+1].PED = false
							RADAR_2.ents[_PED+1].PID = PID
							RADAR_2.ents[_PED+1].PLYR = true
							RADAR_2.ents[_PED+1].DEAD = API.ent.is.dead(_PED)
							RADAR_2.ents[_PED+1].D_TIME = TIME_MS()+10000
							if API.Ped.is.shooting(_PED) then
								RADAR_2.ents[_PED+1].SHOOT =	TIME_MS()+100
							end
						end
					end
				else
					ped_type = get_type(API.Ped.get.rel_group_hash(_PED),_PED)
					if ped_type > 0 and funcs.is.in_grid_xy(API.plyr.get.coords(API.plyr.my_id()),API.ent.get.coords(_PED),RADAR_2.range.value) then
						if RADAR_2.dead_chk(_PED) then
							_dist = funcs.get.dist_me_ent_2d(_PED)
							--_dist = mth.abs(v2(API.cam.get.pos().x,API.cam.get.pos().y):magnitude(v2(API.ent.get.coords(_PED).x,API.ent.get.coords(_PED).y)))
							good = (_dist <= RADAR_2.range.value)
							if good then
								RADAR_2.ents[_PED+1].DIST = _dist
								RADAR_2.ents[_PED+1].FRND = false
								RADAR_2.ents[_PED+1].COLR = RADAR_2.ped_colors[ped_type]
								RADAR_2.ents[_PED+1].PID = -1
								RADAR_2.ents[_PED+1].PLYR = false
								RADAR_2.ents[_PED+1].PED = true
								if not RADAR_2.ents[_PED+1].DEAD then
									RADAR_2.ents[_PED+1].D_TIME = TIME_MS()+10000
								end
								RADAR_2.ents[_PED+1].DEAD = API.ent.is.dead(_PED)
								if API.Ped.is.shooting(_PED) then
									RADAR_2.ents[_PED+1].SHOOT =	TIME_MS()+100
								end
								RADAR_2.ents[_PED+1].ALPHA = ped_alpha[ped_type]
							end
						else
							good = true
						end
					end
				end
			end
			if not good then
				RADAR_2.ents_default(_PED+1)
			end
		end
		f.on=RADAR_2.feat.on
	end
end)RADAR_2.info.hidden=true



RADAR_2.rdr_optns=menu_add_feature("Radar options", "parent", g.prnt.utils_info_radar.id)

RADAR_2.range = menu_add_feature("Range", "action_value_f",RADAR_2.rdr_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.range,25,500,5,100,"g.tbl.RADAR.range")

RADAR_2.r_size = menu_add_feature("Radar size", "action_value_f",RADAR_2.rdr_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.r_size,0.05,2,0.01,1,"g.tbl.RADAR.r_size")

RADAR_2.x = menu_add_feature("X Pos", "action_value_f",RADAR_2.rdr_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.x,-1,1,0.01,0.44,"g.tbl.RADAR.x")
RADAR_2.y = menu_add_feature("Y Pos", "action_value_f",RADAR_2.rdr_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.y,-1,1,0.01,0.39,"g.tbl.RADAR.y")

RADAR_2.rings_prnt = menu_add_feature("Range rings", "parent",RADAR_2.rdr_optns.id,function(f)
	RADAR_2.r_r.hidden=RADAR_2.rings_opp_color.on
	RADAR_2.r_g.hidden=RADAR_2.rings_opp_color.on
	RADAR_2.r_b.hidden=RADAR_2.rings_opp_color.on
end)

RADAR_2.rings_show = menu_add_feature("Show rings", "toggle",RADAR_2.rings_prnt.id)
funcs.add_to_S_L(g.tbl.RADAR.rings_show,"g.tbl.RADAR.rings_show")
RADAR_2.rings_show.on=true
RADAR_2.rings_rng = menu_add_feature("Ring interval (meters)", "action_value_i",RADAR_2.rings_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.rings_rng,5,250,5,25,"g.tbl.RADAR.rings_rng")

RADAR_2.rings_opp_color = menu_add_feature("Inverse color", "toggle",RADAR_2.rings_prnt.id,function(f)
	RADAR_2.r_r.hidden=f.on
	RADAR_2.r_g.hidden=f.on
	RADAR_2.r_b.hidden=f.on
end)
funcs.add_to_S_L(g.tbl.RADAR.rings_opp_color,"g.tbl.RADAR.rings_opp_color")

g.tbl.RADAR.r_r = menu_add_feature("Red", "action_value_i",g.tbl.RADAR.rings_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.r_r,0,255,1,180,"g.tbl.RADAR.r_r")
g.tbl.RADAR.r_g = menu_add_feature("Green", "action_value_i",g.tbl.RADAR.rings_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.r_g,0,255,1,255,"g.tbl.RADAR.r_g")
g.tbl.RADAR.r_b = menu_add_feature("Blue", "action_value_i",g.tbl.RADAR.rings_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.r_b,0,255,1,180,"g.tbl.RADAR.r_b")
g.tbl.RADAR.r_a = menu_add_feature("Alpha", "action_value_i",g.tbl.RADAR.rings_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.r_a,0,255,1,100,"g.tbl.RADAR.r_a")
g.tbl.RADAR.rings_opp_color.on=true

g.tbl.RADAR.rdr_clr_prnt=menu_add_feature("Radar Color", "parent", g.tbl.RADAR.rdr_optns.id)

g.tbl.RADAR.r = menu_add_feature("Red", "action_value_i",g.tbl.RADAR.rdr_clr_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.r,0,255,1,0,"g.tbl.RADAR.r")
g.tbl.RADAR.g = menu_add_feature("Green", "action_value_i",g.tbl.RADAR.rdr_clr_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.g,0,255,1,0,"g.tbl.RADAR.g")
g.tbl.RADAR.b = menu_add_feature("Blue", "action_value_i",g.tbl.RADAR.rdr_clr_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.b,0,255,1,0,"g.tbl.RADAR.b")
g.tbl.RADAR.a = menu_add_feature("Alpha", "action_value_i",g.tbl.RADAR.rdr_clr_prnt.id)
funcs.set_feat_i_f(g.tbl.RADAR.a,0,255,1,100,"g.tbl.RADAR.a")

g.tbl.RADAR.ped_optns=menu_add_feature("Ped options", "parent", g.prnt.utils_info_radar.id)

g.tbl.RADAR.p_size = menu_add_feature("Size", "action_value_f",g.tbl.RADAR.ped_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.p_size,0.05,2,0.01,1,"g.tbl.RADAR.p_size")

g.tbl.RADAR.plyr_optns=menu_add_feature("Player options", "parent", g.tbl.RADAR.ped_optns.id)

g.tbl.RADAR.plyr_name_optns=menu_add_feature("Player name", "parent", g.tbl.RADAR.plyr_optns.id)

g.tbl.RADAR.name = menu_add_feature("Show name", "toggle",g.tbl.RADAR.plyr_name_optns.id)
funcs.add_to_S_L(g.tbl.RADAR.name,"g.tbl.RADAR.name")
g.tbl.RADAR.name.on=true

g.tbl.RADAR.name_s = menu_add_feature("Name Size", "action_value_f",g.tbl.RADAR.plyr_name_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.name_s,0,2,0.01,1,"g.tbl.RADAR.name_s")

g.tbl.RADAR.name_j = menu_add_feature("Justification", "action_value_str",g.tbl.RADAR.plyr_name_optns.id)
new_set_str_data(g.tbl.RADAR.name_j,{"Left","Center","Right"})
funcs.add_to_S_L(g.tbl.RADAR.name_j,"g.tbl.RADAR.name_j")

g.tbl.RADAR.name_x = menu_add_feature("Name X Pos offset", "action_value_f",g.tbl.RADAR.plyr_name_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.name_x,-1,1,0.001,0,"g.tbl.RADAR.name_x")

g.tbl.RADAR.name_y = menu_add_feature("Name Y Pos offset", "action_value_f",g.tbl.RADAR.plyr_name_optns.id)
funcs.set_feat_i_f(g.tbl.RADAR.name_y,-1,1,0.001,0,"g.tbl.RADAR.name_y")

g.tbl.RADAR.self = menu_add_feature("Show self", "toggle",g.tbl.RADAR.plyr_optns.id)
funcs.add_to_S_L(g.tbl.RADAR.self,"g.tbl.RADAR.self")
RADAR_2.self.on=true

RADAR_2.s_a = menu_add_feature("Self alpha", "action_value_i",RADAR_2.plyr_optns.id)
funcs.set_feat_i_f(RADAR_2.s_a,0,255,1,255,"g.tbl.RADAR.s_a")
RADAR_2.f_a = menu_add_feature("Friend alpha", "action_value_i",RADAR_2.plyr_optns.id)
funcs.set_feat_i_f(RADAR_2.f_a,0,255,1,255,"g.tbl.RADAR.f_a")
RADAR_2.o_a = menu_add_feature("Other player alpha", "action_value_i",RADAR_2.plyr_optns.id)
funcs.set_feat_i_f(RADAR_2.o_a,0,255,1,255,"g.tbl.RADAR.o_a")

RADAR_2.csa_prnt=menu_add_feature("Cops/Security/Army", "parent", RADAR_2.ped_optns.id)
RADAR_2.csa_show=menu_add_feature("Show peds", "toggle", RADAR_2.csa_prnt.id)
funcs.add_to_S_L(RADAR_2.csa_show,"g.tbl.RADAR.csa_show")
RADAR_2.csa_show.on=true
RADAR_2.csa_r = menu_add_feature("Red", "action_value_i",RADAR_2.csa_prnt.id)
funcs.set_feat_i_f(RADAR_2.csa_r,0,255,1,0,"g.tbl.RADAR.csa_r")
RADAR_2.csa_g = menu_add_feature("Green", "action_value_i",RADAR_2.csa_prnt.id)
funcs.set_feat_i_f(RADAR_2.csa_g,0,255,1,0,"g.tbl.RADAR.csa_g")
RADAR_2.csa_b = menu_add_feature("Blue", "action_value_i",RADAR_2.csa_prnt.id)
funcs.set_feat_i_f(RADAR_2.csa_b,0,255,1,200,"g.tbl.RADAR.csa_b")
RADAR_2.csa_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.csa_prnt.id)
funcs.set_feat_i_f(RADAR_2.csa_a,0,255,1,255,"g.tbl.RADAR.csa_a")

RADAR_2.mssn_prnt=menu_add_feature("Mission/Other", "parent", RADAR_2.ped_optns.id)
RADAR_2.mssn_show=menu_add_feature("Show peds", "toggle", RADAR_2.mssn_prnt.id)
funcs.add_to_S_L(RADAR_2.mssn_show,"g.tbl.RADAR.mssn_show")
RADAR_2.mssn_show.on=true
RADAR_2.mssn_r = menu_add_feature("Red", "action_value_i",RADAR_2.mssn_prnt.id)
funcs.set_feat_i_f(RADAR_2.mssn_r,0,255,1,225,"g.tbl.RADAR.mssn_r")
RADAR_2.mssn_g = menu_add_feature("Green", "action_value_i",RADAR_2.mssn_prnt.id)
funcs.set_feat_i_f(RADAR_2.mssn_g,0,255,1,69,"g.tbl.RADAR.mssn_g")
RADAR_2.mssn_b = menu_add_feature("Blue", "action_value_i",RADAR_2.mssn_prnt.id)
funcs.set_feat_i_f(RADAR_2.mssn_b,0,255,1,69,"g.tbl.RADAR.mssn_b")
RADAR_2.mssn_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.mssn_prnt.id)
funcs.set_feat_i_f(RADAR_2.mssn_a,0,255,1,255,"g.tbl.RADAR.mssn_a")

RADAR_2.anml_prnt=menu_add_feature("Animals", "parent", RADAR_2.ped_optns.id)
RADAR_2.anml_show=menu_add_feature("Show peds", "toggle", RADAR_2.anml_prnt.id)
funcs.add_to_S_L(RADAR_2.anml_show,"g.tbl.RADAR.anml_show")
RADAR_2.anml_show.on=true
RADAR_2.anml_r = menu_add_feature("Red", "action_value_i",RADAR_2.anml_prnt.id)
funcs.set_feat_i_f(RADAR_2.anml_r,0,255,1,150,"g.tbl.RADAR.anml_r")
RADAR_2.anml_g = menu_add_feature("Green", "action_value_i",RADAR_2.anml_prnt.id)
funcs.set_feat_i_f(RADAR_2.anml_g,0,255,1,190,"g.tbl.RADAR.anml_g")
RADAR_2.anml_b = menu_add_feature("Blue", "action_value_i",RADAR_2.anml_prnt.id)
funcs.set_feat_i_f(RADAR_2.anml_b,0,255,1,0,"g.tbl.RADAR.anml_b")
RADAR_2.anml_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.anml_prnt.id)
funcs.set_feat_i_f(RADAR_2.anml_a,0,255,1,255,"g.tbl.RADAR.anml_a")

RADAR_2.nice_prnt=menu_add_feature("Friendly NPCs", "parent", RADAR_2.ped_optns.id)
RADAR_2.nice_show=menu_add_feature("Show peds", "toggle", RADAR_2.nice_prnt.id)
funcs.add_to_S_L(RADAR_2.nice_show,"g.tbl.RADAR.nice_show")
RADAR_2.nice_show.on=true
RADAR_2.nice_r = menu_add_feature("Red", "action_value_i",RADAR_2.nice_prnt.id)
funcs.set_feat_i_f(RADAR_2.nice_r,0,255,1,93,"g.tbl.RADAR.nice_r")
RADAR_2.nice_g = menu_add_feature("Green", "action_value_i",RADAR_2.nice_prnt.id)
funcs.set_feat_i_f(RADAR_2.nice_g,0,255,1,182,"g.tbl.RADAR.nice_g")
RADAR_2.nice_b = menu_add_feature("Blue", "action_value_i",RADAR_2.nice_prnt.id)
funcs.set_feat_i_f(RADAR_2.nice_b,0,255,1,229,"g.tbl.RADAR.nice_b")
RADAR_2.nice_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.nice_prnt.id)
funcs.set_feat_i_f(RADAR_2.nice_a,0,255,1,255,"g.tbl.RADAR.nice_a")

RADAR_2.monitor_prnt=menu_add_feature("Monitor adjustments", "parent", RADAR_2.ped_optns.id)
RADAR_2.xT = menu_add_feature("X Offset", "action_value_f",RADAR_2.monitor_prnt.id,function(f)
	g.N_P(2,f.value,__GV__,3,"Blue")
end)
funcs.set_feat_i_f(RADAR_2.xT,0,3,0.001,1,"g.tbl.RADAR.xT")
RADAR_2.yT = menu_add_feature("Y Offset", "action_value_f",RADAR_2.monitor_prnt.id,function(f)
	g.N_P(2,f.value,__GV__,3,"Blue")
end)
funcs.set_feat_i_f(RADAR_2.yT,0,3,0.001,1,"g.tbl.RADAR.yT")
RADAR_2.math_mod = menu_add_feature("Adjustment sensitivity","autoaction_value_str",RADAR_2.monitor_prnt.id,function(f)
	local _table = {0.0001,0.001,0.01,0.1}
	RADAR_2.xT.mod=_table[f.value+1]
	RADAR_2.yT.mod=_table[f.value+1]
	g.N_P(2,"Offset mod changed to ".._table[f.value+1],__GV__,3,"Blue")
end)
RADAR_2.math_mod:set_str_data({"0.0001","0.001","0.01","0.1"})
funcs.add_to_S_L(RADAR_2.math_mod,"g.tbl.RADAR.math_mod")

RADAR_2.wp_optns=menu_add_feature("Waypoint options", "parent", g.prnt.utils_info_radar.id)

RADAR_2.wp_size = menu_add_feature("Size", "action_value_f",RADAR_2.wp_optns.id)
funcs.set_feat_i_f(RADAR_2.wp_size,0.05,2,0.01,1,"g.tbl.RADAR.wp_size")

RADAR_2.wp_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.wp_optns.id)
funcs.set_feat_i_f(RADAR_2.wp_a,0,255,1,255,"g.tbl.RADAR.wp_a")

RADAR_2.veh_optns=menu_add_feature("Vehicle options", "parent", g.prnt.utils_info_radar.id)

RADAR_2.veh_size = menu_add_feature("Size", "action_value_f",RADAR_2.veh_optns.id)
funcs.set_feat_i_f(RADAR_2.veh_size,0.05,2,0.01,1,"g.tbl.RADAR.veh_size")

RADAR_2.veh_a = menu_add_feature("Alpha", "action_value_i",RADAR_2.veh_optns.id)
funcs.set_feat_i_f(RADAR_2.veh_a,0,255,1,255,"g.tbl.RADAR.veh_a")

RADAR_2.veh_pers_show=menu_add_feature("Show my personal vehicle", "toggle", RADAR_2.veh_optns.id)
funcs.add_to_S_L(RADAR_2.veh_pers_show,"g.tbl.RADAR.veh_pers_show")
RADAR_2.veh_pers_show.on=true
RADAR_2.veh_veh_show=menu_add_feature("Show my last vehicle", "toggle", RADAR_2.veh_optns.id)
funcs.add_to_S_L(RADAR_2.veh_veh_show,"g.tbl.RADAR.veh_veh_show")
RADAR_2.veh_veh_show.on=true

g.print_load_info("2T1 Radar 2.0",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Player Overlay"

g.tbl.clear_stuff={}
g.tbl.clear_stuff.ped_count=0
g.tbl.clear_stuff.obj_count=0
g.tbl.clear_stuff.veh_count=0
g.tbl.clear_stuff.feat=menu_add_feature("Clear area","action",g.prnt.utils_clear.id,function(f)
	if not g.tbl.clear_stuff.peds.on and not g.tbl.clear_stuff.obj.on and not g.tbl.clear_stuff.veh.on then
		g.N_P(2,"No option selected.",__GV__,4,"Blue")
	else
		local range,peds,objs,vehs = g.tbl.clear_stuff.range_feat.value
		peds = g.tbl.clear_stuff.peds.on
		objs = g.tbl.clear_stuff.obj.on
		vehs = g.tbl.clear_stuff.veh.on
		g.tbl.clear_stuff.ped_count=0
		g.tbl.clear_stuff.obj_count=0
		g.tbl.clear_stuff.veh_count=0
		g.tbl.clear_stuff.peds_do.on = g.tbl.clear_stuff.peds.on
		g.tbl.clear_stuff.obj_do.on = g.tbl.clear_stuff.obj.on
		g.tbl.clear_stuff.veh_do.on = g.tbl.clear_stuff.veh.on
		g.tbl.clear_stuff.debug_pos=API.plyr.get.coords(API.plyr.my_id())
		g.tbl.clear_stuff.debug_time= TIME_MS()+2000
		g.tbl.clear_stuff.debug_div=2
		g.tbl.clear_stuff.show_debug_feat.on=true
		while g.tbl.clear_stuff.peds_do.on or g.tbl.clear_stuff.obj_do.on or g.tbl.clear_stuff.veh_do.on do
			YIELD(0)
		end
		local msg=""
		if peds then
			msg=msg..g.tbl.clear_stuff.ped_count.." Peds"
		end
		if objs then
			if peds then
				msg=msg.." and "
			end
			msg=msg..g.tbl.clear_stuff.obj_count.." Objects"
		end
		if vehs then
			if peds or objs then
				msg=msg.." and "
			end
			msg=msg..g.tbl.clear_stuff.veh_count.." Vehicles"
		end
		msg=msg.." within "..range.." meters cleared."
		g.N_P(2,msg,__GV__,4,"Blue")
	end
end)

g.tbl.clear_stuff.rng=0
g.tbl.clear_stuff.range_feat=menu_add_feature("Range","autoaction_value_i",g.prnt.utils_clear.id,function(f)
	if f.value ~= g.tbl.clear_stuff.rng then
		g.tbl.clear_stuff.rng=f.value
		g.tbl.clear_stuff.debug_pos=API.plyr.get.coords(API.plyr.my_id())
		g.tbl.clear_stuff.debug_time= TIME_MS()+1000
		g.tbl.clear_stuff.debug_div=1
		g.tbl.clear_stuff.show_debug_feat.on=true
	end
end)
funcs.set_feat_i_f(g.tbl.clear_stuff.range_feat,10,500,10,100,"g.tbl.clear_stuff.range_feat")

g.tbl.clear_stuff.debug_time= TIME_MS()
g.tbl.clear_stuff.debug_pos=API.plyr.get.coords(API.plyr.my_id())
g.tbl.clear_stuff.debug_div=1
g.tbl.clear_stuff.show_debug_feat=og_menu_add_feature("Show debug HIDDEN","toggle",g.prnt.utils_clear.id,function(f)
	if f.on then
		while g.tbl.clear_stuff.debug_time > TIME_MS() do
			YIELD(5)
			graphics.draw_marker(28, g.tbl.clear_stuff.debug_pos, funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), funcs.vec(g.tbl.clear_stuff.rng, g.tbl.clear_stuff.rng, g.tbl.clear_stuff.rng), 255, 0, 0, mth.flr((g.tbl.clear_stuff.debug_time-TIME_MS()) /1000/g.tbl.clear_stuff.debug_div*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
		end
	end
	f.on=false
end)g.tbl.clear_stuff.show_debug_feat.hidden=true

g.tbl.clear_stuff.peds_do=og_menu_add_feature("Peds HIDDEN","toggle",g.prnt.utils_clear.id,function(f)
	if f.on then
		local my_pos=API.plyr.get.coords(API.plyr.my_id())
		local all_peds=API.Ped.get.all()
		local _table = {}
		for i=1,#all_peds do
			if funcs.is.in_grid(my_pos,API.ent.get.coords(all_peds[i]),g.tbl.clear_stuff.range_feat.value) and not API.Ped.is.plyr(all_peds[i]) then
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local ent = all_peds[i]
					_table[ent]=true
					if funcs.doo.remove_ent(ent,2000) then
						g.tbl.clear_stuff.ped_count=g.tbl.clear_stuff.ped_count+1
					end
					_table[ent]=false
				end)
			end
		end
		::check::
		YIELD(0)
		for _, ENT in pairs(_table) do
			if ENT then
				goto check
			end
		end
		f.on=false
	end
end)g.tbl.clear_stuff.peds_do.hidden=true

g.tbl.clear_stuff.obj_do=og_menu_add_feature("Objects HIDDEN","toggle",g.prnt.utils_clear.id,function(f)
	if f.on then
		local my_pos=API.plyr.get.coords(API.plyr.my_id())
		local all_obj=object.get_all_objects()
		local _table = {}
		for i=1,#all_obj do
			if funcs.is.in_grid(my_pos,API.ent.get.coords(all_obj[i]),g.tbl.clear_stuff.range_feat.value) then
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local ent = all_obj[i]
					_table[ent]=true
					if funcs.doo.remove_ent(ent,2000) then
						g.tbl.clear_stuff.obj_count=g.tbl.clear_stuff.obj_count+1
					end
					_table[ent]=false
				end)
			end
		end
		::check::
		YIELD(0)
		for _, ENT in pairs(_table) do
			if ENT then
				goto check
			end
		end
		f.on=false
	end
end)g.tbl.clear_stuff.obj_do.hidden=true

g.tbl.clear_stuff.veh_do=og_menu_add_feature("Vehicles HIDDEN","toggle",g.prnt.utils_clear.id,function(f)
	if f.on then
		local my_pos=API.plyr.get.coords(API.plyr.my_id())
		local all_veh=API.veh.get.all()
		local _table = {}
		local function should_do_it(_veh)
			if not funcs.is.in_grid(my_pos,API.ent.get.coords(_veh),g.tbl.clear_stuff.range_feat.value) then
				return false
			end
			if decorator.decor_get_int(_veh, "Player_Vehicle") == g.tbl.PID_INFO.net_hash[API.plyr.my_id()+1] or funcs.ME._in_that_veh(_veh) or g.tbl.PID_INFO.veh[API.plyr.my_id()+1] == _veh then
				return false
			end
			if g.tbl.clear_stuff.prsnl.on then
				if decorator.decor_get_int(_veh, "Player_Vehicle") > 0 then
					return false
				end
			end
			if g.tbl.clear_stuff.prvs.on then
				if API.veh.get.been_owned(_veh) then
					return false
				end
			end
			for i=1,32 do
				if g.tbl.clear_stuff.frnds.on and g.tbl.PID_INFO.is_frnd[i] then
					if g.tbl.PID_INFO.veh[i] == _veh or decorator.decor_get_int(_veh, "Player_Vehicle") == g.tbl.PID_INFO.net_hash[i] then
						return false
					end
				end
				if g.tbl.clear_stuff.orgmc.on and g.tbl.PID_INFO.color[API.plyr.my_id()+1] > -1 then
					if g.tbl.PID_INFO.color[API.plyr.my_id()+1] == g.tbl.PID_INFO.color[i] then
						return false
					end
				end
			end
			return true
		end
		for i=1,#all_veh do
			if should_do_it(all_veh[i]) then
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local ent = all_veh[i]
					_table[ent]=true
					if funcs.doo.remove_ent(ent,2000) then
						g.tbl.clear_stuff.veh_count=g.tbl.clear_stuff.veh_count+1
					end
					_table[ent]=false
				end)
			end
		end
		::check::
		YIELD(0)
		for _, ENT in pairs(_table) do
			if ENT then
				goto check
			end
		end
		f.on=false
	end
end)g.tbl.clear_stuff.veh_do.hidden=true

g.tbl.clear_stuff.peds=menu_add_feature("Peds","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.peds,"g.tbl.clear_stuff.peds")
g.tbl.clear_stuff.peds.on=true

g.tbl.clear_stuff.obj=menu_add_feature("Objects","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.obj,"g.tbl.clear_stuff.obj")
g.tbl.clear_stuff.obj.on=true

g.tbl.clear_stuff.veh=menu_add_feature("Vehicles","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.veh,"g.tbl.clear_stuff.veh")
g.tbl.clear_stuff.veh.on=true

g.tbl.clear_stuff.prsnl=menu_add_feature("Exclude personal vehicles","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.prsnl,"g.tbl.clear_stuff.prsnl")

g.tbl.clear_stuff.prvs=menu_add_feature("Exclude previously used vehicles","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.prvs,"g.tbl.clear_stuff.prvs")

g.tbl.clear_stuff.frnds=menu_add_feature("Exclude friends","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.frnds,"g.tbl.clear_stuff.frnds")

g.tbl.clear_stuff.orgmc=menu_add_feature("Exclude my ORG/MC","toggle",g.prnt.utils_clear.id)
funcs.add_to_S_L(g.tbl.clear_stuff.orgmc,"g.tbl.clear_stuff.orgmc")



-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------Show player aiming at me
	-------------------------------------------------------------------------------------------------
	g.tbl.aim_protex_main = {}
	g.tbl.aim_protex_main.loaded=false
	g.tbl.aim_protex_main.loadedtime=TIME_MS()
	g.tbl.aim_protex_main.AimAtMe = {}
	function g.tbl.aim_protex_main.AimDefault(i)
		g.tbl.aim_protex_main.AimAtMe[i] = {false,"",0,""}
	end
	for i=1,32 do
		 g.tbl.aim_protex_main.AimDefault(i)
	end

	g.tbl.aim_protex_main.weap_str = {}
	g.tbl.aim_protex_main.veh_table = {}

	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		--local aimtime  = TIME_MS()
		local all_hash = weap_info.all_hash
		local get_name = API.wpn.get_name
		local weap_str = g.tbl.aim_protex_main.weap_str
		local veh_info = weap_info.veh.info
		local veh_table = g.tbl.aim_protex_main.veh_table
		for t=1,#all_hash do
			weap_str[all_hash[t]]=get_name(all_hash[t])
			if t % 20 == 0 then
				YIELD(0)
			end
		end
		for i=1,#veh_info do
			local this_weap = veh_info[i]
			local this_hash = API.get_hash_key(this_weap[2])
			if veh_table[this_hash]==nil then
				veh_table[this_hash]=this_weap[5]
			end
			if i % 20 == 0 then
				YIELD(0)
			end
		end
		g.tbl.aim_protex_main.loaded=true
		--g.print_load_info("Aim Protex",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)--,true)
		--g.var.feat_loading_str = "Utilities"
	end)

	function g.tbl.aim_protex_main.get_weap_name(pid)
		return (API.wpn.get_name(API.Ped.get.weapon(API.plyr.get.ped(pid))) or "Weapon")
	end

	function g.tbl.aim_protex_main.get_veh_weap_name(pid)
		local weap = g.tbl.aim_protex_main.veh_table[ntv.get.ped_veh_weap(API.plyr.get.ped(pid))]
		if weap == nil then
			weap = (weap_info.veh.mg_name[ntv.get.ped_veh_weap(API.plyr.get.ped(pid))] or "Vehicle Weapon")
		end
		return weap
	end

	g.tbl.aim_protex_main._aim_notif=menu_add_feature("Show name of player aiming at me", "toggle", g.prnt.utils_info_aim.id, function(feat)
		funcs.doo.yield_while_true(not g.tbl.aim_protex_main.loaded, 2000)
		funcs.doo.aim_overlay_feats_hide(false)
		local y_val, y_offset,text
		local _r,_g,_b,s,f,x
		local text = ""
		local function should_default(i)
			if i-1 == API.plyr.my_id() or not funcs.is.valid_pid(i-1) then
				return true
			elseif g.tbl.aim_protex_main.AimAtMe[i][1] and g.tbl.aim_protex_main.AimAtMe[i][3] < TIME_MS() then
				return true
			end
			return false
		end
		while feat.on do
			YIELD(5)
			for i=1,32 do
				if should_default(i) then
					g.tbl.aim_protex_main.AimDefault(i)
				elseif funcs.ME._in_veh() and API.plyr.is.in_veh(i-1) and ntv.get.my_veh_lock_trgt(API.plyr.get.veh(i-1))==funcs.ME._ped() then
					g.tbl.aim_protex_main.AimAtMe[i] = {true,g.tbl.aim_protex_main.get_veh_weap_name(i-1),TIME_MS() + (g.tbl.aim_protex_main._plyr_time.value*1000),funcs.get.pid_name(i-1)}
				elseif funcs.is.pid_aim_at_me(i-1) then
					g.tbl.aim_protex_main.AimAtMe[i] = {true,g.tbl.aim_protex_main.get_weap_name(i-1),TIME_MS() + (g.tbl.aim_protex_main._plyr_time.value*1000),funcs.get.pid_name(i-1)}
				end
			end
			g.tbl.aim_protex_main.show_overlay(g.tbl.aim_protex_main.AimAtMe)
		end
		funcs.doo.aim_overlay_feats_hide(true)
	end)g.tbl.aim_protex_main._aim_notif.on=true
	funcs.add_to_S_L(g.tbl.aim_protex_main._aim_notif,"g.tbl.aim_protex_main._aim_notif")

	function g.tbl.aim_protex_main.show_overlay(_table)
		local y_val,y_offset = g.tbl.aim_protex_main._plyr_aim_y.value,g.tbl.aim_protex_main._plyr_aim_spc.value
		local _r,_g,_b = g.tbl.aim_protex_main._plyr_aim_cr.value,g.tbl.aim_protex_main._plyr_aim_cg.value,g.tbl.aim_protex_main._plyr_aim_cb.value
		local s,f,x = g.tbl.aim_protex_main._plyr_aim_s.value/300,g.tbl.aim_protex_main._plyr_aim_f.value,g.tbl.aim_protex_main._plyr_aim_x.value/300
		local alpha,a = g.tbl.aim_protex_main._plyr_aim_a.value
		for i=1,#_table do
			if _table[i][1] and _table[i][3] > TIME_MS() then
				a = (_table[i][3]-TIME_MS()) /1000/(g.tbl.aim_protex_main._plyr_time.value+1)
				if a > .5 then a = g.tbl.aim_protex_main._plyr_aim_a.value else a = mth.flr(a*1.5*alpha) end
				funcs.doo.overlay(_table[i][4].." - ".._table[i][2],_r,_g,_b,a,s,f,x,y_val/300)
				y_val = y_val + y_offset
			end
		end
	end

	g.tbl.aim_protex_main._aim_notif_test = menu_add_feature("Player aim overlay test?", "toggle", g.prnt.utils_info_aim.id, function(f)
		while f.on do
			local _table = {}
			for i=1, 3 do
				_table[i] = {true,(API.wpn.get_name(weap_info.all_hash[mth.rndm(1,#weap_info.all_hash)]) or "Weapon"),TIME_MS() + (g.tbl.aim_protex_main._plyr_time.value*1000),"Player "..mth.rndm(1,9)}
			end
			local time = TIME_MS() + (g.tbl.aim_protex_main._plyr_time.value*1000)
			while time > TIME_MS() and f.on do
				YIELD(5)
				g.tbl.aim_protex_main.show_overlay(_table)
			end
			YIELD(0)
		end
		if g.tbl.aim_protex_main._aim_notif.on then
			g.tbl.aim_protex_main._aim_notif_test.hidden=false
		end
	end)

	function funcs.is.pid_aim_at_me(_pid)
		return (funcs.is.valid_pid(_pid) and API.plyr.get.aim_at(_pid) == API.plyr.get.ped(API.plyr.my_id()))
	end

	function funcs.doo.input_f_value(_feat,_min,_max,_str_max,_type)
		local status,str = 1
		status,str = funcs.get.text_input("Type a number between ".._min.." and ".._max,_feat.value,_str_max,_type)
		if status == 0 and tonumber(str) <= _max and tonumber(str) >= _min then
			_feat.value=tonumber(str)
		end
	end

	g.tbl.aim_protex_main._plyr_time = menu_add_feature("Time on screen", "action_value_f", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,1,5,3,4)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_time,1,5,0.1,2.5,"g.tbl.aim_protex_main._plyr_time")

	g.tbl.aim_protex_main._plyr_aim_x = menu_add_feature("X Pos", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,0,300,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_x,0,300,1,229,"g.tbl.aim_protex_main._plyr_aim_x")

	g.tbl.aim_protex_main._plyr_aim_y = menu_add_feature("Y Pos", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,0,300,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_y,0,300,1,23,"g.tbl.aim_protex_main._plyr_aim_y")

	g.tbl.aim_protex_main._plyr_aim_spc = menu_add_feature("Spacing", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,1,69,2,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_spc,1,69,1,18,"g.tbl.aim_protex_main._plyr_aim_spc")

	g.tbl.aim_protex_main._plyr_aim_s = menu_add_feature("Scale", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,75,300,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_s,75,300,1,277,"g.tbl.aim_protex_main._plyr_aim_s")

	g.tbl.aim_protex_main._plyr_aim_f = menu_add_feature("Font", "action_value_i", g.prnt.utils_info_aim.id)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_f,0,9,1,9,"g.tbl.aim_protex_main._plyr_aim_f")

	g.tbl.aim_protex_main._plyr_aim_cr = menu_add_feature("Red", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,0,255,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_cr,0,255,1,255,"g.tbl.aim_protex_main._plyr_aim_cr")

	g.tbl.aim_protex_main._plyr_aim_cg = menu_add_feature("Green", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,0,255,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_cg,0,255,1,0,"g.tbl.aim_protex_main._plyr_aim_cg")

	g.tbl.aim_protex_main._plyr_aim_cb = menu_add_feature("Blue", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,0,255,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_cb,0,255,1,0,"g.tbl.aim_protex_main._plyr_aim_cb")

	g.tbl.aim_protex_main._plyr_aim_a = menu_add_feature("Alpha", "action_value_i", g.prnt.utils_info_aim.id,function(f)
		funcs.doo.input_f_value(f,30,255,3,3)
	end)
	funcs.set_feat_i_f(g.tbl.aim_protex_main._plyr_aim_a,30,255,1,255,"g.tbl.aim_protex_main._plyr_aim_a")

	function funcs.doo.aim_overlay_feats_hide(_bool)
	g.tbl.aim_protex_main._plyr_time.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_spc.hidden=_bool
	g.tbl.aim_protex_main._aim_notif_test.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_x.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_y.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_s.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_f.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_cr.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_cg.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_cb.hidden=_bool
	g.tbl.aim_protex_main._plyr_aim_a.hidden=_bool
	end
	funcs.doo.aim_overlay_feats_hide(true)

-------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------Show player list
-------------------------------------------------------------------------------------------------
g.tbl.PID_OSD = {}
g.tbl.PID_OSD.sort_prnt = menu_add_feature("Sort list", "parent", g.prnt.utils_info_overlay.id)
g.tbl.PID_OSD.show_info_prnt = menu_add_feature("Select info", "parent", g.prnt.utils_info_overlay.id)
g.tbl.PID_OSD.display_prnt = menu_add_feature("Display options", "parent", g.prnt.utils_info_overlay.id)
g.tbl.PID_OSD.sort_prnt_left = menu_add_feature("Order of info on left", "parent", g.tbl.PID_OSD.sort_prnt.id)
g.tbl.PID_OSD.sort_prnt_right = menu_add_feature("Order of info on right", "parent", g.tbl.PID_OSD.sort_prnt.id)
g.tbl.PID_OSD.text_dots = "..."
g.tbl.PID_OSD.popo_rb=false
g.tbl.PID_OSD.sort_bool=false

g.tbl.PID_OSD.alpha_str = {"Fade"}
for i=1,42 do
	g.tbl.PID_OSD.alpha_str[#g.tbl.PID_OSD.alpha_str+1]=(50+((i-1)*5))
end

g.tbl.PID_OSD.dist_table = {} --made this before i knew how to use tables properly. Too lazy to update
for i=0,31 do
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local pid = i
		while true do
			if funcs.is.valid_pid(pid) then
				if pid == API.plyr.my_id() then
					g.tbl.PID_OSD.dist_table[pid+1]={0,API.plyr.get.coords(pid),pid}
				else
					g.tbl.PID_OSD.dist_table[pid+1]={funcs.get.dist_me_pid_3d(pid),API.plyr.get.coords(pid),pid}
				end
			else
				g.tbl.PID_OSD.dist_table[pid+1]={10000,funcs.vec(0,0,0),pid}
			end
			YIELD(mth.rndm(90,100))
		end
	end)
end

g.tbl.PID_OSD.plyr_info_table = {}
function g.tbl.PID_OSD.table_default(i)
	g.tbl.PID_OSD.plyr_info_table[i] = {
	false, 	--do it
	0,		-- PID
	"",		-- name
	0,		--distance
	0,		-- kd
	0,		-- money
	0,		-- rank
	0,		-- time in session
	0,		-- host priority
	-1,		-- color
	false,	-- same color
	false,	-- 12 friend
	false,	-- 13 interior
	false,	-- 14 invisible
	}
end

g.tbl.PID_OSD.blink = {
false, -- otr
false, -- dead
false, -- mod spec
false, -- invis
}

-- g.tbl.PID_OSD.team_rgb = {
-- {255,255,255},-- table 1  == -1  -- white   gta reports org color as -1 when not in org/mc and momentarily when in org/mc
-- {247,159,123},-- table 2  ==  0  -- orange
-- {226,134,187},-- table 3  ==  1  -- pink
-- {239,238,151},-- table 4  ==  2  -- yellow
-- {113,169,175},-- table 5  ==  3  -- teal blue/green
-- {160,140,193},-- table 6  ==  4  -- purple
-- {141,206,167},-- table 7  ==  5  -- light green
-- {181,214,234},-- table 8  ==  6  -- light blue
-- {178,144,132},-- table 9  ==  7  -- brown
-- {0,  132,114},-- table 10 ==  8  -- dark green
-- {216,85,117},-- table 11 ==  9  -- hot pink
-- {255,255,255}-- table 12 == 10  -- I havent seen this as an org/mc color but without this slot here i will get an error
-- }

g.tbl.PID_OSD.team_rgb2 = {
[-1] = {r = 255,g = 255,b = 255},-- table 1  == -1  -- white   gta reports org color as -1 when not in org/mc and momentarily when in org/mc
[0] = {r = 247,g = 159,b = 123},-- table 2  ==  0  -- orange
[1] = {r = 226,g = 134,b = 187},-- table 3  ==  1  -- pink
[2] = {r = 239,g = 238,b = 151},-- table 4  ==  2  -- yellow
[3] = {r = 113,g = 169,b = 175},-- table 5  ==  3  -- teal blue/green
[4] = {r = 160,g = 140,b = 193},-- table 6  ==  4  -- purple
[5] = {r = 141,g = 206,b = 167},-- table 7  ==  5  -- light green
[6] = {r = 181,g = 214,b = 234},-- table 8  ==  6  -- light blue
[7] = {r = 178,g = 144,b = 132},-- table 9  ==  7  -- brown
[8] = {r = 0,  g = 132,b = 114},-- table 10 ==  8  -- dark green
[9] = {r = 216,g = 85,b = 117},-- table 11 ==  9  -- hot pink
[10] = {r = 255,g = 255,b = 255}-- table 12 == 10  -- I havent seen this as an org/mc color but without this slot here i will get an error
}

g.tbl.PID_OSD.team_rgba = {
[-1] = funcs.get.rgba_to_int(255,255,255,255), --white
[0] = funcs.get.rgba_to_int(247,159,123,255), --orange
[1] = funcs.get.rgba_to_int(226,134,187,255), --pink
[2] = funcs.get.rgba_to_int(239,238,151,255), --yello
[3] = funcs.get.rgba_to_int(113,169,175,255), --teal blue/green
[4] = funcs.get.rgba_to_int(160,140,193,255), --purple
[5] = funcs.get.rgba_to_int(141,206,167,255), --light green
[6] = funcs.get.rgba_to_int(181,214,234,255), --light blue
[7] = funcs.get.rgba_to_int(178,144,132,255), -- brown
[8] = funcs.get.rgba_to_int(0,  132,114,255), -- dark green
[9] = funcs.get.rgba_to_int(216,85,117,255),  -- hot pink
[10] = funcs.get.rgba_to_int(255,255,255,255) -- I havent seen this as an org/mc color but without this slot here i will get an error
}

local conversionValues = {a = 24, b = 16, g = 8, r = 0}
function funcs.get.convert_int_to_rgba(...) --thanks ghost cheese
    local int, val1, val2, val3, val4 = ...
    local values = {val1, val2, val3, val4}

    for k, v in pairs(values) do
        values[k] = int >> conversionValues[v] & 0xff
    end
    return table.unpack(values)
end

function funcs.get.rgba_from_pid(_pid)
	local color = g.tbl.PID_INFO.color[_pid+1]
	return color and g.tbl.PID_OSD.team_rgba[color] or g.tbl.PID_OSD.team_rgba[-1] 
	--return g.tbl.PID_OSD.team_rgba[g.tbl.PID_INFO.color[_pid+1]]
end

function g.tbl.PID_OSD.plyr_rgb(_pidT,_val)
	local color
	if funcs.is.num(_pidT) and _pidT > 0 then
		color = g.tbl.PID_OSD.team_rgb2[g.tbl.PID_INFO.color[_pidT]] or g.tbl.PID_OSD.team_rgb2[-1]
		if _val == "r" then
			return color.r
		elseif _val == "g" then
			return color.g
		elseif _val == "b" then
			return color.b
		end
		return color.r,color.g,color.b
	end
	if _val ~= nil then
		return 255
	end
	return 255,255,255
end

function funcs.get.popo_rgb(_r,_g,_b,_wntd)
	if _wntd and g.tbl.PID_OSD.plyr_sort_wanted.on and g.tbl.PID_OSD.plyr_sort_wanted.value ~= 0 then
		if g.tbl.PID_OSD.popo_rb == true then
			return	235,36,39
		elseif g.tbl.PID_OSD.popo_rb == false then
			return 38,136,234
		end
	end
	return _r,_g,_b
end

function g.tbl.PID_OSD.time_M_S_str(_pid_time)
	local timer = API.util.t_s()-_pid_time
	local minutes = timer/60
	local seconds = funcs.get.round_num((60*(minutes-mth.flr(minutes))))
	if seconds > 59 then
		seconds = mth.flr(seconds/60)
	end
	if seconds < 10 then
		return mth.flr(timer/60)..":".."0"..tostring(seconds)
	else
		return mth.flr(timer/60)..":"..seconds
	end
end


function g.tbl.PID_OSD.plyr_info_do(pidT,_pid,dead,frnd,_int,_wntd,_otr)
	local _table = g.tbl.PID_OSD.plyr_sort_left.list
	local plyr_info = ""
	local host = API.plyr.is.host(_pid)
	local s_host = (script.get_host_of_this_script()==_pid)
	local its_me = (_pid == API.plyr.my_id())

	if ntv.is.voice_active(_pid) then
		plyr_info=plyr_info..g.tbl.PID_OSD.voice_dots_L
	elseif g.tbl.PID_INFO.typing[pidT] then
		plyr_info=plyr_info..g.tbl.PID_OSD.text_dots
	end

	for i=1,9 do
		if _table[i] == 1 and g.tbl.PID_INFO.pause[pidT]==true then
			plyr_info=plyr_info.." [".."Pause".."]"
		elseif _table[i] == 2 and glbls.is_mission_active(_pid) then
			plyr_info=plyr_info.." [".."On Mission".."]"
		elseif _table[i] == 3 and _int then
			plyr_info=plyr_info.." ["..g.tbl.PID_INFO.interior_str[pidT].."]"
		elseif _table[i] == 4 and _wntd and g.tbl.PID_OSD.plyr_sort_wanted.on and g.tbl.PID_OSD.plyr_sort_wanted.value ~= 1 then
			plyr_info=plyr_info.." ["..API.plyr.get.wanted(_pid).." STAR".."]"
		elseif _table[i] == 5 then
			if g.tbl.PID_INFO.loading[pidT] then
				plyr_info=plyr_info.." [".."LOADING".."]"
			elseif dead or API.plyr.get.max_health(_pid) == 0.0 then
				if API.plyr.get.max_health(_pid) == 0.0 then
					plyr_info=plyr_info.." [".."UN-DEAD".."]"
				else
					plyr_info=plyr_info.." [".."DEAD".."]"
				end
			end
		elseif _table[i] == 6 then
			if host or s_host or frnd or its_me then
				plyr_info=plyr_info.." [".." "
				if host then plyr_info=plyr_info.."H" end
				if s_host then plyr_info=plyr_info.."S" end
				if frnd then plyr_info=plyr_info.."F" end
				if its_me then plyr_info=plyr_info.."Y" end
				plyr_info=plyr_info.." ".."]"
			end
		elseif _table[i] == 7 and _otr and not g.tbl.PID_INFO.loading[pidT] then
			plyr_info=plyr_info.." [".."OTR "..g.tbl.PID_OSD.time_M_S_str(g.tbl.PID_INFO.otr_time[pidT]).."]"
		elseif _table[i] == 8 and g.tbl.PID_OSD.plyr_sort_tis.on then
			plyr_info=plyr_info.." ["..g.tbl.PID_OSD.time_M_S_str(g.tbl.PID_INFO.join_time[pidT]).."]"
		elseif _table[i] == 9 and g.tbl.PID_OSD.plyr_sort_rank.on then
			plyr_info=plyr_info.." ["..g.tbl.PID_INFO.rank[pidT].."]"
		end
	end
	--plyr_info=plyr_info..ntv.c(0x1E314167F701DC3B,ui.get_blip_from_entity(API.plyr.get.ped(_pid))):__tointeger() -- GetBlipInfoIdDisplay\
	--plyr_info=plyr_info..ntv.c(0x1FC877464A04FC4F,ui.get_blip_from_entity(API.plyr.get.ped(_pid))):__tointeger() -- GetBlipSprite\


	--plyr_info=plyr_info..ui.get_blip_from_entity(API.plyr.get.ped(_pid))
	--plyr_info=plyr_info.." -- "..mth.flr( ntv.get.ent_height(API.plyr.get.ped(_pid)))
	--plyr_info=plyr_info.." ›»> <«‹		•·"
	return plyr_info
end
----------------------------------------------------------------------------------------------sort left
g.tbl.PID_OSD.plyr_sort_left = {}
g.tbl.PID_OSD.plyr_sort_left.list = {1,2,3,4,5,6,7,8,9}
g.tbl.PID_OSD.plyr_sort_left.str = {
"Pause",			--1
"On Mission",		--2
"Interior",			--3
"Wanted",			--4
"Loading/Dead",		--5
"Host/Friend",		--6
"Off the radar",	--7
"Time in session",	--8
"Rank"}				--9

function g.tbl.PID_OSD.plyr_sort_left_do(_feat,_bool)
	local msg,_value = ""
	local _val_table = {}
	local _feat_table = {}
	for i=1,9 do
		if g.tbl.PID_OSD.plyr_sort_left[i].name == _feat.name then
			_value = _feat.value
			_feat_table[i]=true
			break
		end
	end
	for i=1,9 do
		_val_table[i] = g.tbl.PID_OSD.plyr_sort_left[i].value
	end
	for feat=1,9 do
		if not _feat_table[feat] then
			for i=1,9 do
				if not _feat_table[i] then
					if g.tbl.PID_OSD.plyr_sort_left[i].value == _value then
						for ii=0,8 do
							if not funcs.is.table_has(_val_table,ii) then
								g.tbl.PID_OSD.plyr_sort_left[i].value = ii
								_val_table[#_val_table+1] = ii
								_feat_table[i]=true
								break
							end
						end
					end
				end
			end
		end
	end
	for i=1,9 do
		g.tbl.PID_OSD.plyr_sort_left.list[i] = g.tbl.PID_OSD.plyr_sort_left[i].value+1
		msg = msg..i.." - "..g.tbl.PID_OSD.plyr_sort_left.str[g.tbl.PID_OSD.plyr_sort_left[i].value+1].."\n"
	end
	if _bool then
		g.N_P(2,"Player info overlay left sorted to:\n"..msg,__GV__,5,"Blue")
	end
end

for i=1,9 do
	g.tbl.PID_OSD.plyr_sort_left[i]=menu_add_feature("Left info slot #"..i, "action_value_str", g.tbl.PID_OSD.sort_prnt_left.id,function(f)
		g.tbl.PID_OSD.plyr_sort_left_do(g.tbl.PID_OSD.plyr_sort_left[i],true)
	end)
	new_set_str_data(g.tbl.PID_OSD.plyr_sort_left[i],g.tbl.PID_OSD.plyr_sort_left.str)
	g.tbl.PID_OSD.plyr_sort_left[i].value = i-1
end

g.tbl.PID_OSD.plyr_sort_left.default_feat=menu_add_feature("Left info slots default", "action", g.tbl.PID_OSD.sort_prnt_left.id,function(f)
	g.tbl.PID_OSD.plyr_sort_left.list = {1,2,3,4,5,6,7,8,9}
	local msg = ""
	for i=1,9 do
		g.tbl.PID_OSD.plyr_sort_left[i].value = i-1
		msg = msg..i.." - "..g.tbl.PID_OSD.plyr_sort_left.str[g.tbl.PID_OSD.plyr_sort_left[i].value+1].."\n"
	end
	g.N_P(2,"Player info overlay left sorted to:\n"..msg,__GV__,5,"Blue")
end)
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------sort right
g.tbl.PID_OSD.plyr_sort_right = {}
g.tbl.PID_OSD.plyr_sort_right.list = {1,2,3,4,5}
g.tbl.PID_OSD.plyr_sort_right.str = {
"Name",
"Money",
"KD",
"Vehicle",
"Speed"
}

function g.tbl.PID_OSD.plyr_sort_right_do(_feat,_bool)
	local msg,_value = ""
	local _val_table = {}
	local _feat_table = {}
	for i=1,5 do
		if g.tbl.PID_OSD.plyr_sort_right[i].name == _feat.name then
			_value = _feat.value
			_feat_table[i]=true
			break
		end
	end
	for i=1,5 do
		_val_table[i] = g.tbl.PID_OSD.plyr_sort_right[i].value
	end
	for feat=1,5 do
		if not _feat_table[feat] then
			for i=1,5 do
				if not _feat_table[i] then
					if g.tbl.PID_OSD.plyr_sort_right[i].value == _value then
						for ii=0,4 do
							if not funcs.is.table_has(_val_table,ii) then
								g.tbl.PID_OSD.plyr_sort_right[i].value = ii
								_val_table[#_val_table+1] = ii
								_feat_table[i]=true
								break
							end
						end
					end
				end
			end
		end
	end
	for i=1,5 do
		g.tbl.PID_OSD.plyr_sort_right.list[i] = g.tbl.PID_OSD.plyr_sort_right[i].value+1
		msg = msg..i.." - "..g.tbl.PID_OSD.plyr_sort_right.str[g.tbl.PID_OSD.plyr_sort_right[i].value+1].."\n"
	end
	if _bool then
		g.N_P(2,"Player info overlay right sorted to:\n"..msg,__GV__,5,"Blue")
	end
end

for i=1,5 do
	g.tbl.PID_OSD.plyr_sort_right[i]=menu_add_feature("Right info slot #"..i, "action_value_str", g.tbl.PID_OSD.sort_prnt_right.id,function(f)
		g.tbl.PID_OSD.plyr_sort_right_do(g.tbl.PID_OSD.plyr_sort_right[i],true)
	end)
	new_set_str_data(g.tbl.PID_OSD.plyr_sort_right[i],g.tbl.PID_OSD.plyr_sort_right.str)
	g.tbl.PID_OSD.plyr_sort_right[i].value = i-1
end

g.tbl.PID_OSD.plyr_sort_right.default_feat=menu_add_feature("Right info slots default", "action", g.tbl.PID_OSD.sort_prnt_right.id,function(f)
	g.tbl.PID_OSD.plyr_sort_right.list = {1,2,3,4,5}
	local msg = ""
	for i=1,5 do
		g.tbl.PID_OSD.plyr_sort_right[i].value = i-1
		msg = msg..i.." - "..g.tbl.PID_OSD.plyr_sort_right.str[g.tbl.PID_OSD.plyr_sort_right[i].value+1].."\n"
	end
	g.N_P(2,"Player info overlay right sorted to:\n"..msg,__GV__,5,"Blue")
end)
----------------------------------------------------------------------------------------------
function g.tbl.PID_OSD.rgb_do(mod_spec,frnd,dead,otr,_r,_g,_b,popo,_wntd,_invis)
	local _r,_g,_b = _r,_g,_b
	if _invis and g.tbl.PID_OSD.blink[4] then
		_r,_g,_b = 255,192,203
	elseif mod_spec and g.tbl.PID_OSD.blink[3] then
		_r,_g,_b =  255,0,0
	elseif frnd and not dead and not otr then
		_r,_g,_b =  255,255,0
	elseif dead and g.tbl.PID_OSD.blink[2] then
		_r,_g,_b =  0,0,0
	elseif otr and g.tbl.PID_OSD.blink[1] then
		_r,_g,_b =  0,255,0
	end
	if popo then _r,_g,_b = funcs.get.popo_rgb(_r,_g,_b,_wntd) end
	return _r,_g,_b
end

function g.tbl.PID_OSD.god_mod_do(_pid,_int,_invis)
	local god_mod_text=""
	local gm_table = {}
	if not _int and g.tbl.PID_INFO.plyr_god[_pid+1] then
		gm_table[#gm_table+1]="G"
	end
	if not _int and (g.tbl.PID_INFO.in_veh[_pid+1] and g.tbl.PID_INFO.veh_god[_pid+1]) then
		gm_table[#gm_table+1]="VG"
	end
	if g.tbl.PID_INFO.modder[_pid+1] then
		gm_table[#gm_table+1]="M"
	end
	if not _int and _invis then
		gm_table[#gm_table+1]="IV"
	end
	if #gm_table > 0 then
		god_mod_text=god_mod_text.."["
		for i=1,#gm_table do
			god_mod_text=god_mod_text..gm_table[i]
			if gm_table[i+1] == "IV" then
				god_mod_text=god_mod_text.." "
			end
		end
		god_mod_text=god_mod_text.."]"
	end

	-- local plyr_g = g.tbl.PID_INFO.plyr_god[_pid+1]
	-- local veh_g = (g.tbl.PID_INFO.in_veh[_pid+1] and g.tbl.PID_INFO.veh_god[_pid+1])
	-- local plyr_m = g.tbl.PID_INFO.modder[_pid+1]
	-- if not _int and (plyr_g or veh_g) then
		-- god_mod_text=god_mod_text.."["
		-- if plyr_m then god_mod_text=god_mod_text.."M" end
		-- if plyr_g then god_mod_text=god_mod_text.."G" end
		-- if veh_g then god_mod_text=god_mod_text.."V" end
		-- god_mod_text=god_mod_text.."]"
	-- elseif plyr_m then god_mod_text=god_mod_text.."[M]"
	-- end
	return god_mod_text
end

function g.tbl.PID_OSD.name_do(_pid,pidT,dead)
	local name,mod_spec ="",false
	local count,brckt1,brckt2 = 1
	local _r,_g,_b = g.tbl.PID_OSD.plyr_rgb(pidT)
	local _table = g.tbl.PID_OSD.plyr_sort_right.list
	-- local function brckt(_val)
		-- if funcs.is.even_num(_val) then
			-- return " {","}"
		-- end
		-- return " [","]"
	-- end
	local function get_total_money_str(_val)
		if _val >= 1000000000 then
			return "$ "..funcs.get._2_dec(_val/1000000000).." B"
		elseif _val >= 1000000 then
			return "$ "..funcs.get._2_dec(_val/1000000).." M"
		elseif _val >= 1000 then
			return "$ "..funcs.get._2_dec(_val/1000).." K"
		end
		return "$ ".._val
	end
	for i=1,5 do
		--brckt1,brckt2 = brckt(count)
		if _table[i] == 1 then name=name.." "..g.tbl.PID_INFO.name[pidT] count = count + 1 end
		if _table[i] == 2 and g.tbl.PID_OSD.plyr_sort_money.on then name=name.." ["..get_total_money_str(g.tbl.PID_INFO.money[_pid+1]).."]" count = count + 1 end
		if _table[i] == 3 and g.tbl.PID_OSD.plyr_sort_kd.on then name=name.." [".."KD "..g.tbl.PID_INFO.kd[pidT].."]" count = count + 1 end


		if _table[i] == 4 and g.tbl.PID_OSD.plyr_sort_veh.on then
			if g.tbl.PID_INFO.in_veh[pidT] then
				name=name.." ["..funcs.get.veh_model_name(g.tbl.PID_INFO.veh[pidT]).."]"
				count = count + 1
			else
				local PED = API.plyr.get.ped(_pid)
				local blip_info = funcs.get.ent_blip_image_and_rot(PED)
				local blip_str = veh_stuff.hash_is_name[blip_info]
				if blip_info and not blip_str and type(blip_info) == "string" then
					blip_str = string.sub(blip_info,1,#blip_info-1)
				end
				if blip_str then
					name=name.." [*"..blip_str.."]"
					count = count + 1
				elseif API.plyr.get.coords(_pid).z == -50 then
					name=name.." [*Vehicle]"
					count = count + 1
				end
			end
		end
		if _table[i] == 5 then
			if (g.tbl.PID_OSD.plyr_sort_speed_veh.on and g.tbl.PID_INFO.in_veh[pidT]) or (g.tbl.PID_OSD.plyr_sort_speed_ped.on and not g.tbl.PID_INFO.in_veh[pidT]) then
				if g.tbl.PID_OSD.plyr_sort_speed_type.value == 0 and g.tbl.PID_INFO.plyr_speed_pos_mph[pidT] > g.tbl.PID_OSD.plyr_sort_speed_above.value then
					if g.tbl.PID_INFO.plyr_speed_pos_mph[pidT] < 5 then
						name=name.." ["..funcs.get._1_dec(g.tbl.PID_INFO.plyr_speed_pos_mph[pidT]).." MPH".."]"
					else
						name=name.." ["..mth.flr(g.tbl.PID_INFO.plyr_speed_pos_mph[pidT]).." MPH".."]"
					end
					count = count + 1
				elseif g.tbl.PID_OSD.plyr_sort_speed_type.value == 1 and g.tbl.PID_INFO.plyr_speed_pos_kph[pidT] > g.tbl.PID_OSD.plyr_sort_speed_above.value then
					if g.tbl.PID_INFO.plyr_speed_pos_kph[pidT] < 5 then
						name=name.." ["..funcs.get._1_dec(g.tbl.PID_INFO.plyr_speed_pos_kph[pidT]).." KPH".."]"
					else
						name=name.." ["..mth.flr(g.tbl.PID_INFO.plyr_speed_pos_kph[pidT]).." KPH".."]"
					end
					count = count + 1
				end
			end
		end
	end
	if API.plyr.is.spectating(_pid) then
		-- local spctee =  network.get_player_player_is_spectating(_pid)
		-- if spctee ~= nil and g.tbl.PID_INFO.name[spctee+1] ~= nil then

		local spctee = network.get_entity_player_is_spectating(_pid)
		if funcs.is.ent(spctee) and API.ent.is.ped(spctee) and API.Ped.is.plyr(spctee) then
			spctee = API.plyr.get.plyr_from_ped(spctee)
			if not g.tbl.PID_INFO.interior[pidT] and not dead then mod_spec = true name=name.." - MODDED SPECTATE: "
			else name=name.." - Spectating: " end
			name=name..g.tbl.PID_INFO.name[spctee+1]
		end
	end
	if ntv.is.voice_active(_pid) then
		name=name..g.tbl.PID_OSD.voice_dots_R
	elseif g.tbl.PID_INFO.typing[pidT] then
		name=name..g.tbl.PID_OSD.text_dots
	end
	return name,_r,_g,_b,mod_spec
end



g.tbl.PID_OSD.plyr_list_feat=menu_add_feature("Show player list", "toggle", g.prnt.utils_info_overlay.id, function(f)
	while not g.var.GS_has_loaded do
		YIELD(500)
	end
	g.tbl.PID_OSD.plyr_sort_left_do(g.tbl.PID_OSD.plyr_sort_left[1],false)
	funcs.doo.PID_OSD_hide(not f.on)
	g.tbl.PID_OSD.plyr_list_record_feat.on=f.on
	g.tbl.PID_OSD.popo_rb_feat.on=f.on
	g.tbl.PID_OSD.blink_do.on=f.on
	local max_count,count,y_val, y_offset,x_pos,y_once,y_off_once,more_players_once,dist_offset,god_offset
	local _r,_g,_b,plyr_info_offset,plyr_info,_dead,_otr,_frnd,mod_spec,god_mod_text,name,_pid,_pidT,_int,_table,_wntd
	local alpha_switch,alpha_calc,alpha_fade,alpha,alpha_speed,_invis = true,100,100,255
	while f.on do
		YIELD(5)
		if g.tbl.PID_OSD.plyr_sort_int_alpha.value == 0 then

			if alpha_switch then
				alpha_calc = alpha_calc *(1.001+(g.tbl.PID_OSD.plyr_sort_int_alpha_speed.value/1000))
				if alpha_calc >= 220 then alpha_switch = false end
			else
				alpha_calc = alpha_calc *(.999-(g.tbl.PID_OSD.plyr_sort_int_alpha_speed.value/1000))
				if alpha_calc <= 150 then alpha_switch = true end
			end
			alpha_fade=mth.flr(alpha_calc)
		else
			alpha_fade = g.tbl.PID_OSD.alpha_str[g.tbl.PID_OSD.plyr_sort_int_alpha.value+1]
		end
		_table = {}
		for i=1,32 do
			if g.tbl.PID_OSD.plyr_info_table[i] ~= nil and g.tbl.PID_OSD.plyr_info_table[i][1] and API.plyr.is.valid(g.tbl.PID_OSD.plyr_info_table[i][2]) and API.plyr.get.name(g.tbl.PID_OSD.plyr_info_table[i][2]) == g.tbl.PID_OSD.plyr_info_table[i][3] then
				_table[#_table+1] = g.tbl.PID_OSD.plyr_info_table[i]
			end
		end
		if #_table < 1 then
			YIELD(250)
		else
			max_count = g.tbl.PID_OSD.plyr_sort_max.value
			count = 0
			y_once,y_off_once,more_players_once=false,false,false
			y_val = g.tbl.PID_OSD.plyr_sort_y.value
			y_offset = g.tbl.PID_OSD.plyr_sort_space_ver.value
			for i=1,#_table do
				if count < max_count then
					x_pos = g.tbl.PID_OSD.plyr_sort_x.value
					if g.tbl.PID_OSD.plyr_sort_column_space.on then
						if (g.tbl.PID_OSD.plyr_sort_column_type.value == 0 and i > funcs.get.round_num(max_count/2)) or (g.tbl.PID_OSD.plyr_sort_column_type.value == 1 and i > funcs.get.round_num(#_table/2)) then
							x_pos=x_pos+g.tbl.PID_OSD.plyr_sort_column_space.value
							if not y_once then
								y_val = g.tbl.PID_OSD.plyr_sort_y.value
								y_once=true
							end
						end
					end
					if i > 1 then
						if y_once and not y_off_once then y_off_once=true else y_val = y_val + y_offset	end
					end
					dist_offset = x_pos-(g.tbl.PID_OSD.plyr_sort_space_hor.value/4*3)
					plyr_info_offset = dist_offset-.5
					--god_offset = x_pos-((x_pos-dist_offset)*(g.tbl.PID_OSD.plyr_sort_space_hor.value/25))
					god_offset = x_pos-(g.tbl.PID_OSD.plyr_sort_space_hor.value/4.69)

					_pid,_pidT = _table[i][2],_table[i][2]+1
					_otr = (g.tbl.PID_INFO.otr_time[_pidT] ~= -1)
					_dead = g.tbl.PID_INFO.dead[_pidT]
					_frnd = _table[i][12]
					_int = g.tbl.PID_INFO.interior[_pidT]
					_wntd = (API.plyr.get.wanted(_pid) > 0)
					_invis = g.tbl.PID_INFO.invisible[_pidT]
					if _int then alpha = alpha_fade else alpha = 255 end

					-- on mission,loading,time in session, off the radar etc --
					plyr_info = g.tbl.PID_OSD.plyr_info_do(_pidT,_pid,_dead,_frnd,_int,_wntd,_otr)
					_r,_g,_b = g.tbl.PID_OSD.rgb_do(false,_frnd,_dead,_otr,255,255,255,true,_wntd,_invis)
					funcs.doo.overlay_right(plyr_info,_r,_g,_b,alpha,g.tbl.PID_OSD.plyr_sort_scale.value/300,g.tbl.PID_OSD.plyr_sort_font.value,plyr_info_offset/300,y_val/300,(plyr_info_offset-20)/300)

					-- distance --
					funcs.doo.overlay_left(mth.flr(g.tbl.PID_OSD.dist_table[_pid+1][1]),_r,_g,_b,alpha,g.tbl.PID_OSD.plyr_sort_scale.value/300,g.tbl.PID_OSD.plyr_sort_font.value,dist_offset/300,y_val/300)

					-- god or mod --
					god_mod_text = g.tbl.PID_OSD.god_mod_do(_pid,_int,_invis)
					if god_mod_text ~= "" then
						_r,_g,_b = g.tbl.PID_OSD.rgb_do(false,false,_dead,false,255,0,0,false,false,_invis)
						funcs.doo.overlay(god_mod_text,_r,_g,_b,alpha,g.tbl.PID_OSD.plyr_sort_scale.value/300,g.tbl.PID_OSD.plyr_sort_font.value,god_offset/300,y_val/300,(god_offset-20)/300)
					end

					-- name,vehicle,kd,money,etc
					name,_r,_g,_b,mod_spec = g.tbl.PID_OSD.name_do(_pid,_pidT,_dead)
					_r,_g,_b = g.tbl.PID_OSD.rgb_do(mod_spec,false,_dead,false,_r,_g,_b,false,false,false)
					funcs.doo.overlay_left(name,_r,_g,_b,alpha,g.tbl.PID_OSD.plyr_sort_scale.value/300,g.tbl.PID_OSD.plyr_sort_font.value,x_pos/300,y_val/300)
					count=count+1
				elseif count == max_count and count < #_table and not more_players_once then
					y_val = y_val + y_offset
					more_players = tostring(#_table-count)
					if #_table-count > 1 then more_players=more_players.." players hidden"	else more_players=more_players.." player hidden" end
					funcs.doo.overlay_left(more_players,255,255,255,150,g.tbl.PID_OSD.plyr_sort_scale.value/300,g.tbl.PID_OSD.plyr_sort_font.value,x_pos/300,y_val/300)
					more_players_once=true
				end
			end
		end
	end
	funcs.doo.PID_OSD_hide(not f.on)
	g.tbl.PID_OSD.plyr_list_record_feat.on=f.on
	g.tbl.PID_OSD.popo_rb_feat.on=f.on
	g.tbl.PID_OSD.blink_do.on=f.on
end)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_list_feat,"g.tbl.PID_OSD.plyr_list_feat")

g.tbl.PID_OSD.plyr_list_record_feat=og_menu_add_feature("Show player list HIDDEN", "toggle", g.prnt.utils_info_overlay.id, function(f)
	local top_table,other_table,end_table,bottom_table
	local function color_check(mine,theirs)
		if mine > -1 and theirs > -1 and mine == theirs then
			return true
		end
		return false
	end
	local function sort_for_top(_table,_val)
		top_table,other_table,bottom_table,end_table = {},{},{},{}
		for i=1,32 do
			if g.tbl.PID_OSD.plyr_sort_interior.on and _table[i][13] then
				bottom_table[#bottom_table+1]=_table[i]
			elseif _val == 0 then
				if _table[i][12] then
					top_table[#top_table+1]=_table[i]
				else
					other_table[#other_table+1]=_table[i]
				end
			else
				if _table[i][11] then
					top_table[#top_table+1]=_table[i]
				else
					other_table[#other_table+1]=_table[i]
				end
			end
		end
		if #top_table > 0 then
			if #top_table > 1 then
				g.tbl.PID_OSD.sort_do(top_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
			end
			for i=1,#top_table do
				end_table[#end_table+1]=top_table[i]
			end
		end
		if #other_table > 0 then
			if #other_table > 1 then
				g.tbl.PID_OSD.sort_do(other_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
			end
			for i=1,#other_table do
				end_table[#end_table+1]=other_table[i]
			end
		end
		if #bottom_table > 0 then
			if #bottom_table > 1 then
				g.tbl.PID_OSD.sort_do(bottom_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
			end
			for i=1,#bottom_table do
				end_table[#end_table+1]=bottom_table[i]
			end
		end
		return end_table
	end
	local function sort_for_bottom(_table)
		other_table,bottom_table,end_table = {},{},{}
		for i=1,32 do
			if _table[i][13] then
				bottom_table[#bottom_table+1]=_table[i]
			else
				other_table[#other_table+1]=_table[i]
			end
		end
		if #other_table > 0 then
			if #other_table > 1 then
				g.tbl.PID_OSD.sort_do(other_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
			end
			for i=1,#other_table do
				end_table[#end_table+1]=other_table[i]
			end
		end
		if #bottom_table > 0 then
			if #bottom_table > 1 then
				g.tbl.PID_OSD.sort_do(bottom_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
			end
			for i=1,#bottom_table do
				end_table[#end_table+1]=bottom_table[i]
			end
		end
		return end_table
	end
    while f.on do
		g.tbl.PID_OSD.sort_bool=false
		for i=1,32 do
			if funcs.is.valid_pid(i-1) and (g.tbl.PID_OSD.plyr_sort_self.on or i-1 ~= API.plyr.my_id()) then
				g.tbl.PID_OSD.plyr_info_table[i] = {
					true, 											-- 1  do it
					i-1,											-- 2  PID
					g.tbl.PID_INFO.name[i],							-- 3  name
					g.tbl.PID_OSD.dist_table[i][1],			-- 4  distance
					g.tbl.PID_INFO.kd[i],							-- 5  kd
					g.tbl.PID_INFO.money[i],							-- 6  money
					g.tbl.PID_INFO.rank[i],							-- 7  rank
					API.util.t_s()-g.tbl.PID_INFO.join_time[i],		-- 8  time in session
					API.plyr.get.host_priority(i-1),			-- 9  host priority
					g.tbl.PID_INFO.color[i],							-- 10 color
					color_check(g.tbl.PID_INFO.color[API.plyr.my_id()+1],g.tbl.PID_INFO.color[i]),	-- 11 same org/mc
					API.plyr.is.friend(i-1),					-- 12 friend
					g.tbl.PID_INFO.interior[i],						-- 13 interior
				}
			else
				g.tbl.PID_OSD.table_default(i)
			end
		end
		if g.tbl.PID_OSD.plyr_sort_top.on then
			g.tbl.PID_OSD.plyr_info_table = sort_for_top(g.tbl.PID_OSD.plyr_info_table,g.tbl.PID_OSD.plyr_sort_top.value)
		elseif g.tbl.PID_OSD.plyr_sort_interior.on then
			g.tbl.PID_OSD.plyr_info_table = sort_for_bottom(g.tbl.PID_OSD.plyr_info_table)
		else
			g.tbl.PID_OSD.sort_do(g.tbl.PID_OSD.plyr_info_table,g.tbl.PID_OSD.plyr_sort_by_val.value)
		end
		funcs.doo.yield_while_true(f.on and (g.tbl.PID_OSD.sort_bool==false),250)
	end
end)
g.tbl.PID_OSD.plyr_list_record_feat.hidden=true

function g.tbl.PID_OSD.sort_do(_table,_val)
	if _val == 1 then -- alphabetical
		if  g.tbl.PID_OSD.plyr_sort_asc_desc.value == 0 then table.sort(_table, function(a, b) return a[3]:lower() < b[3]:lower() end)  -- thank you mr kek
		else table.sort(_table, function(a, b) return a[3]:lower() > b[3]:lower() end)  -- thank you mr kek
		end
	elseif _val == 2 then -- distance
		if  g.tbl.PID_OSD.plyr_sort_asc_desc.value == 0 then table.sort(_table, function(a, b) return a[4] < b[4] end)
		else table.sort(_table, function(a, b) return a[4] > b[4] end)
		end
	else -- other
		if g.tbl.PID_OSD.plyr_sort_asc_desc.value == 0 then
			table.sort(_table, function(a, b)
				if a[_val+2] == b[_val+2] then return a[4] < b[4]
				else return a[_val+2] < b[_val+2]
				end
			end)
		else
			table.sort(_table, function(a, b)
				if a[_val+2] == b[_val+2] then return a[4] > b[4]
				else return a[_val+2] > b[_val+2]
				end
			end)
		end
	end
end

g.tbl.PID_OSD.blink_do=og_menu_add_feature("hidden - makes blinks, blink, and dots, dot", "toggle", g.prnt.utils_info_overlay.id, function(f)
	while f.on do
		YIELD(50)
		g.tbl.PID_OSD.text_dots="..."
		for i=1,10 do
			if i < 5 then
				g.tbl.PID_OSD.blink[i]=true
				funcs.doo.yield_while_true(f.on,100)
				g.tbl.PID_OSD.text_dots=g.tbl.PID_OSD.text_dots.."."
				g.tbl.PID_OSD.blink[i]=false
				funcs.doo.yield_while_true(f.on,100)
				g.tbl.PID_OSD.text_dots=g.tbl.PID_OSD.text_dots.."."
			else
				g.tbl.PID_OSD.text_dots=g.tbl.PID_OSD.text_dots.."."
				funcs.doo.yield_while_true(f.on,25)
			end
		end
	end
end)
g.tbl.PID_OSD.blink_do.hidden=true

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	while true do
		g.tbl.PID_OSD.voice_dots_L="››››>>"
		g.tbl.PID_OSD.voice_dots_R="<<‹‹‹‹"
		YIELD(250)

		g.tbl.PID_OSD.voice_dots_L="›››>>›"
		g.tbl.PID_OSD.voice_dots_R="‹<<‹‹‹"
		YIELD(250)

		g.tbl.PID_OSD.voice_dots_L="››>>››"
		g.tbl.PID_OSD.voice_dots_R="‹‹<<‹‹"
		YIELD(250)

		g.tbl.PID_OSD.voice_dots_L="›>>›››"
		g.tbl.PID_OSD.voice_dots_R="‹‹‹<<‹"
		YIELD(250)

		g.tbl.PID_OSD.voice_dots_L=">>››››"
		g.tbl.PID_OSD.voice_dots_R="‹‹‹‹<<"
		YIELD(250)

	end
end)


g.tbl.PID_OSD.popo_rb_feat=og_menu_add_feature("hidden - makes police colrs flash", "toggle", g.prnt.utils_info_overlay.id, function(f)
	while f.on do
		for i=1,4 do
			g.tbl.PID_OSD.popo_rb=true
			funcs.doo.yield_while_true(f.on,125)
			g.tbl.PID_OSD.popo_rb=false
			funcs.doo.yield_while_true(f.on,225)
		end
		g.tbl.PID_OSD.popo_rb=nil
		funcs.doo.yield_while_true(f.on,1000)
	end
end)
g.tbl.PID_OSD.popo_rb_feat.hidden=true

g.tbl.PID_OSD.plyr_sort_by_val=menu_add_feature("Player list sort by:", "autoaction_value_str", g.tbl.PID_OSD.sort_prnt.id,function()
	g.tbl.PID_OSD.sort_bool=true
end)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_by_val,{"PID","Alphabetically","Distance","K/D Ratio","Money","Rank","Time in session","Host Priority"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_by_val,"g.tbl.PID_OSD.plyr_sort_by_val")

g.tbl.PID_OSD.plyr_sort_asc_desc=menu_add_feature("Player list sort type:", "autoaction_value_str", g.tbl.PID_OSD.sort_prnt.id,function()
	g.tbl.PID_OSD.sort_bool=true
end)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_asc_desc,{"Ascending", "Descending"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_asc_desc,"g.tbl.PID_OSD.plyr_sort_asc_desc")

g.tbl.PID_OSD.plyr_sort_top = menu_add_feature("Always top of the list:", "value_str", g.tbl.PID_OSD.sort_prnt.id)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_top,{"Friends","Org/MC"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_top,"g.tbl.PID_OSD.plyr_sort_top")

g.tbl.PID_OSD.plyr_sort_interior = menu_add_feature("Interior always at bottom of list", "toggle", g.tbl.PID_OSD.sort_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_interior,"g.tbl.PID_OSD.plyr_sort_interior")

g.tbl.PID_OSD.plyr_sort_self = menu_add_feature("Include self on list", "toggle", g.tbl.PID_OSD.sort_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_self,"g.tbl.PID_OSD.plyr_sort_self")

g.tbl.PID_OSD.plyr_sort_money = menu_add_feature("Show money", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_money,"g.tbl.PID_OSD.plyr_sort_money")

g.tbl.PID_OSD.plyr_sort_rank = menu_add_feature("Show rank", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_rank,"g.tbl.PID_OSD.plyr_sort_rank")

g.tbl.PID_OSD.plyr_sort_kd = menu_add_feature("Show K/D", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_kd,"g.tbl.PID_OSD.plyr_sort_kd")

g.tbl.PID_OSD.plyr_sort_veh = menu_add_feature("Show vehicle", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_veh,"g.tbl.PID_OSD.plyr_sort_veh")

g.tbl.PID_OSD.plyr_sort_speed_veh = menu_add_feature("Show speed in a vehicle", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_speed_veh,"g.tbl.PID_OSD.plyr_sort_speed_veh")

g.tbl.PID_OSD.plyr_sort_speed_ped = menu_add_feature("Show speed on foot", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_speed_ped,"g.tbl.PID_OSD.plyr_sort_speed_ped")

g.tbl.PID_OSD.plyr_sort_speed_type = menu_add_feature("Show speed using:", "autoaction_value_str", g.tbl.PID_OSD.show_info_prnt.id)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_speed_type,{"MPH","KPH"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_speed_type,"g.tbl.PID_OSD.plyr_sort_speed_type")

g.tbl.PID_OSD.plyr_sort_speed_above = menu_add_feature("Only show speed above", "action_value_i", g.tbl.PID_OSD.show_info_prnt.id)
g.tbl.PID_OSD.plyr_sort_speed_above.max,g.tbl.PID_OSD.plyr_sort_speed_above.min,g.tbl.PID_OSD.plyr_sort_speed_above.mod=200,0,5
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_speed_above,"g.tbl.PID_OSD.plyr_sort_speed_above")

g.tbl.PID_OSD.plyr_sort_wanted = menu_add_feature("Show wanted level", "value_str", g.tbl.PID_OSD.show_info_prnt.id)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_wanted,{"Show stars","Blink red/blue","Show both"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_wanted,"g.tbl.PID_OSD.plyr_sort_wanted")

g.tbl.PID_OSD.plyr_sort_tis = menu_add_feature("Show time in session", "toggle", g.tbl.PID_OSD.show_info_prnt.id)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_tis,"g.tbl.PID_OSD.plyr_sort_tis")

g.tbl.PID_OSD.plyr_sort_column_space = menu_add_feature("Display two columns: Spacing", "value_i", g.tbl.PID_OSD.display_prnt.id)
g.tbl.PID_OSD.plyr_sort_column_space.max,g.tbl.PID_OSD.plyr_sort_column_space.min,g.tbl.PID_OSD.plyr_sort_column_space.mod=250,25,5
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_column_space,"g.tbl.PID_OSD.plyr_sort_column_space")

g.tbl.PID_OSD.plyr_sort_column_type = menu_add_feature("Display two columns: Type", "autoaction_value_str", g.tbl.PID_OSD.display_prnt.id)
new_set_str_data(g.tbl.PID_OSD.plyr_sort_column_type,{"If needed","Always 50/50"})
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_column_type,"g.tbl.PID_OSD.plyr_sort_column_type")

g.tbl.PID_OSD.plyr_sort_int_alpha = menu_add_feature("Interior player alpha", "autoaction_value_str", g.tbl.PID_OSD.display_prnt.id,function(f)
	if f.value == 0 then
		g.tbl.PID_OSD.plyr_sort_int_alpha_speed.hidden=false
	else
		g.tbl.PID_OSD.plyr_sort_int_alpha_speed.hidden=true
	end
end)
g.tbl.PID_OSD.plyr_sort_int_alpha:set_str_data(g.tbl.PID_OSD.alpha_str)
funcs.add_to_S_L(g.tbl.PID_OSD.plyr_sort_int_alpha,"g.tbl.PID_OSD.plyr_sort_int_alpha")

g.tbl.PID_OSD.plyr_sort_int_alpha_speed = menu_add_feature("Alpha fade speed", "action_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_int_alpha_speed,1,10,1,5,"g.tbl.PID_OSD.plyr_sort_int_alpha_speed")

g.tbl.PID_OSD.plyr_sort_max = menu_add_feature("Max Players", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_max,1,32,1,32,"g.tbl.PID_OSD.plyr_sort_max")

g.tbl.PID_OSD.plyr_sort_x = menu_add_feature("X Pos", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_x,0,300,1,0,"g.tbl.PID_OSD.plyr_sort_x")

g.tbl.PID_OSD.plyr_sort_y = menu_add_feature("Y Pos", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_y,0,300,1,0,"g.tbl.PID_OSD.plyr_sort_y")

g.tbl.PID_OSD.plyr_sort_space_hor = menu_add_feature("Horizontal Spacing", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_space_hor,1,25,1,1,"g.tbl.PID_OSD.plyr_sort_space_hor")

g.tbl.PID_OSD.plyr_sort_space_ver = menu_add_feature("Vertical Spacing", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_space_ver,1,25,1,1,"g.tbl.PID_OSD.plyr_sort_space_ver")

g.tbl.PID_OSD.plyr_sort_scale = menu_add_feature("Scale", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_scale,75,300,1,75,"g.tbl.PID_OSD.plyr_sort_scale")

g.tbl.PID_OSD.plyr_sort_font = menu_add_feature("Font", "autoaction_value_i", g.tbl.PID_OSD.display_prnt.id)
funcs.set_feat_i_f(g.tbl.PID_OSD.plyr_sort_font,0,9,1,0,"g.tbl.PID_OSD.plyr_sort_font")

function funcs.doo.PID_OSD_hide(_bool)
g.tbl.PID_OSD.sort_prnt.hidden=_bool
g.tbl.PID_OSD.display_prnt.hidden=_bool
g.tbl.PID_OSD.show_info_prnt.hidden=_bool
end
funcs.doo.PID_OSD_hide(true)

function funcs.doo.PID_OSD_recc_sett()
g.tbl.PID_OSD.plyr_sort_by_val.value=2
g.tbl.PID_OSD.plyr_sort_self.on=true
g.tbl.PID_OSD.plyr_sort_money.on=true
g.tbl.PID_OSD.plyr_sort_rank.on=true
g.tbl.PID_OSD.plyr_sort_kd.on=true
g.tbl.PID_OSD.plyr_sort_veh.on=true
g.tbl.PID_OSD.plyr_sort_max.value=32
g.tbl.PID_OSD.plyr_sort_space_hor.value=10
g.tbl.PID_OSD.plyr_sort_space_ver.value=5
g.tbl.PID_OSD.plyr_sort_x.value=91
g.tbl.PID_OSD.plyr_sort_y.value=3
g.tbl.PID_OSD.plyr_sort_scale.value=75
g.tbl.PID_OSD.plyr_sort_font.value=4
g.tbl.PID_OSD.plyr_sort_column_space.on=true
g.tbl.PID_OSD.plyr_sort_column_space.value=100
g.tbl.PID_OSD.plyr_sort_column_type.value=1
g.tbl.PID_OSD.plyr_sort_wanted.on=true
g.tbl.PID_OSD.plyr_sort_wanted.value=2
g.tbl.PID_OSD.plyr_sort_tis.on=true
g.tbl.PID_OSD.plyr_sort_speed_type.value=0
g.tbl.PID_OSD.plyr_sort_speed_above.value=0
g.tbl.PID_OSD.plyr_sort_speed_veh.on=true
g.tbl.PID_OSD.plyr_sort_speed_ped.on=true
g.tbl.PID_OSD.plyr_sort_interior.on=true
g.tbl.PID_OSD.plyr_list_feat.on=true
end
funcs.doo.PID_OSD_recc_sett()

g.print_load_info("Player Overlay",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Leaderboard"

g._ldrbrd = {}
g._ldrbrd.ped_veh_id={-1,-1}
g._ldrbrd.plyr_dead={}
g._ldrbrd.plyr_score={}
g._ldrbrd.plyr_name={}
g._ldrbrd.feat_name_str={}
g._ldrbrd.last_killer=-1
g._ldrbrd.last_death=-1

function g._ldrbrd.default_all_tables()
	for i=1,32 do
		g._ldrbrd.plyr_score[i]={}
		for pid=1,32 do
			g._ldrbrd.plyr_score[i][pid]={0,0,""}
		end
		g._ldrbrd.ped_veh_id[i]={-1,-1}
		g._ldrbrd.plyr_dead[i]=false
		g._ldrbrd.plyr_name[i]=""
		if API.plyr.is.valid(i-1) then
			g._ldrbrd.feat_name_str[i]=funcs.get.pid_name(i-1)
		else
			g._ldrbrd.feat_name_str[i]=""
		end
	end
end
g._ldrbrd.default_all_tables()

function g._ldrbrd.sort(score_table)
	if g._ldrbrd.sort_drctn.value == 0 and g._ldrbrd.sort_by.value ~= 4 then
		if g._ldrbrd.sort_by.value == 0 then
			table.sort(score_table, function(a, b) return a[3]:lower() < b[3]:lower()  end)
		elseif g._ldrbrd.sort_by.value == 1 then
			table.sort(score_table, function(a, b)
			if a[1] == b[1] then
				return a[3]:lower() < b[3]:lower()
			end
			return a[1] < b[1] end)
		elseif g._ldrbrd.sort_by.value == 2 then
			table.sort(score_table, function(a, b)
			if a[2] == b[2] then
				return a[3]:lower() < b[3]:lower()
			end
			return a[2] < b[2] end)
		else
			table.sort(score_table, function(a, b) return a[7] < b[7]  end)
		end
	elseif g._ldrbrd.sort_drctn.value == 1 then
		if g._ldrbrd.sort_by.value == 0 then
			table.sort(score_table, function(a, b) return a[3]:lower() > b[3]:lower()  end)
		elseif g._ldrbrd.sort_by.value == 1 then
			table.sort(score_table, function(a, b)
			if a[1] == b[1] then
				return a[3]:lower() > b[3]:lower()
			end
			return a[1] > b[1]  end)
		elseif g._ldrbrd.sort_by.value == 2 then
			table.sort(score_table, function(a, b)
			if a[2] == b[2] then
				return a[3]:lower() > b[3]:lower()
			end
			return a[2] > b[2]  end)
		elseif g._ldrbrd.sort_by.value == 3 then
			table.sort(score_table, function(a, b) return a[7] > b[7]  end)
		else
			table.sort(score_table, function(a, b) return a[8] > b[8]  end)
		end
	end
end

g._ldrbrd.record_ped_veh_id = og_menu_add_feature("HIDDEN record plyr ped veh id death", "toggle", g.prnt.utils_info_ldrbrd.id, function(f)
	local function record_death(_pidT,_ped_id)
		if API.plyr.count() > 0 then -- suicide in SP returns nil i guess
			local murderer = ntv.get.what_ent_killed_ped(_ped_id)
			for i=1,32 do
				if g._ldrbrd.ped_veh_id[i][1] == murderer or g._ldrbrd.ped_veh_id[i][2] == murderer then
					g._ldrbrd.plyr_score[_pidT][i][2]=g._ldrbrd.plyr_score[_pidT][i][2]+1
					g._ldrbrd.plyr_score[i][_pidT][1]=g._ldrbrd.plyr_score[i][_pidT][1]+1
					g._ldrbrd.last_killer=i
					g._ldrbrd.last_death=_pidT
					return true
				end
			end
		end
		return false
	end
	local plyr_leave = event.add_event_listener("player_leave", function(listener)
		if listener.player == API.plyr.my_id() then
			g._ldrbrd.default_all_tables()
		end
	end)
	while f.on do
		for i=1,32 do
			if funcs.is.valid_pid(i-1) then
				g._ldrbrd.ped_veh_id[i][1]=API.plyr.get.ped(i-1)
				g._ldrbrd.plyr_name[i]=funcs.get.pid_name(i-1)
				g._ldrbrd.feat_name_str[i]=funcs.get.pid_name(i-1)
				for pid=1,32 do
					g._ldrbrd.plyr_score[pid][i][3]=funcs.get.pid_name(i-1)
				end
				if API.plyr.is.in_veh(i-1) then
					g._ldrbrd.ped_veh_id[i][2]=API.plyr.get.veh(i-1)
				else
					g._ldrbrd.ped_veh_id[i][2]=-1
				end
			else
				if g._ldrbrd.last_killer == i then
					g._ldrbrd.last_killer=-1
				end
				if g._ldrbrd.last_death == i then
					g._ldrbrd.last_death=-1
				end
				g._ldrbrd.ped_veh_id[i]={-1,-1}
				g._ldrbrd.plyr_dead[i]=false
				g._ldrbrd.plyr_name[i]=""
				g._ldrbrd.feat_name_str[i]=""
				for pid=1,32 do
					g._ldrbrd.plyr_score[i][pid]={0,0,""}
					g._ldrbrd.plyr_score[pid][i]={0,0,""}
				end
			end
		end
		g._ldrbrd.feat:set_str_data(g._ldrbrd.feat_name_str)
		for i=1,32 do
			if funcs.is.valid_pid(i-1) then
				if funcs.is.dead(API.plyr.get.ped(i-1)) then
					if g._ldrbrd.plyr_dead[i] == false then
						if record_death(i,API.plyr.get.ped(i-1)) then
							g._ldrbrd.plyr_dead[i]=true
						end
					end
				elseif API.plyr.is.playing(i-1) then
					g._ldrbrd.plyr_dead[i] = false
				end
			end
		end
		YIELD(250)
	end
end)
g._ldrbrd.record_ped_veh_id.on=true
g._ldrbrd.record_ped_veh_id.hidden=true

g._ldrbrd.feat = menu_add_feature("Show Leaderboard","value_str",g.prnt.utils_info_ldrbrd.id, function(f)
	local score_table,_table,count,name,v2_pos,text_pos
	local _r,_g,_b,size,back_a,text_a,pid,my_r,my_g,my_b,screen_s
	local f_value=f.value
	local y_val,y_ofst = 0.013,0
	local x_pos,y_pos = 0.5,0.5
	local function show_last()
		if not g._ldrbrd.show_last.on then
			return false
		elseif g._ldrbrd.show_last.value == 0 and not funcs.is.valid_pid(g._ldrbrd.last_killer-1) then
			return false
		elseif g._ldrbrd.show_last.value == 1 and not funcs.is.valid_pid(g._ldrbrd.last_death-1) then
			return false
		else
			local I_name
			if g._ldrbrd.show_last.value == 0 then I_name=funcs.get.pid_name(g._ldrbrd.last_killer-1) else I_name=funcs.get.pid_name(g._ldrbrd.last_death-1) end
			for i=1,32 do
				if g._ldrbrd.feat_name_str[i] == I_name then
					name = I_name
					my_r,my_g,my_b = g.tbl.PID_OSD.plyr_rgb(i,nil)
					_table=g._ldrbrd.plyr_score[i]
					f.value=i-1
					return true
				end
			end
		end
		return false
	end
	local function retrieve_info()
		_table = {}
		if not show_last() then
			for i=1,32 do
				if g._ldrbrd.plyr_name[i] == g._ldrbrd.feat_name_str[f.value+1] then
					name = funcs.get.pid_name(i-1)
					my_r,my_g,my_b = g.tbl.PID_OSD.plyr_rgb(i,nil)
					_table=g._ldrbrd.plyr_score[i]
					break
				end
			end
		end
		count = 1
		score_table={}
		for i=1,32 do
			if _table[i] and ((_table[i][1] ~= nil and _table[i][1] > 0) or (_table[i][2] ~= nil and _table[i][2] > 0))  then
				if _table[i][3] == name then
					name=name.." - ".._table[i][1].." Suicide"
				else
					count=count+1
					score_table[#score_table+1]={
					_table[i][1],
					_table[i][2],
					_table[i][3],
					g.tbl.PID_OSD.plyr_rgb(i,"r"),
					g.tbl.PID_OSD.plyr_rgb(i,"g"),
					g.tbl.PID_OSD.plyr_rgb(i,"b"),
					g.tbl.PID_OSD.dist_table[i][1],
					i-1}
				end
			end
		end
	end
	local function check_plyr_name()
		local down=false
		if f_value~=f.value then
			if f.value==f_value-1 or f_value-1==-1 then
				down=true
			end
		end
		repeat
			if g._ldrbrd.feat_name_str[f.value+1] == "" then
				if down then
					if f.value == 0 then
						f.value=31
					else
						f.value=f.value-1
					end
				else
					if f.value == 31 then
						f.value=0
					else
						f.value=f.value+1
					end
				end
			end
		until g._ldrbrd.feat_name_str[f.value+1] ~= ""
		f_value=f.value
	end
	while not g.var.GS_has_loaded do
		YIELD(50)
	end
	local script_size = funcs.get.SD_size(f.on)
	while f.on do
		YIELD(5)
		check_plyr_name()
		retrieve_info()
		g._ldrbrd.sort(score_table)
		x_pos = g._ldrbrd.x.value
		y_pos = g._ldrbrd.y.value
		back_a = g._ldrbrd.back_a.value
		text_a = g._ldrbrd.text_a.value
		size = g._ldrbrd.size.value
		y_val = 0.04*size
		v2_pos = v2(x_pos,y_pos-y_val*count*.5)
		API.SD.draw_rect(v2_pos,funcs.vec(0.169*size,0.040*size*count),funcs.get.rgba_to_int(0,0,0,back_a))
		API.SD.draw_rect(funcs.vec(x_pos,y_pos-(y_val*.5)),funcs.vec(0.169*size,0.040*size),funcs.get.rgba_to_int(0,0,0,back_a))
		text_pos = v2(v2_pos.x*(2/3),(y_pos-(y_val*.5))*2)
		text_size = size*1.069*script_size*g.RES
		API.SD.draw_text(name,text_pos,text_pos,text_size,funcs.get.rgba_to_int(my_r,my_g,my_b,text_a),((1<<0)+(1<<1)+(1<<2)),nil)
		for i = 1,#score_table do
			text_pos=text_pos-v2(0,y_val*2)
			_r,_g,_b = score_table[i][4],score_table[i][5],score_table[i][6]
			API.SD.draw_text(score_table[i][1],text_pos-funcs.vec(size*0.0725,0),text_pos,text_size,funcs.get.rgba_to_int(my_r,my_g,my_b,text_a),((1<<0)+(1<<1)+(1<<2)),nil)
			API.SD.draw_text("-",text_pos-funcs.vec(size*0.06,0),text_pos,text_size,funcs.get.rgba_to_int(255,255,255,text_a),((1<<0)+(1<<1)+(1<<2)),nil)
			API.SD.draw_text(score_table[i][2],text_pos-funcs.vec(size*0.0475,0)	,text_pos,text_size,funcs.get.rgba_to_int(_r,_g,_b,text_a),((1<<0)+(1<<1)+(1<<2)),nil)
			API.SD.draw_text(score_table[i][3],funcs.vec(x_pos,text_pos.y)-funcs.vec(size*0.0325,0),funcs.vec(x_pos,text_pos.y),text_size,funcs.get.rgba_to_int(_r,_g,_b,text_a),((1<<1)+(1<<2)),nil)
		end
	end
end)
g._ldrbrd.feat:set_str_data(g._ldrbrd.feat_name_str)
funcs.add_to_S_L(g._ldrbrd.feat,"g._ldrbrd.feat")

g._ldrbrd.show_last = menu_add_feature("Always show last player who:","value_str",g.prnt.utils_info_ldrbrd.id)
new_set_str_data(g._ldrbrd.show_last,{"Killed","Was killed"})
funcs.add_to_S_L(g._ldrbrd.show_last,"g._ldrbrd.show_last")

g._ldrbrd.sort_by = menu_add_feature("Sort scores","action_value_str",g.prnt.utils_info_ldrbrd.id)
new_set_str_data(g._ldrbrd.sort_by,{"Name","Kills","Deaths","Distance","PID"})
funcs.add_to_S_L(g._ldrbrd.sort_by,"g._ldrbrd.sort_by")

g._ldrbrd.sort_drctn = menu_add_feature("Sort type","action_value_str",g.prnt.utils_info_ldrbrd.id)
new_set_str_data(g._ldrbrd.sort_drctn,{"Ascending","Descending"})
funcs.add_to_S_L(g._ldrbrd.sort_drctn,"g._ldrbrd.sort_drctn")

g._ldrbrd.size = menu_add_feature("Size","action_value_f",g.prnt.utils_info_ldrbrd.id)
funcs.set_feat_i_f(g._ldrbrd.size,0.1,3,0.01,1,"g._ldrbrd.size")

g._ldrbrd.x = menu_add_feature("X Pos","action_value_f",g.prnt.utils_info_ldrbrd.id)
funcs.set_feat_i_f(g._ldrbrd.x,-1.0,1.0,0.01,0.89,"g._ldrbrd.x")

g._ldrbrd.y = menu_add_feature("Y Pos","action_value_f",g.prnt.utils_info_ldrbrd.id)
funcs.set_feat_i_f(g._ldrbrd.y,-1.0,1.0,0.01,0.44,"g._ldrbrd.y")

g._ldrbrd.back_a = menu_add_feature("Background alpha","action_value_i",g.prnt.utils_info_ldrbrd.id)
funcs.set_feat_i_f(g._ldrbrd.back_a,1,255,1,100,"g._ldrbrd.back_a")

g._ldrbrd.text_a = menu_add_feature("Text alpha","action_value_i",g.prnt.utils_info_ldrbrd.id)
funcs.set_feat_i_f(g._ldrbrd.text_a,1,255,1,255,"g._ldrbrd.text_a")

function g._ldrbrd.get_highest(_1_or_2,_text)
	local temp,score,name_k,name_d=0,{},{},{}
	for i=1,32 do
		for pid=1,32 do
			if g._ldrbrd.plyr_score[i][pid][_1_or_2] > temp and g._ldrbrd.plyr_name[i] ~= "" and g._ldrbrd.plyr_name[pid] ~= "" then
				temp=g._ldrbrd.plyr_score[i][pid][_1_or_2]
			end
		end
	end
	for i=1,32 do
		for pid=1,32 do
			if g._ldrbrd.plyr_score[i][pid][_1_or_2] >= temp and g._ldrbrd.plyr_name[i] ~= "" and g._ldrbrd.plyr_name[pid] ~= "" then
				score[#score+1]={g._ldrbrd.plyr_score[i][pid][1],g._ldrbrd.plyr_score[i][pid][2],g._ldrbrd.plyr_name[i],g._ldrbrd.plyr_name[pid]}
			end
		end
	end
	if temp>0 then
		local msg =""
		for i=1,#score do
			if score[i][3] == score[i][4] then
				msg=msg..score[i][3].." "..score[i][1].." suicide(s)\n"
			else
				msg=msg..score[i][3].." "..score[i][1].." - "..score[i][2].." "..score[i][4].."\n"
			end
		end
		g.N_P(2,msg,__GV__,5,"Blue")
	else
		g.N_P(2,"No recorded ".._text,__GV__,5,"Blue")
	end
end

g._ldrbrd.highest_kill = menu_add_feature("Who has the most kills?","action",g.prnt.utils_info_ldrbrd.id,function()
	g._ldrbrd.get_highest(1,"kills")
end)

g._ldrbrd.highest_death = menu_add_feature("Who has the most deaths?","action",g.prnt.utils_info_ldrbrd.id,function()
	g._ldrbrd.get_highest(2,"deaths")
end)

------------------------------------------------------------------------------------------------------------------------------------
g._LOS_={}
g._LOS_._table={}

function g._LOS_.default(i)
	g._LOS_._table[i]={false,"",0,0,0,0,""}
end
for i=1,32 do
	g._LOS_.default(i)
end

function g._LOS_.sort(_table)
	if g._LOS_.sort_drctn.value == 0 then
		if g._LOS_.sort_by.value == 0 then
			table.sort(_table, function(a, b) return a[6] < b[6]  end)
		else
			table.sort(_table, function(a, b) return a[2]:lower() < b[2]:lower()  end)
		end
	else
		if g._LOS_.sort_by.value == 0 then
			table.sort(_table, function(a, b) return a[6] > b[6]  end)
		else
			table.sort(_table, function(a, b) return a[2]:lower() > b[2]:lower()  end)
		end
	end
end

function g._LOS_.get_dist(_dist)
	if g._LOS_.dist_type.value == 0 then
		return funcs.get.dist_to_str(_dist,"m")
	end
	return funcs.get.dist_to_str(_dist,"ft")
end

function g._LOS_.show_it(_table,script_size)
	local x_pos,y_pos,size = g._LOS_.x.value,g._LOS_.y.value,g._LOS_.size.value
	local back_a = funcs.get.rgba_to_int(0,0,0,g._LOS_.back_a.value)
	local y_val = 0.04*size
	local v2_pos = v2(x_pos,y_pos-y_val*(#_table+1)*.5)
	local text_size = size*1.069*script_size*g.RES
	API.SD.draw_rect(v2_pos,funcs.vec(0.24*size,0.040*size*(#_table+1)),back_a)
	API.SD.draw_rect(funcs.vec(x_pos,y_pos-(y_val*.5)),funcs.vec(0.24*size,0.040*size),back_a)
	local text_pos = v2(v2_pos.x*(2/3),(y_pos-(y_val*.5))*2)
	local my_r,my_g,my_b = g.tbl.PID_OSD.plyr_rgb(API.plyr.my_id()+1,nil)
	API.SD.draw_text(funcs.get.pid_name(API.plyr.my_id()),text_pos,text_pos,text_size,funcs.get.rgba_to_int(my_r,my_g,my_b,g._LOS_.text_a.value),((1<<0)+(1<<1)+(1<<2)),nil)
	for i = 1,#_table do
		text_pos=text_pos-funcs.vec(0,y_val*2)
		local text_rgba = funcs.get.rgba_to_int(_table[i][3],_table[i][4],_table[i][5],g._LOS_.text_a.value)
		API.SD.draw_text(g._LOS_.get_dist(_table[i][6]) ,text_pos-funcs.vec(size*0.08,0),text_pos,text_size,funcs.get.rgba_to_int(255,255,255,g._LOS_.text_a.value),((1<<0)+(1<<1)+(1<<2)),nil)
		API.SD.draw_text(_table[i][2].." - ".._table[i][7],funcs.vec(x_pos,text_pos.y)-funcs.vec(size*0.0425,0),funcs.vec(x_pos,text_pos.y),text_size,text_rgba,((1<<1)+(1<<2)),nil)
	end
end

g._LOS_.record = og_menu_add_feature("HIDDEN record LOS players", "toggle", g.prnt.utils_info_los.id, function(f)
	while f.on do
		for i=1,32 do
			if funcs.is.valid_pid(i-1) and i-1 ~= API.plyr.my_id() then
				if ntv.is.ent_in_los_front(API.plyr.get.ped(i-1),API.plyr.get.ped(API.plyr.my_id())) then
					g._LOS_._table[i]={
					true,
					funcs.get.pid_name(i-1),
					g.tbl.PID_OSD.plyr_rgb(i,"r"),
					g.tbl.PID_OSD.plyr_rgb(i,"g"),
					g.tbl.PID_OSD.plyr_rgb(i,"b"),
					g.tbl.PID_OSD.dist_table[i][1],
					g.tbl.aim_protex_main.get_weap_name(i-1)
					}
				else
					g._LOS_.default(i)
				end
				YIELD(25)
			end
		end
		f.on=g._LOS_.feat.on
		YIELD(25)
	end
end)g._LOS_.record.hidden=true

g._LOS_.feat = menu_add_feature("Show list","toggle",g.prnt.utils_info_los.id, function(f)
	local _table
	local script_size = funcs.get.SD_size(f.on)
	while f.on do
		YIELD(5)
		g._LOS_.record.on=f.on
		_table={}
		for i=1, 32 do
			if g._LOS_._table[i][1] then
				_table[#_table+1]=g._LOS_._table[i]
			end
		end
		g._LOS_.sort(_table)
		g._LOS_.show_it(_table,script_size)
	end
end)
funcs.add_to_S_L(g._LOS_.feat,"g._LOS_.feat")

g._LOS_.test = menu_add_feature("Display test","action",g.prnt.utils_info_los.id, function(f)
	local _table,time={},TIME_MS()+10000
	local script_size = funcs.get.SD_size(true)
	for i=1,9 do
		_table[i]={
		true,
		"Player "..i,
		mth.rndm(50,255),
		mth.rndm(50,255),
		mth.rndm(50,255),
		mth.rndm(50,5000)*.1,
		(API.wpn.get_name(weap_info.all_hash[mth.rndm(1,#weap_info.all_hash)]) or "Weapon")
		}
	end
	while time > TIME_MS() do
		YIELD(5)
		f.name="Display test "..funcs.get._1_dec((time-TIME_MS())/1000)
		g._LOS_.sort(_table)
		g._LOS_.show_it(_table,script_size)
	end
	f.name="Display test"
end)


g._LOS_.sort_by = menu_add_feature("Sort players","action_value_str",g.prnt.utils_info_los.id)
new_set_str_data(g._LOS_.sort_by,{"Distance","Name"})
funcs.add_to_S_L(g._LOS_.sort_by,"g._LOS_.sort_by")

g._LOS_.sort_drctn = menu_add_feature("Sort type","action_value_str",g.prnt.utils_info_los.id)
new_set_str_data(g._LOS_.sort_drctn,{"Ascending","Descending"})
funcs.add_to_S_L(g._LOS_.sort_drctn,"g._LOS_.sort_drctn")

g._LOS_.dist_type = menu_add_feature("Distance type","action_value_str",g.prnt.utils_info_los.id)
new_set_str_data(g._LOS_.dist_type,{"Meters","Feet"})
funcs.add_to_S_L(g._LOS_.dist_type,"g._LOS_.dist_type")

g._LOS_.size = menu_add_feature("Size","action_value_f",g.prnt.utils_info_los.id)
funcs.set_feat_i_f(g._LOS_.size,0.1,3,0.01,1,"g._LOS_.size")

g._LOS_.x = menu_add_feature("X Pos","action_value_f",g.prnt.utils_info_los.id)
funcs.set_feat_i_f(g._LOS_.x,-1,1,0.01,0.69,"g._LOS_.x")

g._LOS_.y = menu_add_feature("Y Pos","action_value_f",g.prnt.utils_info_los.id)
funcs.set_feat_i_f(g._LOS_.y,-1,1,0.01,0.44,"g._LOS_.y")

g._LOS_.back_a = menu_add_feature("Background alpha","action_value_i",g.prnt.utils_info_los.id)
funcs.set_feat_i_f(g._LOS_.back_a,1,255,1,100,"g._LOS_.back_a")

g._LOS_.text_a = menu_add_feature("Text alpha","action_value_i",g.prnt.utils_info_los.id)
funcs.set_feat_i_f(g._LOS_.text_a,1,255,1,255,"g._LOS_.text_a")

g.print_load_info("Leaderboard",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Remote Ped"

g.tbl.remote_ped = {}

g.tbl.remote_ped.directory=g.paths._user.."Remote Ped Defaults\\"
function g.tbl.remote_ped.info_write(_file,_text)
	local file = io.open(g.tbl.remote_ped.directory.._file..".txt", "w")
	file:write(_text)
	file:close()
end

function g.tbl.remote_ped.info_get(_file)
	local file = io.open(g.tbl.remote_ped.directory.._file..".txt", "r")
	local text = nil
	for line in file:lines() do
		if line ~= nil then
			text = tonumber(line)
			break
		end
	end
	file:close()
	return text
end

function g.tbl.remote_ped.info_check(_file,_default)
	funcs.doo.check_create_dir(g.paths._user)
	funcs.doo.check_create_dir(g.tbl.remote_ped.directory)
	if not utils.file_exists(g.tbl.remote_ped.directory.._file..".txt") then
		g.tbl.remote_ped.info_write(_file,_default)
	end
	local text = g.tbl.remote_ped.info_get(_file)
	if text == nil then
		g.tbl.remote_ped.info_write(_file,_default)
	end
end



g.tbl.remote_ped.info_check("Default Ped Model Hash",API.get_hash_key("a_f_m_fatcult_01"))
g.tbl.remote_ped.ped_hash = g.tbl.remote_ped.info_get("Default Ped Model Hash")
if not API.strm.is.valid_ped(g.tbl.remote_ped.ped_hash) then
	g.tbl.remote_ped.ped_hash=API.get_hash_key("a_f_m_fatcult_01")
end
g.tbl.remote_ped.info_check("Default Ped Weapon Hash",API.get_hash_key("weapon_gusenberg"))
g.tbl.remote_ped.weap_hash = g.tbl.remote_ped.info_get("Default Ped Weapon Hash")
if not funcs.is.table_has(weap_info.all_hash,g.tbl.remote_ped.weap_hash) then
	g.tbl.remote_ped.weap_hash=API.get_hash_key("weapon_gusenberg")
end


g.tbl.R_P={}

g.tbl.R_P.ped=nil
g.tbl.R_P.pos=nil
g.tbl.R_P.veh_control={}
g.tbl.remote_ped.prnt=menu_add_feature("Remote ped","parent",g.prnt.utils.id)
g.tbl.remote_ped.feat=menu_add_feature("Remote ped","toggle",g.tbl.remote_ped.prnt.id,function(f)
	local all_peds,ped_speed,move,aim_or_shoot,shoot,hit,ray_pos,aim_pos,dir,ray_start,_bool,screen_pos,plyr_pid,good_ped,good_pid,in_veh,drive_style
	local pos,time,blip,hopeful_veh,seat,action,enter_type,ped_veh,ped_seat,ped_pos,ped_head,speed,time2,should_hijack,brake_once,shuffle_once=nil
	local otr = menu.get_feature_by_hierarchy_key("online.services.off_the_radar").on
	local shoot_time = TIME_MS()
	local v_Left,v_Right,v_Accel,v_Brake,v_Enter,v_Exit,v_HandBrake=63,64,71,72,23,75,76
	local found, ammo
	local function remove_ped(_ped)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local PED = g.tbl.R_P.ped
			funcs.doo.remove_ent(PED,1000)
		end)
		if ntv.is.blip_exist(blip) then
			ui.remove_blip(blip)
		end
	end
	local function make_ped()
		funcs.doo.req_model(g.tbl.remote_ped.ped_hash)
		if in_veh and funcs.is.veh(ped_veh) then
			g.tbl.R_P.ped=ntv.doo.create_ped_in_veh(ped_veh,6,g.tbl.remote_ped.ped_hash,ped_seat,1,0)
		elseif ped_pos then
			g.tbl.R_P.ped=API.Ped.create(6, g.tbl.remote_ped.ped_hash,ped_pos, (ped_head or mth.rndm(0,359)), true, false)
		else
			g.tbl.R_P.ped=API.Ped.create(6, g.tbl.remote_ped.ped_hash,funcs.get.pos_nearby2(API.plyr.get.coords(plyr_pid),10,false), mth.rndm(0,359), true, false)
		end
		YIELD(0)
		if funcs.is.ent(g.tbl.R_P.ped) then
			funcs.doo.id_migrate(g.tbl.R_P.ped,0)
			funcs.doo.ped_ragdoll(g.tbl.R_P.ped,false,50)
			funcs.doo.set_ped_health(g.tbl.R_P.ped,2500,50)
			g.tbl.entities[#g.tbl.entities+1]=g.tbl.R_P.ped
			blip = ui.add_blip_for_entity(g.tbl.R_P.ped)
			ntv.set.blip_sprite(blip,6)
			ntv.set.blip_scale(blip,0.5)
		end
	end
	local function do_each_frame()
		if funcs.is.ent(g.tbl.R_P.ped) and (API.ent.get.model_hash(g.tbl.R_P.ped) ~= g.tbl.remote_ped.ped_hash or API.ent.is.dead(g.tbl.R_P.ped)) then
			API.Ped.clear_tasks(g.tbl.R_P.ped)
			remove_ped()
			YIELD(0)
			make_ped()
		end
		good_ped=funcs.is.ent(g.tbl.R_P.ped)
		if good_ped then
			API.ent.set.god(g.tbl.R_P.ped,g.tbl.remote_ped.ped_god.on)
			ped_pos=API.ent.get.coords(g.tbl.R_P.ped)
			ped_head=API.ent.get.heading(g.tbl.R_P.ped)
			ntv.cam.set.on_ped(g.tbl.R_P.ped)
			ntv.cam.set.focus_pos(ped_pos)
			ntv.map.lock_mini_pos(ped_pos)
			API.ent.set.coords(funcs.ME._ped(),funcs.vec(g.tbl.R_P.pos.x,g.tbl.R_P.pos.y,-50))
			good_pid=(funcs.is.valid_pid(plyr_pid))
			in_veh=(API.Ped.is.in_veh(g.tbl.R_P.ped))
			driving = (in_veh and funcs.is.ped_in_seat(g.tbl.R_P.ped,API.Ped.get.veh(g.tbl.R_P.ped),-1))
			if driving then
				API.ent.set.god(API.Ped.get.veh(g.tbl.R_P.ped),g.tbl.remote_ped.veh_god.on)
			end
			if (API.Ped.is.ragdoll(g.tbl.R_P.ped) or ai.is_task_active(g.tbl.R_P.ped, 18) or ai.is_task_active(g.tbl.R_P.ped, 408)) and not ai.is_task_active(g.tbl.R_P.ped, 396) then --CTaskNMHighFall = 396, ["CTaskFallOver = 18,"] ["CTaskNMControl = 408,"]
				API.Ped.clear_tasks(g.tbl.R_P.ped)
			end
		end
	end
	local function yield_do(_time,_action)
		local time = TIME_MS()+_time
		local time2 = nil
		while time > TIME_MS() and f.on and good_ped and good_pid do
			if _action == "hijack" then
				if not funcs.is.key_active(v_Enter,1) then
					return false
				end
			elseif _action == "in_veh" then
				if not API.Ped.is.in_veh(g.tbl.R_P.ped) then
					return  false
				end
			elseif _action == "not_in_veh" then
				if API.Ped.is.in_veh(g.tbl.R_P.ped) then
					return  false
				end
			elseif _action == "in_air" then
				if not API.ent.is.in_air(g.tbl.R_P.ped) then
					return false
				end
			elseif _action == "not_in_air" then
				if API.ent.is.in_air(g.tbl.R_P.ped) then
					return false
				end
			elseif _action == "jump" then
				if not funcs.is.key_active(22,1) then
					return false
				end
			elseif _action == "jump_wait" then
				if not ai.is_task_active(g.tbl.R_P.ped, 422) and not  ai.is_task_active(g.tbl.R_P.ped, 421) then
					return false
				elseif not API.ent.is.in_air(g.tbl.R_P.ped) then
					if time2 == nil then
						time2 = TIME_MS() + 200
						time=time+200
					elseif time2 < TIME_MS() then
						API.Ped.clear_tasks(g.tbl.R_P.ped)
					end
				end
			elseif _action == "climb" then --["CTaskJumpVault = 421,"], ["CTaskVault = 50,"], ["CTaskClimbLadder = 1,"], ["CTaskUseClimbOnRoute = 41,"], ["CTaskGoToAndClimbLadder = 47,"],
				if ai.is_task_active(g.tbl.R_P.ped, 421) or ai.is_task_active(g.tbl.R_P.ped, 50) or
					ai.is_task_active(g.tbl.R_P.ped, 2) or ai.is_task_active(g.tbl.R_P.ped, 41) or
					ai.is_task_active(g.tbl.R_P.ped, 47) or ai.is_task_active(g.tbl.R_P.ped, 1) then
					return false
				end
			end
			YIELD(0)
			do_each_frame()
		end
		return true
	end
	function ped_is_aiming_or_shooting()
		if not API.wpn.ped_has(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash) then
			API.wpn.ped_give(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash, 100, true)
			funcs.doo.weap_upgr(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash)
			found, ammo = API.wpn.get_max_ammo(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash)
			if found then
				API.wpn.ped_set_ammo(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash,ammo)
			end
		end
		ray_start = funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),funcs.get.dist_pospos_v2(API.ent.get.coords(g.tbl.R_P.ped),API.cam.get.pos())+0.5)
		ray_start = ((in_veh and (ray_start + funcs.vec(0,0,1))) or ray_start)
		hit, ray_pos = funcs.get.ray_vctr_all(nil,false,ray_start,nil)
		if weapon.get_weapon_weapon_wheel_slot(g.tbl.remote_ped.weap_hash) == 7 then
			if hit then
				if funcs.get.dist_pospos_v3(ray_start,ray_pos) > 22 then
					aim_pos = funcs.get.front_of_dir(ray_start,API.cam.get.rot(),22)
				else
					aim_pos = ray_pos
				end
			else
				aim_pos = funcs.get.front_of_dir(ray_start,API.cam.get.rot(),22)
			end
		elseif hit then
			aim_pos = ray_pos
		else
			aim_pos = funcs.get.front_of_dir(ray_start,API.cam.get.rot(),1000)
		end
		screen_pos = funcs.get.screen_pos_3d(aim_pos)
		if screen_pos then
			API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.remote_ped.reticle.slct.value],screen_pos,1*g.tbl.remote_ped.reticle.mrkr_s.value*g.RES,0, funcs.get.rgba_to_int(g.tbl.remote_ped.reticle.mrkr_r.value,g.tbl.remote_ped.reticle.mrkr_g.value,g.tbl.remote_ped.reticle.mrkr_b.value,g.tbl.remote_ped.reticle.mrkr_a.value))
		end
	end
	-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function() --just testing
		-- while g.tbl.remote_ped.feat.on do
			-- if funcs.is.ent(g.tbl.R_P.ped) then
				-- for k,v in pairs(list) do
					-- if ai.is_task_active(g.tbl.R_P.ped, v) then
						-- menu.notify(k)
					-- end
				-- end
				-- if ped.is_ped_ragdoll(g.tbl.R_P.ped) then
					-- menu.notify("RAGDOLL")
				-- end
			-- end
			-- YIELD(100)
		-- end

	-- end)
	local function release_veh(_bool,_veh) -- might not be necessary
		if _bool and funcs.is.ent(_veh) and g.tbl.R_P.veh_control[_veh]=="mine" then
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local time=TIME_MS()+5000
				local VEH = _veh
				while time > TIME_MS() and funcs.is.ent(VEH) and not funcs.is.ped_in_seat(g.tbl.R_P.ped,VEH,-1) do
					if funcs.ntwrk.ask_quick(VEH) then
						funcs.doo.id_migrate(VEH,1)
						time=TIME_MS()
					end
				end
				g.tbl.R_P.veh_control[VEH]="released"
			end)

		end
	end
	local function get_input()
		if API.Ped.is.in_veh(g.tbl.R_P.ped) then
			in_veh=true
			ped_veh=API.Ped.get.veh(g.tbl.R_P.ped)
			ped_seat=funcs.get.what_seat_ped_in(ped_veh,g.tbl.R_P.ped)
			if not ai.is_task_active(g.tbl.R_P.ped, 2) then --CTaskExitVehicle =2
				if funcs.is.key_active(v_Exit,1) then
					if API.ent.get.speed(ped_veh) > 5 then
						ai.task_leave_vehicle(g.tbl.R_P.ped, ped_veh, 4160)
					else
						ai.task_leave_vehicle(g.tbl.R_P.ped, ped_veh, 0)
					end
					yield_do(500,"in_veh")
				elseif driving then
					dir=nil
					if g.tbl.R_P.veh_control[ped_veh]~="mine" then
						if funcs.ntwrk.ask_quick(ped_veh) then
							funcs.doo.id_migrate(ped_veh,0)
							g.tbl.R_P.veh_control[ped_veh]="mine"
						end
					elseif funcs.is.key_active(v_Accel,1) then
						dir=9
						if funcs.is.key_active(v_Brake,1) then
							dir=30
							if funcs.is.key_active(v_Left,1) then
								dir=4
							elseif funcs.is.key_active(v_Right,1) then
								dir=5
							end
						elseif funcs.is.key_active(v_Left,1) then
							dir=7
							if funcs.is.key_active(v_HandBrake,1) then
								dir=25
							end
						elseif funcs.is.key_active(v_Right,1) then
							dir=8
							if funcs.is.key_active(v_HandBrake,1) then
								dir=26
							end
						elseif funcs.is.key_active(v_HandBrake,1) then
							dir=31
						end
					elseif funcs.is.key_active(v_Brake,1) then
						dir=22
						if funcs.is.key_active(v_Left,1) then
							dir=13
						elseif funcs.is.key_active(v_Right,1) then
							dir=14
						end
					elseif funcs.is.key_active(v_Left,1) then
						dir=11
					elseif funcs.is.key_active(v_Right,1) then
						dir=10
					end
				else
					release_veh(true,ped_veh)
				end
			else
				dir=nil
			end
		else
			in_veh=false
			dir = 0
			if not ai.is_task_active(g.tbl.R_P.ped, 160) then --CTaskEnterVehicle
				hopeful_veh=nil
				if funcs.is.key_active(v_Enter,1) then
					enter_type="free"
					should_hijack=yield_do(500,"hijack")
					if should_hijack then
						enter_type="steal"
					end
					hopeful_veh,seat,action = funcs.get.closest_veh_seat(API.ent.get.coords(g.tbl.R_P.ped),15,enter_type)
					if hopeful_veh then
						ai.task_enter_vehicle(g.tbl.R_P.ped, hopeful_veh, -1, seat, 2.0, action, 0)
						yield_do(500,"not_in_veh")
					end
				end
				if hopeful_veh == nil then
					if funcs.is.key_active(32,1) or funcs.is.key_active(33,1) or funcs.is.key_active(34,1) or funcs.is.key_active(35,1) then
						ped_speed = 1.0
						move = 0
					else
						ped_speed = 0.0
						move = 1
					end
					if move == 0 then
						if funcs.is.key_active(209,1) then
							ped_speed = 2.0
						end
						if funcs.is.key_active(32,1) then -- W
							if (not funcs.is.key_active(34,1) and not funcs.is.key_active(35,1)) or (funcs.is.key_active(34,1) and funcs.is.key_active(35,1)) then
								dir=0
							elseif funcs.is.key_active(34,1) then -- A
								dir=45
							elseif funcs.is.key_active(35,1) then -- D
								dir=-45
							end
						elseif funcs.is.key_active(33,1) then-- S
							if (not funcs.is.key_active(34,1) and not funcs.is.key_active(35,1)) or (funcs.is.key_active(34,1) and funcs.is.key_active(35,1)) then
								dir=-180
							elseif funcs.is.key_active(34,1) then -- A
								dir=135
							elseif funcs.is.key_active(35,1) then -- D
								dir=-135
							end
						elseif funcs.is.key_active(34,1) then -- A
							dir=90
						elseif funcs.is.key_active(35,1) then -- D
							dir=-90
						end
					end
				end
			end
		end
		aim_or_shoot = (funcs.is.key_active(25,1.0) or funcs.is.key_active(24,1.0))
		shoot = funcs.is.bool_to_01(funcs.is.key_active(24,1.0))
	end

	plyr_pid=g.tbl.remote_ped.pid
	if f.on and funcs.is.valid_pid(plyr_pid) then
		make_ped()
		if funcs.is.ent(g.tbl.R_P.ped) then
			menu.get_feature_by_hierarchy_key("online.services.disable_out_of_bounds_death").on=true
			menu.get_feature_by_hierarchy_key("online.services.off_the_radar").on=true
			g.tbl.R_P.pos = funcs.ME._crds()
			good_ped=(funcs.is.ent(g.tbl.R_P.ped) and not API.ent.is.dead(g.tbl.R_P.ped))
			good_pid=(funcs.is.valid_pid(plyr_pid))
			while f.on and good_ped and good_pid do
				get_input()
				if in_veh then
					if driving then
						shuffle_once=false
						if dir then
							ntv.doo.drive_veh(g.tbl.R_P.ped, ped_veh, dir, -1)
							brake_once=false
						elseif not brake_once then
							brake_once=true
							--API.Ped.set.into_veh(g.tbl.R_P.ped, ped_veh,ped_seat)
							ntv.doo.drive_veh(g.tbl.R_P.ped, ped_veh, 1, -1)
						end
					elseif ntv.is.veh_seat_free(ped_veh,-1) then
						if ped_seat == 0 then
							if not shuffle_once then
								ntv.task.ped_seat_shuffle(g.tbl.R_P.ped, ped_veh)
								shuffle_once=true
							end
						else
							API.Ped.set.into_veh(g.tbl.R_P.ped, ped_veh,-1)
						end

					end
					if aim_or_shoot then
						ped_is_aiming_or_shooting()
						if shoot == 1 and shoot_time < TIME_MS() then
							gameplay.shoot_single_bullet_between_coords(ray_start, aim_pos, 1, g.tbl.remote_ped.weap_hash, g.tbl.R_P.ped, true, false, 1000)
							shoot_time = TIME_MS()+69
						end
					end
				else
					shuffle_once=false
					pos = funcs.get.front_of_dir(API.ent.get.coords(g.tbl.R_P.ped),API.cam.get.rot()+v3(0,0,dir),2.5)
					if API.cntrl.is.just_pressed(0, 22) then
						if not yield_do(150,"jump") then
							ntv.doo.ped_jump(g.tbl.R_P.ped,0,0) -- normal jump
						elseif not yield_do(90,"jump") then
							ntv.doo.ped_jump(g.tbl.R_P.ped,1,0) -- super jump (beast)
						elseif yield_do(80,"jump") then
							ntv.doo.ped_jump(g.tbl.R_P.ped,1,1) -- super SUPER jump
						else
							ntv.doo.ped_jump(g.tbl.R_P.ped,1,0)
						end
						yield_do(500,"not_in_air")
						yield_do(60000,"jump_wait")
					elseif aim_or_shoot then
						ped_is_aiming_or_shooting()
						ntv.set.ped_weap(g.tbl.R_P.ped,g.tbl.remote_ped.weap_hash)
						ntv.doo.ped_refill_ammo_now(g.tbl.R_P.ped)
						ntv.doo.ped_mag_infinite(g.tbl.R_P.ped)
						if shoot == 1 then
							if weapon.get_weapon_weapon_wheel_slot(g.tbl.remote_ped.weap_hash) == 7 then
								ntv.task.thow_prjctl(g.tbl.R_P.ped,aim_pos)
								time=TIME_MS()+1250
							else
								if g.tbl.remote_ped.weap_hash == API.get_hash_key("weapon_rayminigun") or g.tbl.remote_ped.weap_hash == API.get_hash_key("weapon_minigun") then
									time=TIME_MS()+500
								else
									time=TIME_MS()+50
								end
								ntv.task.go_aim_coords(g.tbl.R_P.ped,pos,aim_pos,ped_speed,shoot,2.0,0.5,move,0,0,API.get_hash_key("FIRING_PATTERN_FULL_AUTO"))
							end
							while time > TIME_MS() and f.on and good_ped and good_pid do--and ai.is_task_active(g.tbl.R_P.ped, 289) do
								YIELD(0)
								do_each_frame()
							end
						else
							ntv.task.go_aim_coords(g.tbl.R_P.ped,pos,aim_pos,ped_speed,shoot,2.0,0.5,move,0,0,API.get_hash_key("FIRING_PATTERN_FULL_AUTO"))
						end
					elseif ped_speed > 0 then
						ntv.task.go_straight_coords(g.tbl.R_P.ped,pos,ped_speed,1,0.0,0.5)
					elseif not ai.is_task_active(g.tbl.R_P.ped, 160) and not hopeful_veh then --CTaskEnterVehicle
						ntv.task.pause(g.tbl.R_P.ped)
					end
				end
				YIELD(0)
				do_each_frame()
			end
		end
		remove_ped()
		ntv.cam.set.no_focus_pos()
		ntv.map.unlock_mini_pos()
		if not otr then
			menu.get_feature_by_hierarchy_key("online.services.off_the_radar").on=false
		end
		if g.tbl.R_P.pos and funcs.get.dist_pospos_v3(funcs.ME._crds(),g.tbl.R_P.pos) > 5 then
			API.ent.set.coords(funcs.ME._ped(),g.tbl.R_P.pos)
		end
	end
	f.on=false
	g.tbl.R_P.pos=nil
	g.tbl.R_P.ped=nil
end)


g.tbl.remote_ped.pid_str={"PID"}
g.tbl.remote_ped.pid=nil
g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	local do_it = true
	while do_it do
		for i=0,31 do
			if funcs.is.valid_pid(i) then
				g.tbl.remote_ped.pid_str[i+1] = API.plyr.get.name(i)
			else
				g.tbl.remote_ped.pid_str[i+1]="PID "..i
			end
		end
		if API.plyr.is.valid(g.tbl.remote_ped.select_player.value) then
			g.tbl.remote_ped.pid=g.tbl.remote_ped.select_player.value
		else
			g.tbl.remote_ped.pid=nil
		end
		g.tbl.remote_ped.select_player:set_str_data(g.tbl.remote_ped.pid_str)
		YIELD(500)
	end
end)

function g.tbl.remote_ped.check_pid_selection()
	if API.plyr.is.valid(g.tbl.remote_ped.select_player.value) then
		g.tbl.remote_ped.selected_player=g.tbl.remote_ped.select_player.value
	else
		local down=false
		if g.tbl.remote_ped.previous_pid~=g.tbl.remote_ped.select_player.value then
			if g.tbl.remote_ped.select_player.value==g.tbl.remote_ped.previous_pid-1 or g.tbl.remote_ped.previous_pid-1==-1 then
				down=true
			end
		end
		repeat
			if not API.plyr.is.valid(g.tbl.remote_ped.select_player.value) then
				if down then
					if g.tbl.remote_ped.select_player.value == 0 then
						g.tbl.remote_ped.select_player.value=31
					else
						g.tbl.remote_ped.select_player.value=g.tbl.remote_ped.select_player.value-1
					end
				else
					if g.tbl.remote_ped.select_player.value == 31 then
						g.tbl.remote_ped.select_player.value=0
					else
						g.tbl.remote_ped.select_player.value=g.tbl.remote_ped.select_player.value+1
					end
				end
			end
		until API.plyr.is.valid(g.tbl.remote_ped.select_player.value)
		g.tbl.remote_ped.previous_pid=g.tbl.remote_ped.select_player.value
	end
end
g.tbl.remote_ped.previous_pid=0
g.tbl.remote_ped.select_player=menu_add_feature("Near player:", "autoaction_value_str", g.tbl.remote_ped.prnt.id,function(f)
	g.tbl.remote_ped.check_pid_selection()
end)
g.tbl.remote_ped.select_player:set_str_data(g.tbl.remote_ped.pid_str)

g.tbl.remote_ped.weapons = {}
g.tbl.remote_ped.weapons.main_prnt=menu_add_feature("Select Weapon", "parent", g.tbl.remote_ped.prnt.id)
g.tbl.remote_ped.weapons.srch_prnt=menu_add_feature("Search", "parent",g.tbl.remote_ped.weapons.main_prnt.id)
g.tbl.remote_ped.weapons.srch_list={}

g.tbl.remote_ped.search=og_menu_add_feature("Current weapon : "..API.wpn.get_name(g.tbl.remote_ped.weap_hash), "action",g.tbl.remote_ped.weapons.srch_prnt.id,function(f)
	local status,str = 1
	status,str = funcs.get.text_input("Type weapon name","",25,0)
	if status == 0 then
		for i=1,#g.tbl.remote_ped.weapons.srch_list do
			g.tbl.remote_ped.weapons.srch_list[i].hidden=string.match(string.lower(g.tbl.remote_ped.weapons.srch_list[i].name), string.lower(str)) == nil
		end
	end
end)
g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	for i=1,#weap_info.all_hash do
		g.tbl.remote_ped.weapons.srch_list[i]=og_menu_add_feature(API.wpn.get_name(weap_info.all_hash[i]), "action",g.tbl.remote_ped.weapons.srch_prnt.id,function(f)
			g.tbl.remote_ped.weap_hash= weap_info.all_hash[i]
			g.tbl.remote_ped.search.name="Current weapon : "..API.wpn.get_name(g.tbl.remote_ped.weap_hash)
			g.tbl.remote_ped.info_check("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
			g.tbl.remote_ped.info_write("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
		end)
		g.tbl.remote_ped.weapons.srch_list[i].hidden=true
		if i % 5== 0 then
			YIELD(0)
		end
	end
end)

		g.tbl.remote_ped.weapons.types={
		[0]="Pistols",
		[1]="Machine guns",
		[2]="Assault rifles",
		[3]="Snipers",
		[4]="Melee",
		[5]="Shotguns",
		[6]="Heavy weapons",
		[7]="Throwable/Other"
		}
		g.tbl.remote_ped.weapons.prnts={}
		g.tbl.remote_ped.weapons.temp={}
		g.tbl.remote_ped.weapons.one={}

	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		for i=0,7 do
			--if i ~= 4 then --i couldnt figure out melee :(
				g.tbl.remote_ped.weapons.temp[i]={}
				g.tbl.remote_ped.weapons.prnts[i]=menu_add_feature(g.tbl.remote_ped.weapons.types[i], "parent", g.tbl.remote_ped.weapons.main_prnt.id)

				local rp_weap_temp = g.tbl.remote_ped.weapons.temp[i]
				for ii=1,#weap_info.all_hash do
					if weapon.get_weapon_weapon_wheel_slot(weap_info.all_hash[ii])==i and API.wpn.get_name(weap_info.all_hash[ii]) ~= "Unarmed" then
						rp_weap_temp[#rp_weap_temp+1]=weap_info.all_hash[ii]
					end
					if ii % 50 == 0 then
						YIELD(0)
					end
				end
				table.sort(rp_weap_temp, function(a, b) return API.wpn.get_name(a):lower() <  API.wpn.get_name(b):lower() end)
				g.tbl.remote_ped.weapons.one[i]={}
				local rp_weap_one = g.tbl.remote_ped.weapons.one[i]
				for ii=1,#rp_weap_temp do
					if rp_weap_temp[ii] == API.get_hash_key("weapon_stinger") then
						rp_weap_one[ii]=og_menu_add_feature("RPG Stinger", "action", g.tbl.remote_ped.weapons.prnts[i].id, function(f,pid)
							g.tbl.remote_ped.weap_hash= rp_weap_temp[ii]
							g.tbl.remote_ped.search.name="Current weapon : RPG Stinger"
							g.tbl.remote_ped.info_check("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
							g.tbl.remote_ped.info_write("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
							for iii=0,7 do
								for iiii=1,#g.tbl.remote_ped.weapons.one[iii] do
									if g.tbl.remote_ped.weapons.temp[iii][iiii] ~= g.tbl.remote_ped.weap_hash then
										if  g.tbl.remote_ped.weapons.temp[iii][iiii] == API.get_hash_key("weapon_stinger") then
											g.tbl.remote_ped.weapons.one[iii][iiii].name="RPG Stinger"
										else
											g.tbl.remote_ped.weapons.one[iii][iiii].name=API.wpn.get_name(g.tbl.remote_ped.weapons.temp[iii][iiii])
										end
									else
										if  g.tbl.remote_ped.weapons.temp[iii][iiii] == API.get_hash_key("weapon_stinger") then
											g.tbl.remote_ped.weapons.one[iii][iiii].name="** RPG Stinger **"
										else
											g.tbl.remote_ped.weapons.one[iii][iiii].name="** "..API.wpn.get_name(g.tbl.remote_ped.weapons.temp[iii][iiii]).." **"
										end
									end
								end
							end
						end)
					else
						rp_weap_one[ii]=og_menu_add_feature(API.wpn.get_name(rp_weap_temp[ii]), "action", g.tbl.remote_ped.weapons.prnts[i].id, function(f,pid)
							g.tbl.remote_ped.weap_hash= rp_weap_temp[ii]
							g.tbl.remote_ped.search.name="Current weapon : "..API.wpn.get_name(g.tbl.remote_ped.weap_hash)
							g.tbl.remote_ped.info_check("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
							g.tbl.remote_ped.info_write("Default Ped Weapon Hash",g.tbl.remote_ped.weap_hash)
							for iii=0,7 do
								for iiii=1,#g.tbl.remote_ped.weapons.one[iii] do
									if g.tbl.remote_ped.weapons.temp[iii][iiii] ~= g.tbl.remote_ped.weap_hash then
										if  g.tbl.remote_ped.weapons.temp[iii][iiii] == API.get_hash_key("weapon_stinger") then
											g.tbl.remote_ped.weapons.one[iii][iiii].name="RPG Stinger"
										else
											g.tbl.remote_ped.weapons.one[iii][iiii].name=API.wpn.get_name(g.tbl.remote_ped.weapons.temp[iii][iiii])
										end
									else
										if  g.tbl.remote_ped.weapons.temp[iii][iiii] == API.get_hash_key("weapon_stinger") then
											g.tbl.remote_ped.weapons.one[iii][iiii].name="** RPG Stinger **"
										else
											g.tbl.remote_ped.weapons.one[iii][iiii].name="** "..API.wpn.get_name(g.tbl.remote_ped.weapons.temp[iii][iiii]).." **"
										end
									end
								end
							end
						end)
					end
					if ii % 10 == 0 then
						YIELD(0)
					end
				end
			--end
			YIELD(0)
		end
		g.tbl.remote_ped.weapons.prnts[4].hidden=true
	end)



g.tbl.remote_ped.ped_name=ped_models.hash_is_name[g.tbl.remote_ped.ped_hash]
g.tbl.remote_ped.feat.name="Remote ped ("..g.tbl.remote_ped.ped_name..")"

g.tbl.remote_ped.ped_prnt=menu_add_feature("Select Ped", "parent", g.tbl.remote_ped.prnt.id)
g.tbl.remote_ped.ped_srch_prnt=menu_add_feature("Search", "parent", g.tbl.remote_ped.ped_prnt.id)
menu_add_feature("Search for ped", "action", g.tbl.remote_ped.ped_srch_prnt.id,function()
	local status,str,veh = 1
	status,str = funcs.get.text_input("Type part of the ped name","",25,0)
	if status == 0 then
		for i=1,#g.tbl.remote_ped.ped_srch_feats do
			g.tbl.remote_ped.ped_srch_feats[i].hidden=(string.match(string.lower(g.tbl.remote_ped.ped_srch_feats[i].name), string.lower(str)) == nil)
		end
	end
end)

g.tbl.remote_ped.ped_srch_feats={}
g.tbl.remote_ped.ped_prnts={}

g.tbl.remote_ped.reticle={}

g.tbl.remote_ped.reticle.prnt=menu_add_feature("Reticle Options","parent",g.tbl.remote_ped.prnt.id,function()
	g.tbl.remote_ped.reticle.start_test_display()
end)

	function g.tbl.remote_ped.reticle.start_test_display()
		if g.var.GS_has_loaded then
			g.tbl.remote_ped.reticle.test_display=true
			g.tbl.remote_ped.reticle.test_display_feat.on=true
		end
	end

	g.tbl.remote_ped.reticle.test_display=false
	g.tbl.remote_ped.reticle.test_display_feat=og_menu_add_feature("Remote ped icon HIDDEN", "toggle",g.tbl.remote_ped.reticle.prnt.id,function(f)
		local time = TIME_MS() + 3000
		while time > TIME_MS() do
			if g.tbl.remote_ped.reticle.test_display then
				g.tbl.remote_ped.reticle.test_display=false
				time = TIME_MS() + 3000
			end
			API.SD.draw_sprt(g.tbl.reticle_sprites[g.tbl.remote_ped.reticle.slct.value],funcs.vec(0,0),1*g.tbl.remote_ped.reticle.mrkr_s.value,0, funcs.get.rgba_to_int(g.tbl.remote_ped.reticle.mrkr_r.value,g.tbl.remote_ped.reticle.mrkr_g.value,g.tbl.remote_ped.reticle.mrkr_b.value,mth.flr((time-TIME_MS())/3000*g.tbl.remote_ped.reticle.mrkr_a.value)))
			YIELD(5)
		end
		f.on=false
	end)
	g.tbl.remote_ped.reticle.test_display_feat.hidden=true

	g.tbl.remote_ped.reticle.slct = menu_add_feature("Select icon", "autoaction_value_i", g.tbl.remote_ped.reticle.prnt.id, function(f)
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.slct,1,#g.tbl.reticle_files,1,1,"g.tbl.remote_ped.reticle.slct")
	g.tbl.remote_ped.reticle.slct.value=46

	g.tbl.remote_ped.reticle.mrkr_s = menu_add_feature("Icon size", "autoaction_value_f",g.tbl.remote_ped.reticle.prnt.id,function()
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.mrkr_s,0,3,0.01,1,"g.tbl.remote_ped.reticle.mrkr_s")

	g.tbl.remote_ped.reticle.mrkr_r = menu_add_feature("Red", "autoaction_value_i",g.tbl.remote_ped.reticle.prnt.id,function()
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.mrkr_r,0,255,1,255,"g.tbl.remote_ped.reticle.mrkr_r")
	g.tbl.remote_ped.reticle.mrkr_g = menu_add_feature("Green", "autoaction_value_i",g.tbl.remote_ped.reticle.prnt.id,function()
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.mrkr_g,0,255,1,0,"g.tbl.remote_ped.reticle.mrkr_g")
	g.tbl.remote_ped.reticle.mrkr_b = menu_add_feature("Blue", "autoaction_value_i",g.tbl.remote_ped.reticle.prnt.id,function()
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.mrkr_b,0,255,1,0,"g.tbl.remote_ped.reticle.mrkr_b")
	g.tbl.remote_ped.reticle.mrkr_a = menu_add_feature("Alpha", "autoaction_value_i",g.tbl.remote_ped.reticle.prnt.id,function()
		g.tbl.remote_ped.reticle.start_test_display()
	end)
	funcs.set_feat_i_f(g.tbl.remote_ped.reticle.mrkr_a,0,255,1,255,"g.tbl.remote_ped.reticle.mrkr_a")

g.tbl.remote_ped.ped_god=menu_add_feature("Ped god","toggle",g.tbl.remote_ped.prnt.id)
funcs.add_to_S_L(g.tbl.remote_ped.ped_god,"g.tbl.remote_ped.ped_god")
g.tbl.remote_ped.veh_god=menu_add_feature("Vehicle god","toggle",g.tbl.remote_ped.prnt.id)
funcs.add_to_S_L(g.tbl.remote_ped.veh_god,"g.tbl.remote_ped.veh_god")

g.print_load_info("Remote Ped",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Utilities"


menu_add_feature("Set waypoint at this location","toggle", g.prnt.utils.id, function(f)
	local my_pos,wp = API.plyr.get.coords(API.plyr.my_id()),ui.get_waypoint_coord()
	while f.on do
		if (wp.x ~= my_pos.x) and (wp.y ~= my_pos.y) then
			ui.set_new_waypoint(funcs.vec(my_pos.x,my_pos.y))
		end
		YIELD(1000)
		wp=ui.get_waypoint_coord()
	end
end)

menu_add_feature("Set random waypoint","action", g.prnt.utils.id, function(f)
	ui.set_new_waypoint(funcs.vec(mth.rndm(-3500,4200),mth.rndm(-3600,7600)))
end)

g._autoremove_dead=menu_add_feature("Auto-remove dead NPC","toggle", g.prnt.utils.id, function(f)
	local all_peds
	local t = {}
	while f.on do
		all_peds=API.Ped.get.all()
		for i=1,#all_peds do
			if not t[all_peds[i]] and not API.Ped.is.plyr(all_peds[i]) and API.ent.is.dead(all_peds[i]) then
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local ent = all_peds[i]
					local t_ = t
					t_[ent]=true
					YIELD(5000)
					funcs.doo.remove_ent(ent,5000)
					t_[ent]=false
				end)
			end
		end
		YIELD(250)
	end
end)
funcs.add_to_S_L(g._autoremove_dead,"g._autoremove_dead")

g._autocollect=menu_add_feature("Auto-collect dropped cash","toggle", g.prnt.utils.id, function(f)
	local my_pos
	while f.on do
		if not funcs.ME._in_veh() then
			my_pos=funcs.ME._crds()
			for k,v in pairs(object.get_all_pickups()) do
				if API.ent.get.model_hash(v)==3999186071 then
					API.ent.set.coords(v,my_pos)
				end
			end
		end
		funcs.doo.yield_while_true2(f,1000)
	end
end)
funcs.add_to_S_L(g._autocollect,"g._autocollect")

g.var.claim_ins=false
g.feat.auto_insurance=menu_add_feature("Claim all destroyed vehicles each session", "toggle", g.prnt.utils.id, function(f)
	while f.on do
		if g.var.claim_ins then
			YIELD(3000)
			if API.plyr.count()>0 and not g.tbl.PID_INFO.loading[funcs.ME._id()+1] then
				g.var.claim_ins=false
				menu.get_feature_by_hierarchy_key("online.services.personal_vehicles.claim_all_destroyed_vehicles"):toggle()
			end
		end
		YIELD(250)
	end
end)
funcs.add_to_S_L(g.feat.auto_insurance,"g.feat.auto_insurance")

event.add_event_listener("exit", function(f)
	event.remove_event_listener("player_leave", g.feat.plyr_leave)
	event.remove_event_listener("player_join", g.feat.plyr_join)
	hook.remove_script_event_hook(g.tbl.PID_INFO.typing_hook)
	funcs.doo.thermal_toggle(0)
	ntv.cam.set.render_script(0,0,0,0,0)
	ntv.cam.doo.destroy_all()
	ntv.cam.set.no_focus_pos()
	ntv.map.unlock_mini_pos()
	g.tbl.plate_anim.reset_plate()
	for k,v in pairs(g.o.tbl.original_kicks) do
		v.hidden=false
	end
	if g.tbl.R_P.pos and funcs.get.dist_pospos_v3(funcs.ME._crds(),g.tbl.R_P.pos) > 5 then
		API.ent.set.coords(funcs.ME._ped(),g.tbl.R_P.pos)
	end

	for i=1,#g.tbl.PID_INFO.otr_blip do
		if g.tbl.PID_INFO.otr_blip[i]>-1 then -- remove any green otr blips
			ui.remove_blip(g.tbl.PID_INFO.otr_blip[i])
		end
	end
	for i=1,#g.tbl.PID_INFO.undead_blip do
		if g.tbl.PID_INFO.undead_blip[i]>-1 then -- remove any undead blips
			ui.remove_blip(g.tbl.PID_INFO.undead_blip[i])
		end
	end

	for k,v in pairs(g.tbl.spwn.history) do
		if funcs.is.ent(v) then
			for ii=1,funcs.get.veh_seats(v) do
				if funcs.is.ent(API.veh.get.ped_in_seat(v,ii-2)) then
					API.Ped.clear_tasks(API.veh.get.ped_in_seat(v, ii-2))
				end
			end
			if funcs.ntwrk.ask_quick(v) then
				API.ent.set.no_need(v)
				API.ent.delete(v)
			end
		end
	end
	for k,v in pairs(g.o.tbl.cages) do
		for kk,vv in pairs(v) do
			if funcs.ntwrk.ask_quick(vv) then
				API.ent.set.no_need(vv)
				API.ent.delete(vv)
			end
		end
	end
	for k,v in pairs(g.tbl.entities) do
		if funcs.is.ent(v) and funcs.ntwrk.ask_quick(v) then
			API.ent.set.no_need(v)
			API.ent.delete(v)
		end
	end

	--hook.remove_net_event_hook(g.tbl.aim_protex_main.net_hook)


	local time = funcs.get._2_dec((TIME_MS()-g.script_load_time)/1000)
	local str = "Gee-Skid unloaded | "
	str = time > 60 and str..funcs.get._2_dec(time/60).." minutes run time" or str..time.." seconds run time"

	g.N_P(3,"Into the ether :(\n"..str,__GV__,10,"Blue")

	for i=1,#g.tbl.threads do
		if g.tbl.threads[i] then
			menu.delete_thread(g.tbl.threads[i])
		end
	end
end)


g.print_load_info("Utilities",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)---------------------------------------------------UTILS END
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------PLAYER INFO STARTS
g.var.feat_loading_str = "Player Weapons"


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------PLAYERS ONLINE BEGIN



if not nil_var_for_locals then
	local weap_info_all_hash = weap_info.all_hash

	g._SelfProtex_p = menu_add_player_feature("Aim protex", "parent", g.o.prnt.plyr.id)

	g._Fake_Friends = menu_add_player_feature("Fake Friends", "parent", g.o.prnt.plyr.id)

	g.o._weapon={}

	function g.o._weapon.func(_weap,_val,_pid)
		local given,removed,pre_removed=false,false,false
		if _val==0 then
			given = funcs.doo.give_ped_weap(API.plyr.get.ped(_pid),_weap) --then
		elseif not API.wpn.ped_has(API.plyr.get.ped(_pid), _weap) then pre_removed = true
		else
			API.wpn.ped_remove(API.plyr.get.ped(_pid), _weap)
			YIELD(0)
			if not API.wpn.ped_has(API.plyr.get.ped(_pid), _weap) then removed = true end
		end
		return given,removed,pre_removed
	end

	g.o._weapon.main_prnt=menu_add_player_feature("Weapons/Ammo", "parent", g.o.prnt.plyr.id)

	g.o._weapon.search_prnt=menu_add_player_feature("Search for weapon", "parent",g.o._weapon.main_prnt.id)
	g.o._weapon.search_feats={}
	g.o._weapon.search=menu_add_player_feature("Search", "action",g.o._weapon.search_prnt.id,function()
		local status,str = 1
		status,str = funcs.get.text_input("Type weapon name","",25,0)
		if status == 0 then
			local _table={}
			for i=1,#weap_info_all_hash do
				if string.match(string.lower(API.wpn.get_name(weap_info_all_hash[i])), string.lower(str)) ~= nil then
					_table[#_table+1]= weap_info_all_hash[i]
				end
			end
			if #_table > 0 then
				table.sort(_table, function(a, b) return API.wpn.get_name(a):lower() <  API.wpn.get_name(b):lower() end)
				for i=1,#g.o._weapon.search_feats do
					if g.o._weapon.search_feats[i] ~= nil then
						menu.delete_player_feature(g.o._weapon.search_feats[i].id)
						g.o._weapon.search_feats[i] = nil
						YIELD(0)
					end
				end
				for i=1,#_table do
					g.o._weapon.search_feats[i]=og_menu_add_player_feature(API.wpn.get_name(_table[i]), "action_value_str", g.o._weapon.search_prnt.id, function(f,pid)
						local given,removed,pre_removed=g.o._weapon.func(_table[i],f.value,pid)
						if given then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API.wpn.get_name(_table[i]).."/ammo given :)",__GV__,5,"Green")
						elseif removed then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API.wpn.get_name(_table[i]).." removed :)",__GV__,5,"Green")
						elseif pre_removed then g.N_P(2,funcs.get.pid_name(pid) .. "\nPlayer did not have "..API.wpn.get_name(_table[i]),__GV__,5,"Blue")
						else g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API.wpn.get_name(_table[i]).." FAILED :(",__GV__,5,"Red")
						end
					end)
					new_set_str_data(g.o._weapon.search_feats[i],{"Give","Remove"})
				end
			end
		end
	end)

	g.o._weapon.GR_all=menu_add_player_feature("All weapons", "action_value_str",g.o._weapon.main_prnt.id, function(f,pid)
		API.wpn.ped_give(API.plyr.get.ped(pid), -72657034, 100, true)
		local given,removed,pre_removed,failed=0,0,0,0
		for i=1,#weap_info_all_hash do
			local _g,_r,_pr = g.o._weapon.func(weap_info_all_hash[i],f.value,pid)
			if _g then given = given+1 elseif _r then removed = removed+1 elseif _pr then pre_removed = pre_removed+1 else failed=failed+1 end
		end
		if f.value == 0 then
			if given > 0 then
				g.N_P(2,funcs.get.pid_name(pid) .. "\n"..given.."/"..(given+failed).." weapons/ammo given :)",__GV__,5,"Green")
			else
				g.N_P(2,funcs.get.pid_name(pid) .. "\nZero weapons given :(",__GV__,5,"Red")
			end
		elseif removed > 0 then
			g.N_P(2,funcs.get.pid_name(pid) .. "\n"..removed.."/"..(removed+failed).." weapons removed :)",__GV__,5,"Green")
		elseif pre_removed > 0 then
			g.N_P(2,funcs.get.pid_name(pid) .. "\nZero weapons because they didnt have any :)",__GV__,5,"Blue")
		end
	end)
	new_set_str_data(g.o._weapon.GR_all,{"Give","Remove"})
	g.o._weapon.types={
	[0]="Pistols",
	[1]="Machine guns",
	[2]="Assault rifles",
	[3]="Snipers",
	[4]="Melee",
	[5]="Shotguns",
	[6]="Heavy weapons",
	[7]="Throwable/Other"
	}
	g.o._weapon.prnts={}
	g.o._weapon.temp={}
	g.o._weapon.all={}
	g.o._weapon.one={}

	local g_o_weapon_types = g.o._weapon.types
	local g_o_weapon_prnts=g.o._weapon.prnts
	local g_o_weapon_temp=g.o._weapon.temp
	local g_o_weapon_all=g.o._weapon.all
	local g_o_weapon_one=g.o._weapon.one
	local weapon_get_weapon_weapon_wheel_slot = weapon.get_weapon_weapon_wheel_slot
	local API_wpn_get_name = API.wpn.get_name


	for i=0,7 do
		g_o_weapon_temp[i]={}
		g_o_weapon_prnts[i]=menu_add_player_feature(g_o_weapon_types[i], "parent", g.o._weapon.main_prnt.id)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			--YIELD(1000)
			local count = 0
			for ii=1,#weap_info_all_hash do
				local this_weap = weap_info_all_hash[ii]
				if weapon_get_weapon_weapon_wheel_slot(this_weap)==i and API_wpn_get_name(this_weap) ~= "Unarmed" then
					count=count+1
					g_o_weapon_temp[i][count]=this_weap
				end
			end
			table.sort(g_o_weapon_temp[i], function(a, b) return API_wpn_get_name(a):lower() <  API_wpn_get_name(b):lower() end)


			g_o_weapon_all[i]=menu_add_player_feature("All "..g_o_weapon_types[i], "action_value_str", g_o_weapon_prnts[i].id, function(f,pid)
				API.wpn.ped_give(API.plyr.get.ped(pid), -72657034, 100, true)
				local given,removed,pre_removed,_g,_r,_pr=false,false,false,false,false,false
				for ii=1,#g_o_weapon_temp[i] do
					local _g,_r,_pr = g.o._weapon.func(g_o_weapon_temp[i][ii],f.value,pid)
					if _g then given = true elseif _r then removed = true elseif _pr then pre_removed = true end
				end
				if given then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..g_o_weapon_types[i].."/ammo given :)",__GV__,5,"Green")
				elseif removed then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..g_o_weapon_types[i].." removed :)",__GV__,5,"Green")
				elseif pre_removed then g.N_P(2,funcs.get.pid_name(pid) .. "\nPlayer did not have "..g_o_weapon_types[i],__GV__,5,"Blue")
				else g.N_P(2,funcs.get.pid_name(pid) .. "\n"..g_o_weapon_types[i].." FAILED :(",__GV__,5,"Red")
				end
			end)
			new_set_str_data(g_o_weapon_all[i],{"Give","Remove"})
			if i== 7 then
				g.o._weapon.para=menu_add_player_feature("Parachute", "action_value_str", g_o_weapon_prnts[i].id, function(f,pid)
						API.wpn.ped_give(API.plyr.get.ped(pid), -72657034, 100, true)
						g.N_P(2,funcs.get.pid_name(pid) .. "\nParachute given :)",__GV__,5,"Blue")
				end)
				new_set_str_data(g.o._weapon.para,{"Give"})
			end
			g_o_weapon_one[i]={}
			for ii=1,#g_o_weapon_temp[i] do
				g_o_weapon_one[i][ii]=og_menu_add_player_feature(API_wpn_get_name(g_o_weapon_temp[i][ii]), "action_value_str", g_o_weapon_prnts[i].id, function(f,pid)
					local given,removed,pre_removed=g.o._weapon.func(g_o_weapon_temp[i][ii],f.value,pid)
					if given then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API_wpn_get_name(g_o_weapon_temp[i][ii]).."/ammo given :)",__GV__,5,"Green")
					elseif removed then g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API_wpn_get_name(g_o_weapon_temp[i][ii]).." removed :)",__GV__,5,"Green")
					elseif pre_removed then g.N_P(2,funcs.get.pid_name(pid) .. "\nPlayer did not have "..API_wpn_get_name(g_o_weapon_temp[i][ii]),__GV__,5,"Blue")
					else g.N_P(2,funcs.get.pid_name(pid) .. "\n"..API_wpn_get_name(g_o_weapon_temp[i][ii]).." FAILED :(",__GV__,5,"Red")
					end
				end)
				g_o_weapon_one[i][ii]:set_str_data({"Give","Remove"})
				if ii%20==0 then
					YIELD(0)
				end
			end
		end)
		--YIELD(0)
	end

	g.print_load_info("Player Weapons",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
end
	g.var.feat_loading_str = "Assassins Weapons"
		g.o.prnt.Ass2In_main=menu_add_player_feature("Assassin", "parent", g.o.prnt.plyr_attacks.id)


	function funcs.doo.remove_ents_thread(_bool,_var1,_var2,_var3)
		local t1,t2 = {},{}
		if _var1 then t1[#t1+1]=_var1 end
		if _var2 then t1[#t1+1]=_var2 end
		if _var3 then t1[#t1+1]=_var3 end
		for k1,v1 in pairs(t1) do
			if type(v1)=="table" then
				for k2,v2 in pairs(v1) do
					if _bool and type(v2)=="number" then
						g.tbl.unaffected_ents[v2]=false
					end
					if funcs.is.ent(v2) then
						t2[#t2+1]=v2
					end
				end
			else
				if _bool and type(v1)=="number" then
					g.tbl.unaffected_ents[v1]=false
				end
				if funcs.is.ent(v1) then
					t2[#t2+1]=v1
				end
			end
		end
		for k,v in pairs(t2) do
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				local ENT=v
				funcs.doo.remove_ent(ENT,3000)
			end)
		end
	end


	function funcs.doo.ped_attack_ped_thread_simple(_perp,_vctm)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local __perp,__vctm = _perp,_vctm
			local pos,dist,in_veh,aircraft,plane,helo,have_los,los_time,vctm_inair,non_air_tp,found,spawn_points
			local startTime = API.util.t_s()
			local function should_tp()
				if startTime < API.util.t_s() then
					if (helo and dist > 700) or (not helo and plane and dist > 2000) or (not aircraft and in_veh and not vctm_inair and dist > 300) or	(not in_veh and not vctm_inair and dist > 100) then
						return true
					elseif not have_los then
						if los_time == nil then
							if in_veh then
								los_time = API.util.t_s()+25
							else
								los_time = API.util.t_s()+15
							end
						elseif los_time < API.util.t_s() then
							if in_veh then
								los_time = API.util.t_s()+25
							else
								los_time = API.util.t_s()+15
							end
							return true
						end
					elseif in_veh then
						los_time = API.util.t_s()+25
					else
						los_time = API.util.t_s()+15
					end
				end	
				return false
			end
			while funcs.is.ped(__perp) and not API.ent.is.dead(__perp) and funcs.is.ped(__vctm) do
				in_veh = API.Ped.is.in_veh(__perp)
				helo = (in_veh and (API.ent.get.model_hash(API.Ped.get.veh(__perp)) == API.get_hash_key("oppressor2") or API.strm.is.valid_helo(API.ent.get.model_hash(API.Ped.get.veh(__perp)))))
				plane = (in_veh and API.strm.is.valid_plane(API.ent.get.model_hash(API.Ped.get.veh(__perp))))
				aircraft = (helo or plane)
				dist = funcs.get.dist_pospos_v3(API.ent.get.coords(__perp),API.ent.get.coords(__vctm))
				have_los = funcs.is.peds_have_los(__perp,__vctm)
				vctm_inair = (API.ent.is.in_air(__vctm) or (API.Ped.is.in_veh(__vctm) and API.ent.is.in_air(API.Ped.get.veh(__vctm))))
				--non_air_tp = (aircraft or not vctm_inair)
				if should_tp() and (not in_veh or API.veh.get.ped_in_seat(API.Ped.get.veh(__perp), -1) == __perp) then
					if API.Ped.is.plyr(__vctm) then
						pos = funcs.get.pid_pos_z_guess(API.plyr.get.plyr_from_ped(__vctm))
					else
						pos = API.ent.get.coords(__vctm)
					end
					if in_veh then
						if funcs.ntwrk.ask_long(API.Ped.get.veh(__perp),1000) then
							local size = funcs.get.basic_veh_dimensions(true,API.Ped.get.veh(__perp),2,2)
							local int = mth.flr(size*2)
							if helo then
								API.ent.set.coords(API.Ped.get.veh(__perp),pos+funcs.vec(mth.rndm(-(int*25),(int*25)),mth.rndm(-(int*25),(int*25)),100))
							elseif plane then
								API.ent.set.coords(API.Ped.get.veh(__perp),pos+funcs.vec(mth.rndm(-(int*69),(int*69)),mth.rndm(-(int*69),(int*69)),500))
							else
								spawn_points = funcs.get.spawn_points(pos,20)
								for i=1,#spawn_points do
									if funcs.get.dist_pospos_v3(spawn_points[i],API.ent.get.coords(__vctm)) < 300 then
										API.ent.set.coords(API.Ped.get.veh(__perp),spawn_points[i])
										break
									end
								end
							end
						end
					elseif vctm_inair then --gta wont let me know the victim is in air most of the time aaaa need to make my own
						pos = funcs.get.pos_nearby2(pos,10,false)
						if funcs.ntwrk.ask_long(__perp,1000) then
							API.ent.set.coords(__perp,pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),1))
						end
					elseif funcs.ntwrk.ask_long(__perp,1000) then
						API.ent.set.coords(__perp,pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),1))
					end
				end
				if in_veh and API.strm.is.valid_helo(API.ent.get.model_hash(API.Ped.get.veh(__perp))) then
					API.veh.set.helo_blades_full(API.Ped.get.veh(__perp))
				end
				ai.task_combat_ped(__perp, __vctm,0,16)
				YIELD(1000)
			end
			funcs.doo.remove_ent(__perp,1000)
		end)
	end

		function funcs.doo.Ass2In_pid_info(_pid)
			g.N_P(2,
			funcs.get.pid_name(_pid)..
			"\nAssassin: "..g.o.tbl.Ass2In.pids[_pid].PED_NAME..
			"\nWeapon: "..g.o.tbl.Ass2In.pids[_pid].WEAP_NAME..
			"\nVehicle: "..g.o.tbl.Ass2In.pids[_pid].VEH_NAME,
			__GV__,4,"Blue")
		end

		g.o.feat.Ass2In=menu_add_player_feature("Send Assassins", "value_i", g.o.prnt.Ass2In_main.id,function(f,pid)
			local machinePistol = API.get_hash_key("weapon_machinepistol")
			local microSmg = API.get_hash_key("weapon_microsmg")
			local backupBool, backupHash
			local peds_not_to_love,peds,start,veh,memory={},{},{},{},{}
			local veh_height,pid_group,pos,ped_count,peds_temp,all_peds,found,dist,new_pos,spawn_points
			local attacker_group = ped.create_group()
			while f.on do
				for a=1,f.value do
					start[a]=true
					peds[a] = peds[a] or {}
					veh[a] = veh[a] or {}
					for i=1,#peds[a] do
						if funcs.is.ent(peds[a][i]) and not API.ent.is.dead(peds[a][i]) then
							start[a]=false
							break
						end
					end
					if start[a] then
						funcs.doo.remove_ents_thread(true,peds[a],veh[a])
						if not ped.does_group_exist(attacker_group) then
							attacker_group = ped.create_group()
						end
						--funcs.doo.wipe_tbl(peds_not_to_love)
						funcs.doo.wipe_tbl(peds[a])
						peds_not_to_love[API.plyr.get.ped(pid)]=true
						pid_group = player.get_player_group(pid)
						ped_count = math.min(veh_stuff.info[g.o.tbl.Ass2In.pids[pid].VEH_HASH].SEATS,g.o.tbl.Ass2In.pids[pid].PED_MAX)
						spawn_points = funcs.get.spawn_points(API.plyr.get.coords(pid),20)
						pos = spawn_points[mth.rndm(1,#spawn_points)]
						if API.strm.is.valid_helo(g.o.tbl.Ass2In.pids[pid].VEH_HASH) or g.o.tbl.Ass2In.pids[pid].VEH_HASH == API.get_hash_key("oppressor2") then
							veh_height=mth.rndm(100,200)
							pos=pos+funcs.vec(mth.rndm(-150,150),mth.rndm(-150,150),2)
						elseif API.strm.is.valid_plane(g.o.tbl.Ass2In.pids[pid].VEH_HASH) then
							veh_height=mth.rndm(400,500)
							pos=pos+funcs.vec(mth.rndm(-500,500),mth.rndm(-500,500),2)
						else
							veh_height=0
						end
						funcs.doo.req_model(g.o.tbl.Ass2In.pids[pid].VEH_HASH)
						veh[a] = funcs.doo.spawn_veh(pos+funcs.vec(0,0,veh_height),g.o.tbl.Ass2In.pids[pid].VEH_HASH,true,0,true,true)
						YIELD(0)
						if funcs.is.veh(veh[a]) then
							g.tbl.unaffected_ents[veh[a]]=true
							memory[#memory+1]=veh[a]
							API.ent.set.god(veh[a],g.o.tbl.Ass2In.pids[pid].VEH_GOD)
							funcs.doo.req_model(g.o.tbl.Ass2In.pids[pid].PED_HASH)
							backupBool = g.o.tbl.Ass2In.pids[pid].PISTOL
							backupHash = g.o.tbl.Ass2In.pids[pid].WEAP_HASH ~= machinePistol and machinePistol or microSmg
							for i=1,ped_count do 
								peds[a][#peds[a]+1]=funcs.doo.spawn_ped_angry(
								pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),2),
								g.o.tbl.Ass2In.pids[pid].PED_HASH,
								g.o.tbl.Ass2In.pids[pid].WEAP_HASH,
								backupBool and backupHash or nil,
								pid,
								veh[a]
								)
								YIELD(0)
								if funcs.is.ped(peds[a][#peds[a]]) then
									g.tbl.unaffected_ents[peds[a][#peds[a]]]=true
									memory[#memory+1]=peds[a][#peds[a]]
									API.ent.set.god(peds[a][#peds[a]],g.o.tbl.Ass2In.pids[pid].PED_GOD)
									peds_not_to_love[peds[a][#peds[a]]]=true
									ped.set_ped_as_group_member(peds[a][#peds[a]], attacker_group)
									ped.set_ped_never_leaves_group(peds[a][#peds[a]], true)
									ped.set_relationship_between_groups(5, attacker_group, pid_group)
									ped.set_relationship_between_groups(5, pid_group, attacker_group)
								end
							end
							for i=1,ped_count do
								if funcs.is.ped(peds[a][i]) then
									funcs.doo.ped_attack_ped_thread_simple(peds[a][i],API.plyr.get.ped(pid))
								end
							end
						end
					end
					peds_temp = {}
					for i=1,#peds do
						if funcs.is.ent(veh[i]) then
							API.ent.set.god(veh[i],g.o.tbl.Ass2In.pids[pid].VEH_GOD)
						end
						for ii=1,#peds[i] do
							if funcs.is.ent(peds[i][ii]) then
								API.ent.set.god(peds[i][ii],g.o.tbl.Ass2In.pids[pid].PED_GOD)
							end
							peds_temp[#peds_temp+1]=peds[i][ii]
						end
					end
					if attacker_group and ped.does_group_exist(attacker_group) and pid_group and ped.does_group_exist(pid_group) then

						if #peds_temp > 0 then
							all_peds = API.Ped.get.all()
							for i=1,#all_peds do
								if not ped.is_ped_group_member(all_peds[i],attacker_group) then
									if not ped.is_ped_group_member(all_peds[i],pid_group) then
										if not peds_not_to_love[all_peds[i]] then
											ped.set_relationship_between_groups(1, attacker_group, ped.get_ped_group(all_peds[i]))
											ped.set_relationship_between_groups(1, ped.get_ped_group(all_peds[i]), attacker_group)
										end
									end
								end
							end
						end
					end
					if #peds > f.value then
						for i=1,#peds do
							if i > f.value then
								funcs.doo.remove_ents_thread(true,peds[i],veh[i])
							end
						end
						YIELD(0)
						for i=1,#peds do
							if i > f.value then
								peds[i]=nil
								veh[i]=nil
							end
						end
					end
				end
				funcs.doo.yield_while_true(f.on,2000)
			end
			funcs.doo.remove_ents_thread(true,memory)
		end)
		funcs.set_feat_i_f(g.o.feat.Ass2In,1,10,1,1)





		g.o.tbl.Ass2In = {}
		g.o.tbl.Ass2In.loaded=false
		g.o.tbl.Ass2In.loadedtime=TIME_MS()
		g.o.tbl.Ass2In.pids={}
		g.o.tbl.Ass2In.weapons = {}
		g.o.tbl.Ass2In.weapons.prnts={}
		g.o.tbl.Ass2In.weapons.temp={}
		g.o.tbl.Ass2In.ped_prnts={}
		g.o.tbl.Ass2In.weapons.types={
		[0]="Pistols",
		[1]="Machine guns",
		[2]="Assault rifles",
		[3]="Snipers",
		[4]="Melee",
		[5]="Shotguns",
		[6]="Heavy weapons",
		[7]="Throwable/Other"
		}

		for i=0,31 do
			g.o.tbl.Ass2In.pids[i]={
			VEH_HASH = API.get_hash_key("hunter"),
			VEH_NAME = veh_stuff.hash_is_name[API.get_hash_key("hunter")],
			VEH_GOD = false,
			PED_HASH = API.get_hash_key("s_m_y_clown_01"),
			PED_NAME = ped_models.hash_is_name[API.get_hash_key("s_m_y_clown_01")],
			PED_GOD = false,
			WEAP_HASH = API.get_hash_key("weapon_combatmg_mk2"),
			WEAP_NAME = API.wpn.get_name(API.get_hash_key("weapon_combatmg_mk2")),
			PED_MAX = 2,
			PISTOL = false
			}
		end

	--g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		g.o.prnt.Ass2In_weapons=menu_add_player_feature("Select Weapon", "parent", g.o.prnt.Ass2In_main.id)
		g.o.prnt.Ass2In_ped_prnt=menu_add_player_feature("Select Assassin", "parent", g.o.prnt.Ass2In_main.id)
		g.o.prnt.Ass2In_veh_prnt=menu_add_player_feature("Select Vehicle", "parent",g.o.prnt.Ass2In_main.id)
		g.o.prnt.Ass2In_veh_prnt_recc=menu_add_player_feature("Recommended", "parent",g.o.prnt.Ass2In_veh_prnt.id)

if not nil_var_for_locals then
	local weap_info_all_hash = weap_info.all_hash
	local g_o_tbl_Ass2In_weapons_temp = g.o.tbl.Ass2In.weapons.temp
	local g_o_tbl_Ass2In_weapons_prnts = g.o.tbl.Ass2In.weapons.prnts
	local g_o_tbl_Ass2In_weapons_types = g.o.tbl.Ass2In.weapons.types
	local weapon_get_weapon_weapon_wheel_slot = weapon.get_weapon_weapon_wheel_slot
	local API_wpn_get_name = API.wpn.get_name
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		for i=0,7 do
			g_o_tbl_Ass2In_weapons_temp[i]={}
			g_o_tbl_Ass2In_weapons_prnts[i]=og_menu_add_player_feature(g_o_tbl_Ass2In_weapons_types[i], "parent", g.o.prnt.Ass2In_weapons.id)
			for ii=1,#weap_info_all_hash do
				local this_weap = weap_info_all_hash[ii]
				if weapon_get_weapon_weapon_wheel_slot(this_weap)==i and API_wpn_get_name(this_weap) ~= "Unarmed" then
					g_o_tbl_Ass2In_weapons_temp[i][#g_o_tbl_Ass2In_weapons_temp[i]+1]=this_weap
				end
				if ii%50==0 then
					YIELD(0)
				end
			end
			table.sort(g_o_tbl_Ass2In_weapons_temp[i], function(a, b) return API_wpn_get_name(a):lower() <  API_wpn_get_name(b):lower() end)
			for ii=1,#g_o_tbl_Ass2In_weapons_temp[i] do
				og_menu_add_player_feature(API_wpn_get_name(g_o_tbl_Ass2In_weapons_temp[i][ii]), "action", g_o_tbl_Ass2In_weapons_prnts[i].id, function(f,pid)
					g.o.tbl.Ass2In.pids[pid].WEAP_HASH=g_o_tbl_Ass2In_weapons_temp[i][ii]
					g.o.tbl.Ass2In.pids[pid].WEAP_NAME=API_wpn_get_name(g_o_tbl_Ass2In_weapons_temp[i][ii])
					funcs.doo.Ass2In_pid_info(pid)
				end)
				if ii%5==0 then
					YIELD(0)
				end
			end
			YIELD(0)
		end
	end)
	g.print_load_info("Assassins weapons",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Assassins/Remote Peds"
	local string_match = string.match
	local string_sub = string.sub
	local g_o_tbl_Ass2In_ped_prnts = g.o.tbl.Ass2In.ped_prnts
	local g_tbl_remote_ped_ped_prnts = g.tbl.remote_ped.ped_prnts
	local g_tbl_remote_ped_ped_srch_prnt_id = g.tbl.remote_ped.ped_srch_prnt.id
	for i=1,#ped_models.types do
		local PED_TYPE = ped_models.types[i]
		local PED_TYPE_LEN = string.len(PED_TYPE[1])
		g_o_tbl_Ass2In_ped_prnts[i]=og_menu_add_player_feature(PED_TYPE[2], "parent", g.o.prnt.Ass2In_ped_prnt.id)
		g_tbl_remote_ped_ped_prnts[i]=og_menu_add_feature(PED_TYPE[2], "parent", g.tbl.remote_ped.ped_prnt.id)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			for ii=1,#ped_models.peds do
				local PED = ped_models.peds[ii]
				if string_match(string_sub(PED[1],1,PED_TYPE_LEN),PED_TYPE[1]) then
					og_menu_add_player_feature(PED[2], "action", g_o_tbl_Ass2In_ped_prnts[i].id,function(f,pid)
						g.o.tbl.Ass2In.pids[pid].PED_HASH=API.get_hash_key(PED[1])
						g.o.tbl.Ass2In.pids[pid].PED_NAME=ped_models.hash_is_name[API.get_hash_key(PED[1])]
						funcs.doo.Ass2In_pid_info(pid)
					end)
					og_menu_add_feature(PED[2], "action", g_tbl_remote_ped_ped_prnts[i].id,function()
						g.tbl.remote_ped.ped_hash=API.get_hash_key(PED[1])
						g.tbl.remote_ped.ped_name=ped_models.hash_is_name[g.tbl.remote_ped.ped_hash]
						g.tbl.remote_ped.feat.name="Remote ped ("..g.tbl.remote_ped.ped_name..")"
						g.tbl.remote_ped.info_check("Default Ped Model Hash",g.tbl.remote_ped.ped_hash)
						g.tbl.remote_ped.info_write("Default Ped Model Hash",g.tbl.remote_ped.ped_hash)
						g.N_P(2,"Ped selected: "..g.tbl.remote_ped.ped_name,__GV__,4,"Blue")
					end)
				end
				if i==1 then
					g.tbl.remote_ped.ped_srch_feats[ii]=og_menu_add_feature(PED[2], "action", g_tbl_remote_ped_ped_srch_prnt_id,function()
						g.tbl.remote_ped.ped_hash=API.get_hash_key(PED[1])
						g.tbl.remote_ped.ped_name=ped_models.hash_is_name[g.tbl.remote_ped.ped_hash]
						g.tbl.remote_ped.feat.name="Remote ped ("..g.tbl.remote_ped.ped_name..")"
						g.tbl.remote_ped.info_check("Default Ped Model Hash",g.tbl.remote_ped.ped_hash)
						g.tbl.remote_ped.info_write("Default Ped Model Hash",g.tbl.remote_ped.ped_hash)
						g.N_P(2,"Ped selected: "..g.tbl.remote_ped.ped_name,__GV__,4,"Blue")
					end)
					g.tbl.remote_ped.ped_srch_feats[ii].hidden=true
				end
				if ii%5==0 then
					YIELD(0)
				end
			end
		end)
	end

	g.print_load_info("Assassins/Remote Peds",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)

	g.var.feat_loading_str = "Assassins vehicles"

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	g.tbl.spawn_veh_feature_p={}
	g.tbl.spawn_veh_feature_p.temp_list_sort={}
	g.tbl.spawn_veh_feature_p.feat_srch_table={}

	g._VehicleSpawnP_class=menu_add_player_feature("All vehicles by type", "parent", g.o.prnt.spwn.id)
	g.tbl.spawn_veh_feature_p.quick ={}
	g.tbl.spawn_veh_feature_p.quick.prnt=menu_add_player_feature("Quick spawn list", "parent", g.o.prnt.spwn.id)

	g.tbl.spawn_veh_feature_p.quick.feats={}

	g.o.tbl.Ass2In_recc_vehs={
	"rcbandito",
	"minitank",
	"barrage",
	"insurgent3",
	"scarab",
	"phantom2",
	"khanjali",
	"buzzard",
	"savage",
	"akula",
	"hunter",
	"nokota",
	"seabreeze",
	"rogue",
	"molotok",
	"strikeforce",
	"hydra",
	"lazer",
	"dinghy5",
	"patrolboat",
	}
	local yield_count = 0
	for i=1,#g.o.tbl.Ass2In_recc_vehs do
		og_menu_add_player_feature(veh_stuff.hash_is_name[API.get_hash_key(g.o.tbl.Ass2In_recc_vehs[i])], "action", g.o.prnt.Ass2In_veh_prnt_recc.id,function(f,pid)
			g.o.tbl.Ass2In.pids[pid].VEH_HASH=API.get_hash_key(g.o.tbl.Ass2In_recc_vehs[i])
			g.o.tbl.Ass2In.pids[pid].VEH_NAME=veh_stuff.hash_is_name[API.get_hash_key(g.o.tbl.Ass2In_recc_vehs[i])]
			funcs.doo.Ass2In_pid_info(pid)
		end)
		yield_count=yield_count+1
		if yield_count%5==0 then
			YIELD(0)
		end
	end

	g.o.tbl.Ass2In.vehs={}
	g.o.tbl.Ass2In.vehs.temp_list_sort={}
	g.o.tbl.Ass2In.vehs.feat_srch_table={}

	local veh_stuff_class_list = veh_stuff.class_list
	local g_o_tbl_Ass2In_vehs_temp_list_sort = g.o.tbl.Ass2In.vehs.temp_list_sort
	local g_tbl_spawn_veh_feature_p_temp_list_sort = g.tbl.spawn_veh_feature_p.temp_list_sort
	local veh_stuff_master = veh_stuff.master
	local g_o_tbl_Ass2In_vehs_feat_srch_table = g.o.tbl.Ass2In.vehs.feat_srch_table

	for i=1,#veh_stuff_class_list do
		local this_class = veh_stuff_class_list[i]
		if this_class ~= "Trains" then
			g_o_tbl_Ass2In_vehs_temp_list_sort[i]={}
		end
		g_tbl_spawn_veh_feature_p_temp_list_sort[i]={}
		for ii=1,#veh_stuff_master do
			local this_tbl = veh_stuff_master[ii]
			if this_tbl[6] == this_class then
				if this_class ~= "Trains" then
					g_o_tbl_Ass2In_vehs_temp_list_sort[i][#g_o_tbl_Ass2In_vehs_temp_list_sort[i]+1]=this_tbl
				end
				g_tbl_spawn_veh_feature_p_temp_list_sort[i][#g_tbl_spawn_veh_feature_p_temp_list_sort[i]+1]=this_tbl
			end
			yield_count=yield_count+1
			if yield_count%50==0 then
				YIELD(0)
			end
		end
		if this_class ~= "Trains" then
			table.sort(g_o_tbl_Ass2In_vehs_temp_list_sort[i], function(a, b) return a[1]:lower() <  b[1]:lower() end)
		end
		table.sort(g_tbl_spawn_veh_feature_p_temp_list_sort[i], function(a, b) return a[1]:lower() <  b[1]:lower() end)
		YIELD(0)
	end

	local g_o_prnt_Ass2In_veh_prnt_id = g.o.prnt.Ass2In_veh_prnt.id
	local veh_stuff_info = veh_stuff.info
	local g_tbl_spawn_veh_feature_p_feat_srch_table = g.tbl.spawn_veh_feature_p.feat_srch_table
	local g_VehicleSpawnP_class_id = g._VehicleSpawnP_class.id
	for i=1,#veh_stuff_class_list do
		local this_class = veh_stuff_class_list[i]
		local this_temp_list = g_o_tbl_Ass2In_vehs_temp_list_sort[i]
		if this_temp_list then
			g_o_tbl_Ass2In_vehs_feat_srch_table[i] = menu_add_player_feature(this_class, "parent",g_o_prnt_Ass2In_veh_prnt_id)
			--g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				for ii=1,#this_temp_list do
					local this_temp_veh = this_temp_list[ii]
					if veh_stuff_info[this_temp_veh[5]].SEATS > 0 then
						og_menu_add_player_feature(this_temp_veh[2] == "" and this_temp_veh[1] or this_temp_veh[1].." - "..this_temp_veh[2], "action", g_o_tbl_Ass2In_vehs_feat_srch_table[i].id,function(f,pid)
							g.o.tbl.Ass2In.pids[pid].VEH_HASH=this_temp_veh[5]
							g.o.tbl.Ass2In.pids[pid].VEH_NAME=veh_stuff.hash_is_name[this_temp_veh[5]]
							funcs.doo.Ass2In_pid_info(pid)
						end)
					end
					yield_count=yield_count+1
					if yield_count%5==0 then
						YIELD(0)
					end
				end
			--end)
		end
		--g.load_break()
		g_tbl_spawn_veh_feature_p_feat_srch_table[i] = menu_add_player_feature(this_class, "parent",g_VehicleSpawnP_class_id)
		--g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			for ii=1,#g_tbl_spawn_veh_feature_p_temp_list_sort[i] do
				local this_temp_veh = g_tbl_spawn_veh_feature_p_temp_list_sort[i][ii]
				og_menu_add_player_feature(this_temp_veh[2] == "" and this_temp_veh[1] or this_temp_veh[1].." - "..this_temp_veh[2], "action", g_tbl_spawn_veh_feature_p_feat_srch_table[i].id,function(f,pid)
					if intrr.is_pid_intrr(pid) then
						g.N_P(2,funcs.get.pid_name(pid) .. "\nIn interior.",__GV__,4,"Blue")
					else
						funcs.doo.req_model(this_temp_veh[5])
						local veh = funcs.doo.spawn_veh_at_pid(pid,this_temp_veh[5],true)
					end
				end)
				yield_count=yield_count+1
				if yield_count%5==0 then
					YIELD(0)
				end
			end

		--end)
		YIELD(0)
	end
	g.o.tbl.Ass2In.ped_god=menu_add_player_feature("Assassin god","toggle",g.o.prnt.Ass2In_main.id,function(f,pid)
		g.o.tbl.Ass2In.pids[pid].PED_GOD=f.on
	end)
	g.o.tbl.Ass2In.veh_god=menu_add_player_feature("Vehicle god","toggle",g.o.prnt.Ass2In_main.id,function(f,pid)
		g.o.tbl.Ass2In.pids[pid].VEH_GOD=f.on
	end)
	g.o.tbl.Ass2In.backup_pistol=menu_add_player_feature("Add a backup pistol","toggle",g.o.prnt.Ass2In_main.id,function(f,pid)
		g.o.tbl.Ass2In.pids[pid].PISTOL=f.on
	end)
	g.o.tbl.Ass2In.max_peds=menu_add_player_feature("Max assassins","autoaction_value_i",g.o.prnt.Ass2In_main.id,function(f,pid)
		g.o.tbl.Ass2In.pids[pid].PED_MAX=f.value
	end)
	funcs.set_feat_i_f(g.o.tbl.Ass2In.max_peds,1,8,1,2)
	g.o.tbl.Ass2In.loaded=true

end)


	g.print_load_info("Assassins vehicles",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)

end
	g.var.feat_loading_str = "Player vehicle grief"
		g._VehicleGrief_p = menu_add_player_feature("Vehicle Grief", "parent", g.o.prnt.veh.id)

		g._VehicleModP = menu_add_player_feature("Vehicle Mods", "parent", g.o.prnt.veh.id)



		g._spawn_veh_options=menu_add_player_feature("Options", "parent", g.o.prnt.spwn.id)

		g._spawn_veh_search_p=menu_add_player_feature("Search for Make/Model", "parent", g.o.prnt.spwn.id)


	g.tbl.online_veh_grief = {}
	g.tbl.online_veh_grief.list = {}
	g.tbl.online_veh_grief.list.STR = 	{"Kick from veh",	 "Destroy","Freeze","TP away",		"Fuck their veh","Random force", "Launch"}
	g.tbl.online_veh_grief.list.A = 	{"kick_pid_from_veh","destroy","freeze","tp",	  		"fucked",		 "random_force", "float"}
	g.tbl.online_veh_grief.list.V = 	{[0]=pid,					   [2]=0,   [3]="anywhere",					 [5]=25,		 [6]=500}
	g.tbl.online_veh_grief.feats = {}
	g.tbl.online_veh_grief.msg = {}
	for i=1,#g.tbl.online_veh_grief.list.STR do
		g.tbl.online_veh_grief.msg[g.tbl.online_veh_grief.list.A[i]]=g.tbl.online_veh_grief.list.STR[i]
	end
	for i=0,31 do
		g.tbl.online_veh_grief[i]={}
	end

	function funcs.doo.online_veh_grief_set(_bool,_hash,_pid,_f_val)
		if _bool then
			g.tbl.online_veh_grief[_pid][_hash]={
				A = g.tbl.online_veh_grief.list.A[_f_val+1],
				V = g.tbl.online_veh_grief.list.V[_f_val]
			}
		else
			g.tbl.online_veh_grief[_pid][_hash]=false
		end

	end
	g.tbl.online_veh_grief.feats.main=menu_add_player_feature("Vehicle grief", "toggle", g._VehicleGrief_p.id, function(f,pid)

		local time = TIME_MS()-1
		local fails = 0
		local action,val
		while f.on do
			if API.plyr.is.in_veh(pid) and g.tbl.online_veh_grief[pid][API.ent.get.model_hash(API.plyr.get.veh(pid))] and time < TIME_MS() then
				action =  g.tbl.online_veh_grief[pid][API.ent.get.model_hash(API.plyr.get.veh(pid))].A
				if action == "kick_pid_from_veh" then
					val = pid
				else
					val =  g.tbl.online_veh_grief[pid][API.ent.get.model_hash(API.plyr.get.veh(pid))].V
				end
				if (action ~= "tp" and funcs.is.sssn_veh_action_chk(API.plyr.get.veh(pid),action,val)) or (action == "tp" and funcs.get.dist_me_pid_3d(pid) < 500) then
					if funcs.doo.veh_action_list(API.plyr.get.veh(pid),2000,action,val) then
						time = TIME_MS()
						fails=0
					else
						time = TIME_MS() + fails
						if fails == 0 then
							g.N_P(2,funcs.get.pid_name(pid).."\n"..g.tbl.online_veh_grief.msg[action].." FAILED :(",__GV__,5,"Red")
						end
						fails=fails+1500
					end
				end
			else
				time = TIME_MS()
				fails=0
			end
			funcs.doo.yield_while_true(f.on,2000)
		end
	end)

	g.tbl.online_veh_grief.feats.avngr=og_menu_add_player_feature("Avenger", "value_str", g._VehicleGrief_p.id, function(f,pid)
		funcs.doo.online_veh_grief_set(f.on,API.get_hash_key("avenger"),pid,f.value)
		funcs.doo.online_veh_grief_set(f.on,API.get_hash_key("avenger2"),pid,f.value)
	end)
	new_set_str_data(g.tbl.online_veh_grief.feats.avngr,g.tbl.online_veh_grief.list.STR)

	for i=1,#veh_stuff.grief-2 do
		if i > 2 then
			g.tbl.online_veh_grief.feats[i]=og_menu_add_player_feature(veh_stuff.grief[i][3], "value_str", g._VehicleGrief_p.id,function(f,pid)
				funcs.doo.online_veh_grief_set(f.on,veh_stuff.grief[i][1],pid,f.value)
			end)
			new_set_str_data(g.tbl.online_veh_grief.feats[i],g.tbl.online_veh_grief.list.STR)
		end
	end

	g.tbl.online_veh_grief.feats.ramp=og_menu_add_player_feature("Ramp Buggy", "value_str", g._VehicleGrief_p.id, function(f,pid)
		funcs.doo.online_veh_grief_set(f.on,API.get_hash_key("dune4"),pid,f.value)
		funcs.doo.online_veh_grief_set(f.on,API.get_hash_key("dune5"),pid,f.value)
	end)
	new_set_str_data(g.tbl.online_veh_grief.feats.ramp,g.tbl.online_veh_grief.list.STR)

	g.print_load_info("Player vehicle grief",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Player vehicle spawns"
	g.tbl.spawn_veh_search_p_feat = {}
	g.tbl.spawn_veh_search_p_temp = {}
	g._spawn_veh_search_do_p=menu_add_player_feature("Search for Make/Model", "action_value_str", g._spawn_veh_search_p.id, function(f)
		local status,str,veh = 1
		status,str = funcs.get.text_input("Vehicle Make/Model","",25,0)
		if status == 0 then
			g.tbl.spawn_veh_search_p_temp = {}
			g.tbl.spwn.ovrly_srch_do(str,f.value,g.tbl.spawn_veh_search_p_temp)
			if #g.tbl.spawn_veh_search_p_temp > 0 then
				for i=1,#g.tbl.spawn_veh_search_p_feat do
					YIELD(0)
					if g.tbl.spawn_veh_search_p_feat[i] ~= nil then menu.delete_player_feature(g.tbl.spawn_veh_search_p_feat[i].id) end
				end
				g.tbl.spawn_veh_search_p_feat = {}
				for i=1,#g.tbl.spawn_veh_search_p_temp do
					if f.value == 0 then
						g.tbl.spawn_veh_search_p_feat[#g.tbl.spawn_veh_search_p_feat+1]=og_menu_add_player_feature(g.tbl.spawn_veh_search_p_temp[i][1], "action", g._spawn_veh_search_p.id,function(f,pid)
							if intrr.is_pid_intrr(pid) then
								g.N_P(2,funcs.get.pid_name(pid) .. "\nIn interior.",__GV__,4,"Blue")
							else
								funcs.doo.req_model(g.tbl.spawn_veh_search_p_temp[i][5])
								local veh = funcs.doo.spawn_veh_at_pid(pid,g.tbl.spawn_veh_search_p_temp[i][5],true)
							end
						end)
					else
						g.tbl.spawn_veh_search_p_feat[#g.tbl.spawn_veh_search_p_feat+1]=og_menu_add_player_feature(g.tbl.spawn_veh_search_p_temp[i][3], "action", g._spawn_veh_search_p.id,function(f,pid)
							if intrr.is_pid_intrr(pid) then
								g.N_P(2,funcs.get.pid_name(pid) .. "\nIn interior.",__GV__,4,"Blue")
							else
								funcs.doo.req_model(g.tbl.spawn_veh_search_p_temp[i][5])
								local veh = funcs.doo.spawn_veh_at_pid(pid,g.tbl.spawn_veh_search_p_temp[i][5],true)
							end
						end)
					end
				end
			end
		end
	end)
	new_set_str_data(g._spawn_veh_search_do_p,{"Model", "Make","Make or Model"})



	g.print_load_info("Player vehicle spawns",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Player actions"
	g.o.feat.super_crash=menu_add_player_feature("Super Crash", "action_value_str", g.o.prnt.plyr.id, function(f,pid)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local was_on = g.o.tbl.spectate[pid].on
			local turn_on = f.value == 0
			local pid = pid
			local all_veh =  API.veh.get.all()
			local t = {}
			for i=1,#all_veh do
				local ent = API.veh.get.ped_in_seat(all_veh[i], -1)
				if ent and not API.Ped.is.plyr(ent) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local _ent,_veh,_pid = ent,all_veh[i],pid
						if funcs.ntwrk.ask_long(_ent, 1200) and API.plyr.is.valid(_pid) then
							t[_veh]=true
							API.ent.set.coords(_veh,API.plyr.get.coords(_pid)+funcs.vec(mth.rndm(50,50),mth.rndm(50,50),200))
						end
					end)
				end
			end
			if turn_on and not was_on then
				g.o.tbl.spectate[pid].on = true
				YIELD(1250)
			end
			for k, v in pairs(t) do
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local _veh,_pid = k,pid
					if funcs.ntwrk.ask_long(_veh, 500) and API.plyr.is.valid(_pid) then
						API.ent.set.coords(_veh,API.plyr.get.coords(_pid)+funcs.vec(mth.rndm(5,5),mth.rndm(5,5),1))
					end
				end)
			end
			all_veh =  API.veh.get.all()
			for i=1,#all_veh do
				local ent = API.veh.get.ped_in_seat(all_veh[i], -1)
				if ent and not t[all_veh[i]] and not API.Ped.is.plyr(ent) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local _veh,_pid = all_veh[i],pid
						if funcs.ntwrk.ask_long(_veh, 500) and API.plyr.is.valid(_pid) then
							API.ent.set.coords(_veh,API.plyr.get.coords(_pid)+funcs.vec(mth.rndm(5,5),mth.rndm(5,5),1))
						end
					end)
				end
			end
			YIELD(550)
			for k,v in pairs(g.o.tbl.crashes[pid]) do
				v:toggle()
			end
			if turn_on and not was_on then
				local time = TIME_MS() + 5000
				while API.plyr.is.valid(pid) and time > TIME_MS() do
					YIELD(100)
				end
				g.o.tbl.spectate[pid].on = false
			end
		end)
		YIELD(6000)
	end)
	new_set_str_data(g.o.feat.super_crash,{"With spectate","Without spectate"})

	menu_add_player_feature("Send the plague", "toggle", g.o.prnt.plyr_attacks.id, function(f,pid)
		local rats = {}
		local rat_hash = API.get_hash_key("A_C_Rat")
		while f.on do
			for i=1,10 do
				if not API.ent.is.dead(API.plyr.get.ped(pid)) and (not funcs.is.ent(rats[i]) or API.ent.is.dead(rats[i])) then
					funcs.doo.req_model(rat_hash)
					rats[i]=funcs.doo.spawn_ped_angry(API.plyr.get.coords(pid)+funcs.vec(mth.rndm(-25,25),mth.rndm(-25,25),1),rat_hash,nil,nil,pid,nil)
					funcs.doo.plague_attack(rats[i],API.plyr.get.ped(pid),f)
					YIELD(50)
				end
			end
			YIELD(500)
		end
	end)

	g.o.feat.suicide_bomber=menu_add_player_feature("Suicide bomber", "toggle", g.o.prnt.plyr_attacks.id, function(f,pid)
		local ped_hash = API.get_hash_key("mp_m_freemode_01")
		local spawn_points,points2,terrorist,blip,pos,p_crds
		while f.on do
			if not funcs.is.dead(pid) and (not funcs.is.ent(terrorist) or funcs.is.dead(terrorist)) then
				pos = nil
				p_crds = API.plyr.get.coords(pid)
				spawn_points = funcs.get.spawn_points(p_crds,25)
				points2 = {}
				for k,v in pairs (spawn_points) do
					points2[#points2+1]={funcs.get.dist_pospos_v3(v,p_crds),v}
				end
				table.sort(points2, function(a, b) return a[1]<b[1]  end)
				for k,v in ipairs (points2) do
					if v[1] > 50 then
						pos = v[2]
						break
					end
				end

				pos = pos or points2[#points2][2]
				funcs.doo.req_model(ped_hash)
				terrorist=funcs.doo.spawn_ped_angry(pos,ped_hash,nil,nil,pid,nil,200)
				YIELD(0)
				if funcs.is.ent(terrorist) then
					ped.set_ped_component_variation(terrorist, 6, 34, 0, 0)
					ped.set_ped_component_variation(terrorist, 1, 115, 8, 0)
					ped.set_ped_component_variation(terrorist, 11, 114, 0, 0)
					ped.set_ped_component_variation(terrorist, 4, 56, 0, 0)
					ped.set_ped_component_variation(terrorist, 9, 10, 1, 0)
					ped.set_ped_component_variation(terrorist, 2, 38, 0, 0)
					ped.set_ped_component_variation(terrorist, 8, 14, 0, 0)
					ped.set_ped_component_variation(terrorist, 3, 4, 0, 0)
					ped.set_ped_head_blend_data(terrorist, 5, 6, 0, 9, 0, 0, 0.25, 0, 0)
					blip = ui.add_blip_for_entity(terrorist)
					ui.set_blip_colour(blip, 1)
					ntv.set.blip_scale(blip,0.69)
					g.tbl.unaffected_ents[terrorist]=true
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local pid,terrorist,f=pid,terrorist,f
						local p_crds,t_crds
						while f.on and funcs.is.ent(terrorist) and not funcs.is.dead(terrorist) and API.plyr.is.valid(pid) do
							if not funcs.is.dead(pid) then
								p_crds,t_crds = API.plyr.get.coords(pid),API.ent.get.coords(terrorist)
								if funcs.get.dist_pospos_v3(p_crds,t_crds) < 2 then
									fire.add_explosion(t_crds, 47, true, false, 0, pid)
									YIELD(500)
								elseif funcs.is.peds_have_los(terrorist,API.plyr.get.ped(pid)) then
									local trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(p_crds,t_crds,0.169)
									API.ent.set.rotation(terrorist,funcs.get.vctr_to_pos(p_crds,terrorist))
									API.ent.set.velocity(terrorist,trgt_crds_do)
								else
									while f.on and funcs.is.ent(terrorist) and not funcs.is.dead(terrorist) and API.plyr.is.valid(pid) and not funcs.is.dead(pid) and not funcs.is.peds_have_los(terrorist,API.plyr.get.ped(pid)) do
										ai.task_combat_ped(terrorist, API.plyr.get.ped(pid), 0, 16)
										YIELD(2000)
									end
								end
							end
							YIELD(0)
						end
						YIELD(3000)
						funcs.doo.remove_ent(terrorist,3000)
					end)
				end
			end
			YIELD(100)
		end

	end)


	-- g.o.feat.bmx_slap=menu_add_player_feature("BMX slap", "value_str", g.o.prnt.plyr_attacks.id, function(f,pid) --original version
		-- local veh_hash,ENT,p_crds,bike = API.get_hash_key("bmx")
		-- while f.on do
			-- funcs.doo.req_model(veh_hash)
			-- ENT = funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))
			-- p_crds = API.ent.get.coords(ENT)
			-- bike = funcs.doo.spawn_veh(p_crds + funcs.vec(mth.rndm(-25,25),mth.rndm(-25,25),mth.rndm(0,5)),veh_hash,false,nil,true,true,false)
			-- if funcs.is.veh(bike) and ntv.is.ents_in_los(bike,ENT,17,false) then
				-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					-- local bike,p_crds,f,ENT,speed = bike,p_crds,f,ENT,trgt_crds_do,vec_to_trgt
					-- API.ent.set.max_speed(bike, 45000)
					-- local time = TIME_MS()+3000
					-- while time > TIME_MS() and funcs.is.veh(bike) and funcs.is.ent(ENT) and not ntv.is.ents_touch(bike,ENT) do
						-- speed = API.ent.get.speed(ENT)*0.05
						-- speed = speed < 1 and  1 or speed
						-- trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(p_crds+API.ent.get.velocity(ENT)*0.25,API.ent.get.coords(bike),speed)
						-- API.ent.set.max_speed(bike, 45000)
						-- API.ent.set.velocity(bike,trgt_crds_do)
						-- YIELD(0)
					-- end
					-- YIELD(time - TIME_MS())
					-- funcs.doo.remove_ent(bike,5000)
				-- end)
				-- funcs.doo.yield_while_true2(f,f.value==0 and 3000 or 666)
			-- else
				-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					-- funcs.doo.remove_ent(bike,5000)
				-- end)
			-- end
			-- YIELD(0)
		-- end
	-- end)
	-- new_set_str_data(g.o.feat.bmx_slap,{"Slow","Fast"})

	g.o.feat.bmx_slap=menu_add_player_feature("BMX slap", "value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		local veh_hash,ped_hash,bike = API.get_hash_key("bmx"), API.get_hash_key("a_f_m_fatcult_01")
		while f.on do
			funcs.doo.req_model(veh_hash)
			bike = funcs.doo.spawn_veh(API.ent.get.coords(funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))) + funcs.vec(mth.rndm(-25,25),mth.rndm(-25,25),mth.rndm(0,5)),veh_hash,false,nil,true,true,false)
			if funcs.is.veh(bike) then
				if ntv.is.ents_in_los(bike,funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid)),17,false) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local bike = bike
						local speed,trgt_crds_do
						local ENT = funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))
						local time = TIME_MS()+3000
						local switch_type = false
						funcs.doo.req_model(ped_hash)
						local bitch=ntv.doo.create_ped_in_veh(bike,6,ped_hash,-1,1,0)
						YIELD(0)
						if funcs.is.ent(bitch) then
							funcs.doo.id_migrate(bitch,0)
							ntv.set.ped_no_high_fall_damage(bitch,1)
							funcs.doo.ped_combat_attrib(bitch,true)
							ntv.set.ped_critical_dmg(bitch,0)
							funcs.doo.ped_ragdoll(bitch,false,50)
							g.tbl.entities[#g.tbl.entities+1]=bitch
						end
						while f.on and API.plyr.is.valid(pid) and time > TIME_MS() and funcs.is.ent(bike) and funcs.is.ent(ENT) and not ntv.is.ents_touch(bike,ENT) and funcs.get.dist_entent_v3(bike,ENT)>0.25 do
							speed = API.ent.get.speed(ENT)*0.05
							speed = speed < 1 and  1 or speed
							switch_type = (not switch_type)
							if switch_type then
								trgt_crds_do = g.tbl.a_b.get_movement(API.ent.get.coords(ENT),API.ent.get.coords(bike),speed) --the player's current coords
							else
								trgt_crds_do = g.tbl.a_b.get_movement(API.ent.get.coords(ENT)+API.ent.get.velocity(ENT)*0.25,API.ent.get.coords(bike),speed) --the player's predicted coords
							end
							API.ent.set.max_speed(bike, 45000)
							API.ent.set.velocity(bike,trgt_crds_do)
							ENT = funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))
							YIELD(0)
						end
						YIELD(500)
						funcs.doo.remove_ent(bitch,5000)
						funcs.doo.remove_ent(bike,5000)


					end)
					funcs.doo.yield_while_true2(f,f.value==0 and 3000 or 666)
				else
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						funcs.doo.remove_ent(bike,5000)
					end)
				end
			else
				funcs.doo.yield_while_true2(f,3000)
			end
			YIELD(0)
		end
	end)
	new_set_str_data(g.o.feat.bmx_slap,{"Slow","Fast"})

	menu_add_player_feature("Cat Magnet", "toggle", g.o.prnt.plyr_trolls.id, function(f,pid)
		local ped_hash,cat = 1462895032
		while f.on do
			funcs.doo.req_model(ped_hash)
			cat = API.Ped.create(6, ped_hash,API.ent.get.coords(funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))) + funcs.vec(mth.rndm(-25,25),mth.rndm(-25,25),mth.rndm(0,5)), mth.rndm(0,359), true, false)
			if funcs.is.ent(cat) then
				funcs.doo.id_migrate(cat,0)
				if ntv.is.ents_in_los(cat,funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid)),17,false) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local cat = cat
						local speed,trgt_crds_do,dist,cat_coords,ENT_coords,rot,predicted_coords,velocity
						local ENT = funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))
						local time = TIME_MS()+15000
						ntv.set.ped_no_high_fall_damage(cat,1)
						funcs.doo.ped_combat_attrib(cat,true)
						ntv.set.ped_critical_dmg(cat,0)
						funcs.doo.ped_ragdoll(cat,false,50)
						g.tbl.entities[#g.tbl.entities+1]=cat
						while f.on and time > TIME_MS() and API.plyr.is.valid(pid) and funcs.is.ent(cat) and funcs.is.ent(ENT) and ntv.is.ents_in_los(cat,ENT,17,false) do
							cat_coords = API.ent.get.coords(cat)
							ENT_coords = API.ent.get.coords(ENT)
							velocity = API.ent.get.velocity(ENT)
							predicted_coords = ENT_coords+velocity*0.25
							dist = cat_coords:magnitude(predicted_coords)
							speed = dist/30
							trgt_crds_do = g.tbl.a_b.get_movement(ENT_coords+velocity*0.1,cat_coords,speed)
							API.ent.set.max_speed(cat, 45000)
							rot = API.ent.get.rotation(cat)
							rot.x=rot.x+1
							rot.y=rot.y+1
							rot.z=rot.z+1
							API.ent.set.rotation(cat,rot)
							API.ent.set.velocity(cat,trgt_crds_do)
							ENT = funcs.get.ped_veh_or_ped(API.plyr.get.ped(pid))
							YIELD(0)
						end
						funcs.doo.remove_ent(cat,5000)
					end)
					funcs.doo.yield_while_true2(f,1000)
				else
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						funcs.doo.remove_ent(cat,5000)
					end)
				end
			else
				funcs.doo.yield_while_true2(f,3000)
			end
			YIELD(0)
		end
	end)

	function funcs.doo.plague_attack(__perp,__vctm,f)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local pos,dist,have_los,los_time,vctm_inair,coords
			local function should_tp()
				if  dist > 50 then
					return true
				elseif not have_los then
					if los_time == nil then
						los_time = API.util.t_s()+15
					elseif los_time < API.util.t_s() then
						los_time = API.util.t_s()+15
						return true
					end
				else
					los_time = API.util.t_s()+15
				end
				return false
			end
			while f.on and funcs.is.ped(__perp) and not API.ent.is.dead(__perp) and funcs.is.ped(__vctm) do
				coords = API.ent.get.coords(__perp)
				dist = funcs.get.dist_pospos_v3(coords,API.ent.get.coords(__vctm))
				have_los = funcs.is.peds_have_los(__perp,__vctm)
				vctm_inair = (API.ent.is.in_air(__vctm) or (API.Ped.is.in_veh(__vctm) and API.ent.is.in_air(API.Ped.get.veh(__vctm))))
				if should_tp() then
					if vctm_inair then
						pos = funcs.get.pos_nearby2(API.Ped.is.plyr(__vctm) and funcs.get.pid_pos_z_guess(API.plyr.get.plyr_from_ped(__vctm)) or API.ent.get.coords(__vctm),10,false)
					elseif API.Ped.is.plyr(__vctm) then
						pos = funcs.get.pid_pos_z_guess(API.plyr.get.plyr_from_ped(__vctm))
					else
						pos = coords+funcs.vec(0,0,0)
					end
					if funcs.ntwrk.ask_long(__perp,1000) then
						API.ent.set.coords(__perp,pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),1))
						los_time = API.util.t_s()+15
					end
				elseif dist < 6.9 and not API.ent.is.in_air(__perp) and not API.Ped.is.ragdoll(__perp) and not API.ent.is.dead(__vctm) then
					gameplay.shoot_single_bullet_between_coords(coords, API.ent.get.coords(__vctm)+funcs.vec(0,0,-0.5), 1,API.get_hash_key("weapon_rpg"),__perp, true, false, 1000)
				end
				ai.task_combat_ped(__perp, __vctm,0,16)
				YIELD(1000)
			end
			funcs.doo.remove_ent(__perp,1000)
		end)
	end


	g._PlyrPed_shroud=menu_add_player_feature("Shroud player in smoke", "toggle", g.o.prnt.plyr_trolls.id, function(f,pid)
		g._PlyrPed_fire.on=false
		g._PlyrPed_water.on=false
		g._PlyrPed_flare.on=false
		local time = TIME_MS() + 1000
		local point1,point2,random_head
		while f.on do
			YIELD(0)
			if TIME_MS() < time then
				point1=mth.rndm(-1500,2000)*0.001 --elevation
				point2=mth.rndm(1000,2000)*0.001 -- distance
				random_head = mth.rndm(0,359) -- degrees
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,19, 25)
				point1=mth.rndm(-250,750)*0.001 --elevation
				point2=mth.rndm(1000,2000)*0.001 -- distance
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,79, 25)
			else
				funcs.doo.delay(200)
				time = TIME_MS() + 1000
			end
		end
	end)

	g._PlyrPed_flare=menu_add_player_feature("Bedazzle with flares (Blinding lag)", "toggle", g.o.prnt.plyr_trolls.id, function(f,pid)
		g._PlyrPed_fire.on=false
		g._PlyrPed_water.on=false
		g._PlyrPed_shroud.on=false
		local time = TIME_MS() + 1000
		local point1,point2,random_head
		while f.on do
			YIELD(0)
			if TIME_MS() < time then
				point1=mth.rndm(-500,1500)*0.001 --elevation
				point2=mth.rndm(100,2000)*0.001 -- distance
				random_head = mth.rndm(0,359) -- degrees
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,22, 25)
				point1=mth.rndm(1300)*0.001 --elevation
				point2=mth.rndm(2000,3000)*0.001 -- distance
				random_head = mth.rndm(185,190) -- degrees
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,22, 25)
			else
				funcs.doo.delay(50)
				time = TIME_MS() + 1000
			end
		end
	end)

	g._PlyrPed_water=menu_add_player_feature("Spam with water", "toggle", g.o.prnt.plyr_trolls.id, function(f,pid)
		g._PlyrPed_fire.on=false
		g._PlyrPed_flare.on=false
		g._PlyrPed_shroud.on=false
		local time = TIME_MS() + 1000
		local point1,point2,random_head
		while f.on do
			YIELD(0)
			if TIME_MS() < time then
				point1=mth.rndm(-3000,-1000)*0.001 --elevation
				point2=mth.rndm(500,1500)*0.001 -- distance
				random_head = mth.rndm(0,359) -- degrees
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,13, 250)
			else
				funcs.doo.delay(50)
				time = TIME_MS() + 1000
			end
		end
	end)

	g._PlyrPed_fire=menu_add_player_feature("Circle of fire", "toggle", g.o.prnt.plyr_trolls.id, function(f,pid)
		g._PlyrPed_water.on=false
		g._PlyrPed_flare.on=false
		g._PlyrPed_shroud.on=false
		local time = TIME_MS() + 1000
		local point1,point2,random_head
		while f.on do
			YIELD(0)
			if TIME_MS() < time then
				random_head = mth.rndm(0,359) -- degrees
				funcs.doo.expl_ent_pid(pid, -1, random_head, -4,12, 25)
				point1=mth.rndm(-500,1500)*0.001 --elevation
				point2 = mth.rndm(4,5) --distance
				funcs.doo.expl_ent_pid(pid, point1, random_head, point2,3, 25)
			else
				funcs.doo.delay(200)
				time = TIME_MS() + 1000
			end
		end
	end)

	g.o.tbl.cages = {}
	for i=0,31 do
		g.o.tbl.cages[i]={}
	end


	g.o.feat.big_cage=menu_add_player_feature("BIG Cage", "value_str", g.o.prnt.plyr_trolls.id, function(f,pid)
		-- [3883058484] = {
			-- model = bkr_prop_biker_bblock_huge_01,
			-- min = {x = -16.307489395142, y = -22.193475723267, z = -0.80736923217773},
			-- max = {x = 16.307489395142, y = 22.193475723267, z = 0.20263075828552}
		-- },
		if f.on then
			g.o.tbl.cages[pid] = {}
			local ent = API.plyr.is.in_veh(pid) and API.plyr.get.veh(pid) or API.plyr.get.ped(pid)
			local x = 16.307489395142
			local y = 22.193475723267
			local pos = funcs.get.pid_vel_pos(pid,0.1)+funcs.vec(0,0, API.ent.is.in_air(ent) and -x or -3)
			local hash = API.get_hash_key("bkr_prop_biker_bblock_huge_01")
			funcs.doo.req_model(hash)
			g.o.tbl.cages[pid][1] =  funcs.doo.spawn_obj(hash, pos,							funcs.vec(0,0,0),	true,false,0,f.value==0)
			g.o.tbl.cages[pid][2] =  funcs.doo.spawn_obj(hash, pos + funcs.vec(x,	0,	x), 	funcs.vec(0, -90, 0),	true,false,0,f.value==0)
			g.o.tbl.cages[pid][3] =  funcs.doo.spawn_obj(hash, pos + funcs.vec(-x,	0,	x), 	funcs.vec(0, 90, 0),	true,false,0,f.value==0)
			g.o.tbl.cages[pid][4] =  funcs.doo.spawn_obj(hash, pos + funcs.vec(0,	0,	2*x), 	funcs.vec(0, 0, 0),	true,false,0,f.value==0)
			g.o.tbl.cages[pid][5] =  funcs.doo.spawn_obj(hash, pos + funcs.vec(0,	y,	x), 	funcs.vec(90, 0, 0),	true,false,0,f.value==0)
			g.o.tbl.cages[pid][6] =  funcs.doo.spawn_obj(hash, pos + funcs.vec(0,	-y,	x), 	funcs.vec(-90, 0, 0),	true,false,0,f.value==0)
			g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function() --in a thread to  remove cage if  the player leaves
				local f,pid = f,pid
				while f.on and API.plyr.is.valid(pid) do
					for i=1,6 do
						if funcs.is.ent(g.o.tbl.cages[pid][i]) and API.ent.is.visible(g.o.tbl.cages[pid][i]) ~= (f.value == 0) then
							API.ent.set.visible(g.o.tbl.cages[pid][i],f.value == 0)
						end
					end
					YIELD(100)
				end
				for i=1,#g.o.tbl.cages[pid] do
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						funcs.doo.remove_ent(g.o.tbl.cages[pid][i],5000)
					end)
				end
			end)
			while f.on do
				YIELD(0)
			end
		end
	end)
	new_set_str_data(g.o.feat.big_cage,{"Visible","Invisible"})

	g.o.feat.big_cage_move=menu_add_player_feature("Move Cage", "value_str", g.o.prnt.plyr_trolls.id, function(f,pid)
		while f.on do
			for i=1,6 do
				if funcs.is.ent(g.o.tbl.cages[pid][i]) then
					API.ent.set.coords(g.o.tbl.cages[pid][i],API.ent.get.coords(g.o.tbl.cages[pid][i]) + funcs.vec(0,0,f.value == 0 and  .0069 or -.0069))
				end
			end
			YIELD(0)
		end
	end)
	new_set_str_data(g.o.feat.big_cage_move,{"Up","Down"})

	g.o.feat.kamekaze=menu_add_player_feature("Kamikaze planes", "value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		local pilot,veh={},{}
		local veh_hash = API.get_hash_key("duster")
		local ped_hash = API.get_hash_key("a_f_m_fatcult_01")
		while f.on do
			for i=1,3 do
				if f.on and not funcs.is.ent(veh[i]) or funcs.is.dead(veh[i]) then
					funcs.doo.req_model(veh_hash)
					veh[i] = funcs.doo.spawn_veh(API.plyr.get.coords(pid)+funcs.vec(mth.rndm(-500,500),mth.rndm(-500,500),500),veh_hash,true,0,true,true)
					YIELD(0)
					if funcs.is.veh(veh[i]) then
						g.tbl.unaffected_ents[veh[i]]=true
						funcs.doo.req_model(ped_hash)
						pilot[i] = funcs.doo.spawn_ped_angry(API.plyr.get.coords(pid)+funcs.vec(mth.rndm(-500,500),mth.rndm(-500,500),500),ped_hash,nil,nil,pid,veh[i])
						YIELD(0)
						if funcs.is.ped(pilot[i]) then
							g.tbl.unaffected_ents[pilot[i]]=true
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								local pid,vehh,pilot,f=pid,veh[i],pilot[i],f
								local pped = API.plyr.get.ped(pid)
								while f.on and funcs.is.ent(vehh) and not funcs.is.dead(vehh) and API.plyr.is.valid(pid) do
									if funcs.is.peds_have_los(pilot,pped) then
										local trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(API.plyr.get.coords(pid),API.ent.get.coords(vehh),f.value == 0 and 0.5 or 2.5)
										API.ent.set.rotation(vehh,funcs.get.vctr_to_pos(API.plyr.get.coords(pid),vehh))
										API.ent.set.velocity(vehh,trgt_crds_do)
									end
									YIELD(0)
								end
								YIELD(3000)
								funcs.doo.remove_ent(vehh,3000)
								funcs.doo.remove_ent(pilot,3000)
							end)
							funcs.doo.yield_while_true2(f,2500)
						end
					end
				end
			end
			funcs.doo.yield_while_true2(f,1000)
		end

	end)
	new_set_str_data(g.o.feat.kamekaze,{"Slow","Fast"})

	menu_add_player_feature("Give OTR", "action",g.o.prnt.plyr.id, function(f,pid)
		if glbls.is_pid_otr(pid) then
			g.N_P(2,funcs.get.pid_name(pid) .. "\nPlayer already off the radar.",__GV__,4,"Blue")
		else
			glbls.give_otr(pid)
		end
	end)


	g._PlyrPed_wntd = menu_add_player_feature("Set wanted level", "value_i",g.o.prnt.plyr.id, function(f,pid)
		while f.on do
			YIELD(100)
			funcs.doo.wntd_all_psngrs(pid,f.value)
		end
	end)
	funcs.set_feat_i_f(g._PlyrPed_wntd,0,5,1,0)

	g.o._mod_toggle=menu_add_player_feature("Modder flag toggle", "action_value_str", g.o.prnt.plyr.id, function(f,pid)
		if API.plyr.is.modder(pid,mddrs.str_is_int[f.str_data[f.value+1]]) then
			player.unset_player_as_modder(pid,mddrs.str_is_int[f.str_data[f.value+1]])
		elseif player.can_player_be_modder(pid) then
			player.set_player_as_modder(pid,mddrs.str_is_int[f.str_data[f.value+1]])
		else
			g.N_P(2,funcs.get.pid_name(pid) .. "\nCannot be marked as modder.",__GV__,4,"Blue")
		end
	end)
	new_set_str_data(g.o._mod_toggle,mddrs.str)

	g.o._mod_all_toggle=menu_add_player_feature("Modder flags - All", "action_value_str", g.o.prnt.plyr.id, function(f,pid)
		if f.value == 0 then
			if player.can_player_be_modder(pid) then
				for k,v in pairs (mddrs.list) do
					player.set_player_as_modder(pid,k)
				end
			else
				g.N_P(2,funcs.get.pid_name(pid) .. "\nCannot be marked as modder.",__GV__,4,"Blue")
			end
		else
			for k,v in pairs (mddrs.list) do
				player.unset_player_as_modder(pid,k)
			end
		end
	end)
	new_set_str_data(g.o._mod_all_toggle,{"Set","Un-set"})

	g.o._drop_sparrows=menu_add_player_feature("Drop sparrows", "action_value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,false,(f.value*9*3000)+3500,"sparrow",nil,(f.value*9)+1,nil)
	end)
	new_set_str_data(g.o._drop_sparrows,{"One", "Many"})

	g.o._plyr_burn=menu_add_player_feature("Burn player", "action_value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		local t = {funcs.ME._id(),pid}
		funcs.doo.online_plyr_start(pid,false,1000,"burn",3,10,t[f.value+1])
	end)
	new_set_str_data(g.o._plyr_burn,{"Blame me","Blame them"})

	g.o._plyr_xpld=menu_add_player_feature("Explode player", "action_value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		local t = {funcs.ME._id(),pid}
		funcs.doo.online_plyr_start(pid,false,1000,"explode",40,10,t[f.value+1])
	end)
	new_set_str_data(g.o._plyr_xpld,{"Blame me","Blame them"})

	g.o._plyr_fat_bitches=menu_add_player_feature("Spawn angry fat bitch", "action_value_str", g.o.prnt.plyr_attacks.id, function(f,pid)
		local t = {"bmx","deathbike2","toreador","rhino","phantom2","strikeforce","buzzard","foot"}
		funcs.doo.online_plyr_start(pid,false,1000,"fat_bitches",t[f.value+1],1,nil)
	end)
	new_set_str_data(g.o._plyr_fat_bitches,{"On bicycle","On motorcycle","In Toreador","In Rhino","In Phantom Wedge","In B-11 Strikeforce","In Buzzard","On foot"})

	g.o._plyr_kick=menu_add_player_feature("Kick player", "action_value_str", g.o.prnt.plyr.id, function(f,pid)
		if pid == API.plyr.my_id() then
			g.N_P(2,"Really? You want to kick yourself?",__GV__,4,"Yellow")
		elseif f.value == 0 then
			funcs.doo.kick_plyr(pid)
		elseif f.value == 1 then
			funcs.doo.kick_plyr_org(pid)
		else
			funcs.doo.kick_plyrs_in_veh(pid)
		end
	end)
	new_set_str_data(g.o._plyr_kick,{"Just them", "Their org/mc","Everyone in their car"})


	g.var.last_pid_kicked=-1
	function funcs.doo.kick_plyr(_pid,_auto,_type,k_name,no_kick)
		_auto = _auto or false
		if _pid~=g.var.last_pid_kicked then
			g.var.last_pid_kicked = _pid
			if funcs.is.valid_pid(_pid) then
				local name,scid = funcs.get.pid_name(_pid), API.plyr.get.scid(_pid)
				local date_time = os.date("%Y-%m-%d %H%M-%S")
				if not no_kick then
					if g.feat.kick_if_host.on and network.network_is_host() then
						network.network_session_kick_player(_pid)
					else
						g.o.tbl.kicks[_pid][g.feat.kick_type2.str_data[g.feat.kick_type2.value+1]]()
					end
				end
				local time = TIME_MS()+5000
				while time > TIME_MS() and funcs.is.valid_pid(_pid) do
					YIELD(0)
				end
				if not funcs.is.valid_pid(_pid) then
					funcs.doo.kick_notif(_auto,_type,k_name,name,"Kicked :)","Green")
					g.tbl.pid_kicked_mem[#g.tbl.pid_kicked_mem+1]=scid
					funcs.doo.check_create_dir(g.paths._user)
					funcs.doo.check_create_dir(g.paths._user.."Logs\\")
					funcs.doo.check_create_file(g.paths._user.."Logs\\Player Kicks History.csv",__GV__)
					local file = io.open(g.paths._user.."Logs\\Player Kicks History.csv", "a")
					if file then
						file:write("\n"..date_time..","..scid..","..name)
						file:close()
					else
						funcs.N_P(2,"Could not access Player Kicks History.csv\nDo you have that file open??",__GV__,7,"Red")
					end
					g.var.last_pid_kicked=-1
					return true
				else
					funcs.doo.kick_notif(_auto,_type,k_name,name,"Failed to kick :(","Red")
				end
			elseif not no_kick then
				funcs.N_P(2,"Invalid player!\nFailed to kick :(",__GV__,4,"Red")
			end
			g.var.last_pid_kicked=-1
			return false
		end
	end

	function funcs.doo.kick_notif(_auto,_type,k_name,name,msg,color)
		if _auto then
			if k_name ~= name then
				funcs.N_P(2,_type.."  "..k_name.." / "..name.."\n"..msg,funcs.ver_text,4,color)
			else
				funcs.N_P(2,_type.." - "..name.."\n"..msg,funcs.ver_text,4,color)
			end
		else
			funcs.N_P(2,name.."\n"..msg,funcs.ver_text,4,color)
		end
	end

	function funcs.doo.kick_plyr_org(_pid)
		if g.tbl.PID_INFO.color[_pid+1] > -1 then
			local kick_table = {}
			for pid in funcs.get.all_plys_but_me() do
				if funcs.is.same_orgmc(_pid,pid) and not API.plyr.is.friend(pid) and pid ~= _pid then
					kick_table[#kick_table+1]=pid
				end
			end
			for i=1,#kick_table do
				funcs.doo.kick_plyr(kick_table[i])
			end
			funcs.doo.kick_plyr(_pid)
		else
			funcs.N_P(2,funcs.get.pid_name(_pid).."\nNot in an org/mc.",funcs.ver_text,4,"Yellow")
		end
	end

	function funcs.doo.kick_plyrs_in_veh(_pid)
		if funcs.is.valid_pid(_pid) then
			local kick_table = {}
			if API.plyr.is.in_veh(_pid) then
				local plyr_veh = API.plyr.get.veh(_pid)
				for s = 1, funcs.get.veh_seats(plyr_veh) do
					local seat_check = s-2
					if not funcs.ME._in_seat(plyr_veh,seat_check) and not funcs.is.friend_in_seat(plyr_veh,seat_check) and not funcs.is.this_pid_in_seat(plyr_veh,seat_check,_pid) then
						local plyr =  funcs.get.any_pid_in_seat(plyr_veh,seat_check)
						if plyr > -1 then
							kick_table[#kick_table+1]=plyr
						end
					end
				end
			end
			for i=1,#kick_table do
				funcs.doo.kick_plyr(kick_table[i])
			end
			funcs.doo.kick_plyr(_pid)
		else
			funcs.N_P(2,"Invalid player!\nFailed to kick :(",funcs.ver_text,4,"Red")
		end
	end

	g.print_load_info("Player actions",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Player aim griefs"
g.o.tbl.aim_grief={}
for i=0,31 do
	g.o.tbl.aim_grief[i]={}
end

g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	local action_list = {"kick","weapon","all_weapon","burn","explode","fat_bitch","sparrow"}
	while true do
		for pid=0,31 do
			if API.plyr.is.valid(pid) then
				if funcs.is.pid_aim_at_me(pid) and not g.o.tbl.aim_grief[pid]["active"] then
					for i=1,#action_list do
						if g.o.tbl.aim_grief[pid][action_list[i]] then
							g.o.tbl.aim_grief[pid]["active"]=true
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								local _pid = pid
								local _weap,_weap_once,_weap_done = API.Ped.get.weapon(API.plyr.get.ped(_pid)),false,false
								local til_death,dead,bitch,helo
								local time = TIME_MS() + 3000
								while API.plyr.is.valid(_pid) and not dead and time > TIME_MS() do
									local distance,head,pos = funcs.get.plyr_moving_pos(_pid)
									pos = funcs.get.front_of_pos(pos,head,distance,180,0.25)
									if g.o.tbl.aim_grief[_pid]["kick"] and funcs.doo.kick_plyr(_pid) then
										time = TIME_MS()
									else
										if g.o.tbl.aim_grief[_pid]["weapon"] or g.o.tbl.aim_grief[_pid]["all_weapon"] then
											if not _weap_once then
												_weap_once=true
												if g.o.tbl.aim_grief[_pid]["weapon"] then
													API.wpn.ped_remove(API.plyr.get.ped(_pid), _weap)
												else
													menu.get_feature_by_hierarchy_key("online.online_players.player_".._pid..".weapons.remove_all_weapons"):toggle()
												end
											elseif not _weap_done then
												_weap_done=true
												g.N_P(2,funcs.get.pid_name(_pid).."\nWeapon(s) removed :)",__GV__,5,"Green")
											elseif not til_death then
												time = TIME_MS()
											end
										end
										if g.o.tbl.aim_grief[_pid]["burn"] then
											til_death=true
											fire.add_explosion(pos, 3, true, false, 0, _pid)
										end
										if g.o.tbl.aim_grief[_pid]["explode"] then
											til_death=true
											fire.add_explosion(pos, 2, true, false, 0, _pid)
										end
										if g.o.tbl.aim_grief[_pid]["fat_bitch"] and not funcs.is.ent(bitch) then
											til_death=true
											funcs.doo.req_model(API.get_hash_key("a_f_m_fatcult_01"))
											bitch=funcs.doo.spawn_ped_angry(pos+funcs.vec(1,1,0),API.get_hash_key("a_f_m_fatcult_01"),API.get_hash_key("weapon_machinepistol"),API.get_hash_key("weapon_gusenberg"),_pid,nil)
											YIELD(0)
											if funcs.is.ent(bitch) then
												g.tbl.unaffected_ents[bitch]=true
												funcs.doo.set_ped_health(bitch,2500,50)
												funcs.doo.ped_attack_ped_thread(bitch,API.plyr.get.ped(_pid),true,true)
											end
										end
										if g.o.tbl.aim_grief[_pid]["sparrow"] and not funcs.is.ent(helo) then
											til_death=true
											funcs.doo.req_model(1229411063)
											helo = funcs.doo.spawn_veh(pos+funcs.vec(0,0,30),1229411063,nil,nil,true)
											YIELD(0)
											if funcs.is.ent(helo) then
												g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
													local _helo,__pid = helo,_pid
													API.veh.set.engine_health(_helo, -4000)
													ntv.set.veh_body_health(_helo,0)
													API.veh.set.out_of_control(_helo, false, true)
													funcs.doo.ent_seek_pid(_helo,__pid,60)
													funcs.doo.remove_ent(_helo,1000)
												end)
											end
										end
									end
									YIELD(250)
									dead=(til_death and API.plyr.is.valid(_pid) and API.ent.is.dead(API.plyr.get.ped(_pid)))
									if dead then
										g.N_P(2,funcs.get.pid_name(_pid).."\nMurdered :)",__GV__,5,"Green")
									end
								end
								g.o.tbl.aim_grief[_pid]["active"]=false
							end)
							break
						end
					end
				end
			else
				for k,v in pairs(g.o.tbl.aim_grief[pid]) do
					g.o.tbl.aim_grief[pid][k]=false
				end
			end
		end
		YIELD(25)
	end
end)

	g._AimGriefExplode_p=menu_add_player_feature("Explode player","toggle",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["explode"]=f.on
	end)

	g._AimGriefburn_p=menu_add_player_feature("Burn player","toggle",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["burn"]=f.on
	end)

	g._AimGriefSparrow_p=menu_add_player_feature("Drop sparrow on player","toggle",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["sparrow"]=f.on
	end)

	g._AimGriefFatBitch_p=menu_add_player_feature("Spawn angry fat bitch on player","toggle",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["fat_bitch"]=f.on
	end)

	g._AimGriefWeap_p=menu_add_player_feature("Remove weapons","value_str",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["weapon"]=(f.on and f.value == 0)
		g.o.tbl.aim_grief[pid]["all_weapon"]=(f.on and f.value == 1)
	end)
	new_set_str_data(g._AimGriefWeap_p,{"Current weapon", "All weapons"})

	g._AimGriefKick_p=menu_add_player_feature("Kick player","toggle",g._SelfProtex_p.id, function(f,pid)
		g.o.tbl.aim_grief[pid]["kick"]=f.on
	end)

	g.print_load_info("Player aim griefs",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Player teleports"
	menu_add_player_feature("Add as fake friend","action",g._Fake_Friends.id, function(f,pid)
		if pid == API.plyr.my_id() then
			g.N_P(2,"You can't add yourself as a fake friend.",__GV__,4,"Yellow")
		else
			local file_path,file,contents,_start,_end,_last,_ff_sett,_ff_name
			local found,num = false,0
			file_path = "scid"
			if not utils.file_exists(g.paths._cfg..file_path..".cfg") then
				file = io.open(g.paths._cfg..file_path..".cfg", "a")
				file:write("[SCID]")
				file:close()
			end
			file = io.open(g.paths._cfg..file_path..".cfg", "r")
			for line in file:lines() do
				if line == nil then
					break
				else
					_start,_end = string.find(line, ":")
					if _start ~= nil and _end ~= nil then
						_ff_name = string.sub(line,1,_end-1)
						_last = _end+1
						_start,_end = string.find(line, ":",_last)
						if _start ~= nil and _end ~= nil then
							if g.tbl.PID_INFO.scid[pid+1] == funcs.get.hex_to_dec(string.sub(line,_last,_end-1)) then
								found = true
								break
							end
						end
					end
				end
				--YIELD(0)
			end
			io.close(file)
			if found then
				g.N_P(2,"SCID already in fake friends as name: ".._ff_name,__GV__,4,"Yellow")
			else
				num = funcs.get.dec_to_hex(g.tbl.PID_INFO.ff_jt[pid+1] + g.tbl.PID_INFO.ff_stlk[pid+1] + g.tbl.PID_INFO.ff_hide[pid+1] + g.tbl.PID_INFO.ff_frnd[pid+1])
				file = io.open(g.paths._cfg..file_path..".cfg", "a")
				file:write("\n"..funcs.get.pid_name(pid)..":"..funcs.get.dec_to_hex(g.tbl.PID_INFO.scid[pid+1])..":"..num)
				file:close()
				g.N_P(2,"SCID saved in fake friends",__GV__,4,"Green")
			end
		end
	end)

	menu_add_player_feature("Join timeout","toggle",g._Fake_Friends.id, function(f,pid)
		if f.on then g.tbl.PID_INFO.ff_jt[pid+1] = 4 else g.tbl.PID_INFO.ff_jt[pid+1] = 0	end
	end)

	menu_add_player_feature("Stalk","toggle",g._Fake_Friends.id, function(f,pid)
		if f.on then g.tbl.PID_INFO.ff_stlk[pid+1] = 1 else g.tbl.PID_INFO.ff_stlk[pid+1] = 0 end
	end)

	menu_add_player_feature("Hide them","toggle",g._Fake_Friends.id, function(f,pid)
		if f.on then g.tbl.PID_INFO.ff_hide[pid+1] = 8 else g.tbl.PID_INFO.ff_hide[pid+1] = 0	end
	end)

	menu_add_player_feature("Friend list","toggle",g._Fake_Friends.id, function(f,pid)
		if f.on then g.tbl.PID_INFO.ff_frnd[pid+1] = 16 else	g.tbl.PID_INFO.ff_frnd[pid+1] = 0 end
	end)

	-----------------------------------------------------------------------------------------GEE-SKID
	-----------------------------------------------------------------------------------------GeeSkidP
	---------------------------------------------------------------------------------------TeleportsP
	-------------------------------------------------------------------------------------------Online
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------

	function funcs.is.not_my_pid(_pid,_bool,_str,_sec,_color)
		if _bool and funcs.ME._id() == _pid then
			if _str then
				_sec = _sec or 4
				_color = _color or "Yellow"
				g.N_P(2,_str,__GV__,_sec,_color)
			end
			return false
		end
		return true
	end

	function funcs.is.pid_in_interior_and_not_my_interior(_pid)
		if g.tbl.PID_INFO.interior[_pid+1] then
			if g.tbl.PID_INFO.interior[API.plyr.my_id()+1] then
				return interior.get_interior_from_entity(API.plyr.get.ped(_pid)) ~= interior.get_interior_from_entity(funcs.ME._ped())
			end
			return true
		end
		return false
	end

	function funcs.get.veh_tp_height(veh)
		local height = 0
		local hash = API.ent.get.model_hash(veh)
		if streaming.is_model_a_plane(hash) then
			height=height+2
			if API.ent.is.in_air(veh) then
				height=height+69*3
			end
		elseif streaming.is_model_a_heli(hash) then
			height=height+2
			if API.ent.is.in_air(veh) then
				height=height+69*2
			end
		end
		height=height+veh_stuff.info[hash].Z_HEIGHT+1
		return height
	end

	function funcs.doo.tp_self_to_pid(_pid, _where)
		local pos = nil
		if funcs.is.pid_in_interior_and_not_my_interior(_pid) then
			funcs.N_P(2,funcs.get.pid_name(_pid).."\nIn interior.",funcs.ver_text,4,"Yellow")
			return
		elseif _where == "nearby" then
			pos = funcs.get.pos_nearby2(funcs.get.pid_pos_z_guess(_pid),10,false)
		elseif _where == "on_top" then
			pos = funcs.get.pid_pos_z_guess(_pid)
			pos.z=pos.z+3
		else--if _where == "behind" then
			pos = funcs.get.front_of_pos(funcs.get.pid_pos_z_guess(_pid),API.plyr.get.heading(_pid),5,0,1)
		end
		if funcs.ME._in_veh() then
			local veh = funcs.ME._veh()
			pos.z=pos.z+funcs.get.veh_tp_height(veh)
			if funcs.ntwrk.ask_long(veh,1500) then
				API.ent.set.coords(veh,pos)
			else
				funcs.N_P(2,"Failed to get control of vehicle :(",funcs.ver_text,4,"Red")
			end
		else
			API.ent.set.coords(funcs.ME._ped(),pos)
		end
	end


	function funcs.get.online_plyr_tp_pos(_veh,_action,_pos)
		if _action == "50_up" then
			return (funcs.get.ent_pos_z_guess(_veh)+funcs.vec(0,0,50))
		elseif _action == "250_up" then
			return (funcs.get.ent_pos_z_guess(_veh)+funcs.vec(0,0,250))
		elseif _action == "1000_up" then
			return (funcs.get.ent_pos_z_guess(_veh)+funcs.vec(0,0,1000))
		elseif _action == "forward" then
			return (funcs.get.front_of_dir(funcs.get.ent_pos_z_guess(_veh),API.ent.get.rotation(_veh),_pos)+funcs.vec(0,0,1))
		elseif _action == "wp" and g.feat.tp_type.value==0 then
			funcs.doo.wp_obj_tp_type(_pos)
		end
		return _pos
	end

	function funcs.doo.online_plyr_tp(_action,_pos,_loc,_speed,_pid)
		local name = funcs.get.pid_name(_pid)
		local dist = funcs.get.dist_me_pid_3d(_pid)
		local pid_pos = API.plyr.get.coords(_pid)
		local do_hover = g.tbl.PID_INFO.tp_sett[_pid+1]
		local in_veh = API.plyr.is.in_veh(_pid)
		local speed = funcs.vec(0,0,0)
		if funcs.is.pid_in_interior_and_not_my_interior(_pid) then
			funcs.N_P(2,name .. "\nIs in interior.",funcs.ver_text,4,"Yellow")
		elseif (dist < 250 or pid_pos.z > -45) and not in_veh then
			funcs.N_P(2,name .. "\nHas no vehicle.",funcs.ver_text,4,"Yellow")
		elseif dist > 250 and pid_pos.z < -45 and not do_hover and not in_veh then
			funcs.N_P(2,name .. "\nHas no vehicle. Try enabling force check.",funcs.ver_text,4,"Yellow")
		else
			local veh = API.plyr.get.veh(_pid)
			g.tbl.online_plyr_temp[#g.tbl.online_plyr_temp+1]=false
			local t_good = #g.tbl.online_plyr_temp
			g.tbl.online_plyr_temp[#g.tbl.online_plyr_temp+1]=false
			local t_fail = #g.tbl.online_plyr_temp
			if funcs.is.veh(veh) then
				if funcs.ntwrk.ask_long(veh,1000) then
					if _speed then
						speed = API.ent.get.velocity(veh)
					end
					veh = API.plyr.get.veh(_pid)
					_pos = funcs.get.online_plyr_tp_pos(veh,_action,_pos)
					_pos.z=_pos.z+funcs.get.veh_tp_height(veh)
					API.ent.set.coords(veh, _pos)
					YIELD(50)
					funcs.ntwrk.ask_long(veh,500)
					API.ent.set.velocity(veh, speed)
					g.tbl.online_plyr_temp[t_good]=true
				else
					g.tbl.online_plyr_temp[t_fail]=true
				end
			elseif do_hover and dist > 250 and pid_pos.z < -45 then
				local hover_tbl = funcs.get.hover_info()
				local time = TIME_MS() + 2500
				local do_once = false
				local temp_pos = API.plyr.get.coords(_pid)
				funcs.get.ground_z(temp_pos,true)
				while funcs.is.valid_pid(_pid) and (TIME_MS() < time) do
					if API.plyr.get.coords(_pid).z < -45 then
						API.ent.set.coords(funcs.ME._ped(), temp_pos+funcs.vec(0,0,50))
					else
						API.ent.set.coords(funcs.ME._ped(), API.plyr.get.coords(_pid)+funcs.vec(0,0,50))
					end
					if API.plyr.is.in_veh(_pid) and not do_once then
						do_once=true
						veh = API.plyr.get.veh(_pid)
						time=time+1500
						g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
							local __action,__pos,__speed,__pid,__veh,__t_good,__t_fail = _action,_pos,_speed,_pid,veh,t_good,t_fail
							if funcs.ntwrk.ask_long(__veh,1000) then
								local speed = funcs.vec(0,0,0)
								if __speed then
									speed = API.ent.get.velocity(__veh)
								end
								__pos = funcs.get.online_plyr_tp_pos(__veh,__action,__pos)
								__pos.z=__pos.z+funcs.get.veh_tp_height(__veh)
								API.ent.set.coords(__veh, __pos)
								YIELD(50)
								funcs.ntwrk.ask_long(__veh,500)
								API.ent.set.velocity(__veh, speed)
								g.tbl.online_plyr_temp[__t_good]=true
							else
								g.tbl.online_plyr_temp[__t_fail]=true
							end
						end)
					end
					if g.tbl.online_plyr_temp[t_good] or g.tbl.online_plyr_temp[t_fail] then
						time = TIME_MS()
					end
					YIELD(0)
				end
				funcs.doo.hover_back(hover_tbl)
			end
			if not funcs.is.veh(veh) then
				funcs.N_P(2,name .. "\nHas no vehicle.",funcs.ver_text,4,"Yellow")
			elseif g.tbl.online_plyr_temp[t_fail] then
				funcs.N_P(2,name .. "\nFAILED to teleport.",funcs.ver_text,4,"Red")
			end
		end
	end

	g.o._veh_tp_self2=menu_add_player_feature("TP self into their vehicle","action_value_str",g.o.prnt.tp.id,function(f,pid)
		if funcs.is.not_my_pid(pid,(f.value == 1 or f.value == 2),"You can't steal your own seat LOL") then
			funcs.doo.tp_into_plyr_veh2({pid}, f.value,false)
		end
	end)
	new_set_str_data(g.o._veh_tp_self2,{"Free Seat", "Their Seat", "Hijack Driver"})

	g.o._veh_tp_self_near=menu_add_player_feature("TP self to them","action_value_str",g.o.prnt.tp.id,function(f,pid)
		if funcs.is.not_my_pid(pid,true,"You are that player LOL") then
			local t = {"on_top","behind","nearby"}
			funcs.doo.tp_self_to_pid(pid, t[f.value+1])
		end
	end)
	new_set_str_data(g.o._veh_tp_self_near,{"On top", "Behind","Nearby"})

	g.o._veh_tp_to_me=menu_add_player_feature("TP them to me", "action_value_str", g.o.prnt.tp.id, function(f,pid)
		if funcs.is.not_my_pid(pid,true,"You are that player LOL") then
			local my_pos = funcs.get.front_of_dir(funcs.ME._veh_or_me_crds(),funcs.ME._veh_or_me_rot(),5)+funcs.vec(0,0,1)
			if f.value==0 then
				funcs.doo.online_plyr_tp("tp",my_pos,"Teleport",false,pid)
			elseif f.value==1 then
				funcs.doo.online_plyr_tp("tp",funcs.get.pos_nearby2(funcs.ME._veh_or_me_crds(),10,false),"Teleport",false,pid)
			elseif f.value==2 then
				funcs.doo.online_plyr_tp("tp",my_pos+funcs.vec(0,0,50),"Teleport",false,pid)
			elseif f.value==3 then
				funcs.doo.online_plyr_tp("tp",my_pos+funcs.vec(0,0,250),"Teleport",false,pid)
			else
				funcs.doo.online_plyr_tp("tp",my_pos+funcs.vec(0,0,1000),"Teleport",false,pid)
			end
		end
	end)
	new_set_str_data(g.o._veh_tp_to_me,{"In front of me", "Near me", "50m above me","250m above me", "1000m above me"})

	g.o._veh_tp_into_air=menu_add_player_feature("TP them above their position", "action_value_str", g.o.prnt.tp.id, function(f,pid)
		local t = {"50_up","250_up","1000_up"}
		funcs.doo.online_plyr_tp(t[f.value+1],nil,"Teleport",true,pid)
	end)
	new_set_str_data(g.o._veh_tp_into_air,{"50m up", "250m up", "1000m up"})



	g.o._veh_tp_mean_out=menu_add_player_feature("TP them high above", "action_value_str", g.o.prnt.tp.id, function(f,pid)
		if f.value == 0 then
			funcs.doo.online_plyr_tp("tp",funcs.get.rand_ocean_pos(),"Teleport",false,pid)
		elseif f.value == 1 then
			funcs.doo.online_plyr_tp("tp",funcs.vec(mth.rndm(-750,750), mth.rndm(-750,750), 2000),"Teleport",false,pid)
		else
			funcs.doo.online_plyr_tp("tp",funcs.vec(mth.rndm(485,499), mth.rndm(5580,5594), 2000),"Teleport",false,pid)
		end
	end)
	new_set_str_data(g.o._veh_tp_mean_out,{"The Water","The City","Mt. Chiliad"})

	g.o._veh_tp_mean_in=menu_add_player_feature("TP them to interior", "action_value_str", g.o.prnt.tp.id, function(f,pid)
		if f.value == 0 then
			funcs.doo.online_plyr_tp("tp",funcs.vec(mth.rndm(-82, -67), mth.rndm(-825, -812), mth.rndm(312, 317)),"Teleport",false,pid)
		elseif f.value == 1 then
			funcs.doo.online_plyr_tp("tp",funcs.vec(mth.rndm(129,142),mth.rndm(-754,-743),mth.rndm(259,261)),"Teleport",false,pid)
		else
			funcs.doo.online_plyr_tp("tp",funcs.vec(mth.rndm(-799, -757),mth.rndm(318, 338),mth.rndm(107, 127)),"Teleport",false,pid)
		end
	end)
	new_set_str_data(g.o._veh_tp_mean_in,{"Maze bank", "FIB interior","Apartment glitch"})

	g.o._veh_tp_rand=menu_add_player_feature("TP them to random location", "action", g.o.prnt.tp.id, function(f,pid)
		funcs.doo.online_plyr_tp("tp",funcs.get.spawn_points(funcs.vec(mth.rndm(-3500,4200),mth.rndm(-3600,7600),0),1)[1],"Teleport",false,pid)
	end)

	g.o._veh_tp_spcfc=menu_add_player_feature("TP them to specific location", "action_value_str", g.o.prnt.tp.id, function(f,pid)
		local pos
		if f.value == 0 then
			pos = funcs.get.spawn_points(funcs.vec(-1315,-3051,15),10)[1]
		elseif f.value == 1 then
			pos = funcs.get.spawn_points(funcs.vec(1794.3,3262.3,43.7),10)[1]
		elseif f.value == 2 then
			pos = funcs.get.spawn_points(funcs.vec(2144.1,4809.3,42.4),10)[1]
		elseif f.value == 3 then
			funcs.sort.pos_v2(tp_pos.lsc,API.plyr.get.coords(pid))
			pos = funcs.get.spawn_points(tp_pos.lsc[1],1)[1]
		elseif f.value == 4 then
			funcs.sort.pos_v2(tp_pos.ammu,API.plyr.get.coords(pid))
			pos = funcs.get.spawn_points(tp_pos.ammu[1],1)[1]
		else
			pos = funcs.get.spawn_points(funcs.vec(-1912.3,3042.7,34),10)[1]
		end
		funcs.doo.online_plyr_tp("tp",pos,"Teleport",false,pid)
	end)
	new_set_str_data(g.o._veh_tp_spcfc,{"LSIA","Sandy Shores Airfield","Mackenzie Airfield","Los Santos Custom","Ammunation","Fort Zancudo"})

	g.o._veh_tp_forward=menu_add_player_feature("TP them forward", "action_value_i", g.o.prnt.tp.id, function(f,pid)
		funcs.doo.online_plyr_tp("forward",f.value,"Teleport",true,pid)
	end)
	funcs.set_feat_i_f(g.o._veh_tp_forward,5,50,5,5)

	menu_add_player_feature("TP them to objective", "action", g.o.prnt.tp.id, function(f,pid)
		local obj = funcs.get.OBJ_coords3()
		if obj then
			funcs.doo.online_plyr_tp("wp",obj,"Teleport",false,pid)
		else
			funcs.N_P(2,"No objective found.",__GV__,4,"Yellow")
		end
	end)

	g.o._veh_tp_to_wp=menu_add_player_feature("TP them to waypoint", "action", g.o.prnt.tp.id, function(f,pid)
		local wp = funcs.get.waypoint()
		if wp then
			funcs.doo.online_plyr_tp("wp",wp,"Teleport",false,pid)
		else
			funcs.N_P(2,"No waypoint set.",__GV__,4,"Yellow")
		end
	end)

g.print_load_info("Player teleports",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Player vehicle features"
	-----------------------------------------------------------------------------------------GEE-SKID
	-----------------------------------------------------------------------------------------GeeSkidP
	-----------------------------------------------------------------------------------------VehicleP
	-------------------------------------------------------------------------------------------Online
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------

	g.o._player_veh_zoom_stop2=menu_add_player_feature("Vehicle stop/zoom","value_str",g.o.prnt.veh.id,function(f,pid)
		local no_veh,name,veh=0, funcs.get.pid_name(pid)
		while f.on do
			veh = g.tbl.PID_INFO.veh[pid+1]
			YIELD(0)
			if funcs.is.veh(veh) and funcs.ntwrk.ask_quick(veh) then
				if f.value == 0 then
					API.veh.set.forward_speed(veh,0)
				elseif f.value == 1 then
					API.veh.set.forward_speed(veh,100)
				end
			end
			if no_veh==0 and not funcs.is.veh(veh) then
				g.N_P(2,name .. " - No vehicle.\nWaiting...",__GV__,4,"Blue")
				no_veh=1
			end
		end
	end)
	new_set_str_data(g.o._player_veh_zoom_stop2,{"Stop","Zoom Zoom"})

	g.o._veh_float=menu_add_player_feature("Vehicle floats","value_str",g.o.prnt.veh.id,function(f, pid)
		while f.on do
			YIELD(0)
			if API.plyr.is.in_veh(pid) then
				funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,"float",f.value+25+(f.value*174))
			end
		end
	end)
	new_set_str_data(g.o._veh_float,{"Slowly","Rapture"})

	g.o._veh_down=menu_add_player_feature("Vehicle in air comes down","value_str",g.o.prnt.veh.id,function(f, pid)
		while f.on do
			YIELD(100)
			if API.plyr.is.in_veh(pid) and funcs.is.sssn_veh_action_chk(API.plyr.get.veh(pid),"air_down",nil) then
				funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,"air_down",(f.value+25+(f.value*174))*-1)
			end
		end
	end)
	new_set_str_data(g.o._veh_down,{"Gently","YEET"})

	g.o._veh_up=menu_add_player_feature("Vehicle on ground goes up","value_str",g.o.prnt.veh.id,function(f, pid)
		while f.on do
			YIELD(100)
			if API.plyr.is.in_veh(pid) and funcs.is.sssn_veh_action_chk(API.plyr.get.veh(pid),"ground_up",nil) then
				funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,"ground_up",f.value+25+(f.value*174))
			end
		end
	end)
	new_set_str_data(g.o._veh_up,{"Gently","YEET"})

	g.o._veh_grav=menu_add_player_feature("Vehicle gravity","value_str",g.o.prnt.veh.id,function(f, pid)
		while f.on do
			YIELD(100)
			if API.plyr.is.in_veh(pid) then
				funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,"gravity",f.value==0)
			end
		end
	end)
	new_set_str_data(g.o._veh_grav,{"Give","Remove"})


	g.o._veh_god=menu_add_player_feature("Vehicle god","value_str",g.o.prnt.veh.id,function(f, pid)
		while f.on do
			YIELD(100)
			if API.plyr.is.in_veh(pid) and API.ent.get.god(API.plyr.get.veh(pid)) ~= (f.value==0) then
				funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,"god",f.value==0)
			end
		end
	end)
	new_set_str_data(g.o._veh_god,{"Give","Remove"})

	g.o._veh_health_tog=menu_add_player_feature("Vehicle Damage/Destroy","value_str",g.o.prnt.veh.id,function(f, pid)
		local f_value
		while f.on do
			if API.plyr.is.in_veh(pid) and not API.ent.is.dead(API.plyr.get.veh(pid)) then
				f_value=f.value
				if funcs.doo.veh_action_list(API.plyr.get.veh(pid),1000,f.str_data[f.value+1]:lower(),nil) then
					funcs.doo.yield_while_true((f.on and f_value==f.value),5000)
				end
			end
			funcs.doo.yield_while_true(f.on,1000)
		end
	end)
	new_set_str_data(g.o._veh_health_tog,{"Damage","Destroy"})

	g.o._veh_auto_rpr=menu_add_player_feature("Auto-repair if less than %", "value_i", g.o.prnt.veh.id, function(f,pid)
		while f.on do
			if funcs.is.this_pid_in_seat(API.plyr.get.veh(pid),-1,pid) and funcs.get.veh_cmbnd_health_prcnt(API.plyr.get.veh(pid),true) < f.value then
				funcs.doo.veh_repair_most(API.plyr.get.veh(pid),250,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
			end
			funcs.doo.yield_while_true(f.on,500)
		end
	end)
	funcs.set_feat_i_f(g.o._veh_auto_rpr,50,100,5,75)

	g.tbl.online_plyr_temp={}

	function funcs.doo.online_plyr_start(_pid,_veh,_time,_action,_val,_num,_blame)
		local name = funcs.get.pid_name(_pid)
		local str = (g.tbl.sssn_action_str[_action] or "Action")
		local function failed()
			if g.tbl.PID_INFO.interior[_pid+1] then
				g.N_P(2,name.."\n"..str.." FAILED :(\n(They were in interior)",__GV__,5,"Red")
			else
				g.N_P(2,name.."\n"..str.." FAILED :(",__GV__,4,"Red")
			end
		end
		if _veh then
			if API.plyr.is.in_veh(_pid) then
				if not funcs.is.sssn_veh_action_chk(API.plyr.get.veh(_pid),_action,_val) then
					g.N_P(2,name.."\n"..str.." not needed/possible.",__GV__,5,"Yellow")
				elseif not funcs.doo.veh_action_list(API.plyr.get.veh(_pid),_time,_action,_val,_num) then
					failed()
				end
			elseif g.tbl.PID_INFO.tp_sett[_pid+1] then
				if funcs.get.dist_me_pid_3d(_pid) > 250 then
					g.tbl.online_plyr_temp[#g.tbl.online_plyr_temp+1]=false
					local temp = #g.tbl.online_plyr_temp
					local hover_tbl = funcs.get.hover_info()
					local time = TIME_MS() + 1750
					local completed,not_needed,do_once = false,false,false
					local temp_pos,plyr_pos = API.plyr.get.coords(_pid)
					funcs.get.ground_z(temp_pos,true)
					while funcs.is.valid_pid(_pid) and not completed and not not_needed and (TIME_MS() < time) do
						plyr_pos = API.plyr.get.coords(_pid)
						if plyr_pos.z < -45 then
							API.ent.set.coords(funcs.ME._ped(), temp_pos+funcs.vec(0,0,50))
						else
							API.ent.set.coords(funcs.ME._ped(), plyr_pos+funcs.vec(0,0,50))
						end
						if API.plyr.is.in_veh(_pid) and not do_once then
							do_once=true
							if not funcs.is.sssn_veh_action_chk(API.plyr.get.veh(_pid),_action,_val) then
								g.N_P(2,name.."\n"..str.." not needed/possible.",__GV__,5,"Yellow")
								not_needed=true
							else
								time=time+_time
								g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
									local __veh,__time,__action,__val,__temp = API.plyr.get.veh(_pid),_time,_action,_val,temp
									if funcs.doo.veh_action_list(__veh,__time,__action,__val,_num) then
										g.tbl.online_plyr_temp[__temp]=true
									end
								end)
							end
						end
						if g.tbl.online_plyr_temp[temp] then
							completed=true
						end
						YIELD(0)
					end
					funcs.doo.hover_back(hover_tbl)
					if not completed and not not_needed then
						failed()
					end
				else
					g.N_P(2,name.."\nHas no vehicle.",__GV__,5,"Yellow")
				end
			else
				g.N_P(2,name.."\nHas no vehicle. Try enabling force check.",__GV__,5,"Yellow")
			end
		elseif g.tbl.PID_INFO.interior[_pid+1] then
			g.N_P(2,name.."\nIs in interior.",__GV__,4,"Yellow")
		else
			local pid_pos = API.plyr.get.coords(_pid)
			local dist = funcs.get.dist_me_pid_3d(_pid)
			local continue,do_hover = false,false
			if not g.tbl.PID_INFO.tp_sett[_pid+1] then
				if dist > 400 and pid_pos.z < 0 then
					g.N_P(2,name.."\nToo far away to be accurate :(\nTry enabling force check.",__GV__,4,"Yellow")
				else
					continue = true
				end
			else
				continue = true
				if dist > 250 and pid_pos.z < 0 then
					do_hover = true
				end
			end
			if continue then
				g.tbl.sssn_pid_active[#g.tbl.sssn_pid_active+1]={}
				local active = #g.tbl.sssn_pid_active
				g.tbl.sssn_pid_active[active][_pid]=true
				g.tbl.sssn_pid_count[active]=0
				local completed,do_once = false,false
				local dead = API.ent.is.dead(API.plyr.get.ped(_pid))
				if do_hover then
					local hover_tbl = funcs.get.hover_info()
					local time = TIME_MS() + 2500

					local temp_pos,plyr_pos = API.plyr.get.coords(_pid)
					funcs.get.ground_z(temp_pos,true)
					temp_pos.z=temp_pos.z+50
					while funcs.is.valid_pid(_pid) and not completed and (TIME_MS() < time) do
						plyr_pos = API.plyr.get.coords(_pid)
						if plyr_pos.z < -45 then
							API.ent.set.coords(funcs.ME._ped(), temp_pos)
						else
							API.ent.set.coords(funcs.ME._ped(), plyr_pos+funcs.vec(0,0,50))
						end
						if plyr_pos.z > -45 and not do_once then
							do_once=true
							time=time+_time
							funcs.doo.sssn_plyr_pid_action_guts(_pid,active,_action,_val,_num,_blame)
						end
						if g.tbl.sssn_pid_count[active]>0 then
							completed=true
						end
						YIELD(10)
					end
					funcs.doo.hover_back(hover_tbl)
				else
					funcs.doo.sssn_plyr_pid_action_guts(_pid,active,_action,_val,_num,_blame)
					local time = TIME_MS() + 500 + _time
					while funcs.is.valid_pid(_pid) and not completed and (TIME_MS() < time) do
						if g.tbl.sssn_pid_count[active]>0 then
							completed=true
						end
						YIELD(10)
					end
				end
				if not funcs.is.valid_pid(_pid) then
					g.N_P(2,name.."\n"..str.." FAILED because the player left LOL",__GV__,4,"Red")
				elseif dead then
					g.N_P(2,name.."\n"..str.."\nPlayer was already dead :/",__GV__,4,"Red")
				elseif API.ent.is.dead(API.plyr.get.ped(_pid)) then
					g.N_P(2,name.."\nWas murdered :)",__GV__,4,"Green")
				elseif _action ~= "fat_bitches" then
					g.N_P(2,name.."\n"..str.." FAILED to murder :(",__GV__,4,"Red")
				end
			end
		end
	end


	g.o._veh_health=menu_add_player_feature("Vehicle Health","action_value_str",g.o.prnt.veh.id,function(f, pid)
		funcs.doo.online_plyr_start(pid,true,1000,f.str_data[f.value+1]:lower(),nil)
	end)
	new_set_str_data(g.o._veh_health,{"Repair","Damage","Destroy"})

	g.o._veh_horn=menu_add_player_feature("Horn-boost","slider",g.o.prnt.veh.id,function(f,pid)
		while f.on do
			YIELD(25)
			if API.plyr.is.in_veh(pid) and not ntv.is.veh_alarm_on(API.plyr.get.veh(pid)) and ntv.is.veh_horn_on(API.plyr.get.veh(pid)) then
				if funcs.ntwrk.ask_long(API.plyr.get.veh(pid),333) then
					local speed = (API.ent.get.speed(API.plyr.get.veh(pid)))
					speed = speed + (3+(40*f.value)-(0.02*speed))
					speed = speed * (1.01+f.value)
					API.veh.set.forward_speed(API.plyr.get.veh(pid),speed)
					YIELD(333)
				end
			end
		end
	end)
	funcs.set_feat_i_f(g.o._veh_horn,0,.1,.01,0)

	function funcs.get.my_attach_ent(f,pid)
		if f.value==0 then
			if g.o._veh_attach_not_in_veh.on[pid] or funcs.ME._in_veh() then
				return funcs.ME._veh()
			end
		end
		if f.value==1 then
			return funcs.ME._ped()
		end
		return nil
	end

	g.o._veh_attach=menu_add_player_feature("Attach to:","value_str",g.o.prnt.veh_attach.id,function(f,pid)
		local veh,my_ent,no_migrate,offset
		while f.on do
			my_ent = funcs.get.my_attach_ent(f,pid)
			veh = API.plyr.get.veh(pid)
			veh = veh~=0 and veh or glbls.get_pid_pers_veh(pid)
			if veh ~= my_ent and funcs.is.veh(veh) and funcs.is.ent(my_ent) then
				no_migrate=false
				while f.on and veh == API.plyr.get.veh(pid) and my_ent == funcs.get.my_attach_ent(f,pid) and funcs.is.veh(veh) and funcs.is.ent(my_ent) do
					if funcs.ntwrk.ask_quick(veh) then
						if not no_migrate then
							funcs.doo.id_migrate(veh,0)
							no_migrate=true
						end
						if API.ent.is.attached(veh) then
							entity.detach_entity(veh)
						end
						if API.ent.get.attached(veh) ~= my_ent then
							offset = ntv.get.ent_offset_in_world_coords(my_ent,funcs.vec(g.o._veh_attach_x.value[pid],g.o._veh_attach_y.value[pid],g.o._veh_attach_z.value[pid]))-API.ent.get.coords(my_ent)
							entity.attach_entity_to_entity(veh, my_ent, 0, offset, API.ent.get.rotation(my_ent), false, false, false, 0, false)
						end
					end
					YIELD(0)
				end
				if funcs.is.ent(veh) and API.ent.is.attached(veh) then
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local time = TIME_MS() + 5000
						local veh,my_ent = veh,my_ent
						while time > TIME_MS() and funcs.is.ent(veh) and API.ent.is.attached(veh) do
							if funcs.ntwrk.ask_quick(veh) then
								entity.detach_entity(veh)
								if not f.on and funcs.is.ent(my_ent) then
									local trgt_crds_do,vec_to_trgt = g.tbl.a_b.get_movement(API.ent.get.coords(veh),API.ent.get.coords(my_ent),
									g.o._veh_attach_launch.on[pid] and (g.o._veh_attach_launch.value[pid]+1)*1.5 or 0.1)
									entity.apply_force_to_entity(veh,1, trgt_crds_do.x,trgt_crds_do.y,trgt_crds_do.z,0,0,0,false, true)
								end
								funcs.doo.id_migrate(veh,1)
								break
							end
							YIELD(0)
						end

					end)
				end
			end
			YIELD(0)
		end
	end)
	new_set_str_data(g.o._veh_attach,{"My vehicle","My ped"})

	g.o._veh_attach_not_in_veh=menu_add_player_feature("Attach to my vehicle if i'm not in it","toggle",g.o.prnt.veh_attach.id)

	g.o._veh_attach_launch=menu_add_player_feature("Launch away on release","value_str",g.o.prnt.veh_attach.id)
	new_set_str_data(g.o._veh_attach_launch,{"Mild","Moderate","YEET"})

	g.o._veh_attach_x=menu_add_player_feature("Left/Right offset","action_value_f",g.o.prnt.veh_attach.id, function(f)
		funcs.doo.feat_value_within_limit(f,"Enter a number between -100 and 100",f.value,5,5)
	end)
	funcs.set_feat_i_f(g.o._veh_attach_x,-100,100,0.25,0)

	g.o._veh_attach_y=menu_add_player_feature("Front/Back offset","action_value_f",g.o.prnt.veh_attach.id, function(f)
		funcs.doo.feat_value_within_limit(f,"Enter a number between -100 and 100",f.value,5,5)
	end)
	funcs.set_feat_i_f(g.o._veh_attach_y,-100,100,0.25,0)

	g.o._veh_attach_z=menu_add_player_feature("Up/Down offset","action_value_f",g.o.prnt.veh_attach.id, function(f)
		funcs.doo.feat_value_within_limit(f,"Enter a number between -100 and 100",f.value,5,5)
	end)
	funcs.set_feat_i_f(g.o._veh_attach_z,-100,100,0.25,2)

	menu_add_player_feature("Release all vehicles","action",g.o.prnt.veh_attach.id, function(f)
		g.o._veh_attach.on=false
	end)

	menu_add_player_feature("Clone their vehicle", "action",g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,nil,"clone",
		funcs.get.front_of_dir(API.cam.get.pos(),API.cam.get.rot(),6.9 + funcs.get.dist_pospos_v3(funcs.ME._crds(),API.cam.get.pos())),
		API.cam.get.rot().z)
	end)

	g.o._veh_no_lock=menu_add_player_feature("Vehicle missile anti-lock","action_value_str",g.o.prnt.veh.id,function(f, pid)
		funcs.doo.online_plyr_start(pid,true,1000,"anti_lock",f.value==1)
	end)
	new_set_str_data(g.o._veh_no_lock,{"Give","Remove"})

	g.o._veh_freeze=menu_add_player_feature("Freeze their vehicle","action_value_str",g.o.prnt.veh.id,function(f, pid)
		funcs.doo.online_plyr_start(pid,true,1000,"freeze",f.value*45000)
	end)
	new_set_str_data(g.o._veh_freeze,{"Freeze","Un-Freeze"})

	g.o._veh_upgrades_action2=menu_add_player_feature("Vehicle Upgrades","action_value_str",g._VehicleModP.id,function(f,pid)
		local t = {"upgrades","perf","wheels","f1","headlights","neons","paint","livery","weapons"}
		funcs.doo.online_plyr_start(pid,true,1000,t[f.value+1],nil)
	end)
	new_set_str_data(g.o._veh_upgrades_action2,{"Everything", "Performance mods","Wheels/Tires","Give F1 Wheels","Headlights","Neon lights","Paintjob","Livery","Weapons"})

	g.o._plyr_veh_force2=menu_add_player_feature("Vehicle max speed/torque %","action_value_i",g._VehicleModP.id,function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"speed_torque",f.value/100)
	end)
	funcs.set_feat_i_f(g.o._plyr_veh_force2,0,700,5,100)

	g.o._veh_accel_fuck=menu_add_player_feature("Vehicle acceleration is","action_value_str",g.o.prnt.veh.id,function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"speed_torque",(f.value-10)+(f.value*109))
	end)
	new_set_str_data(g.o._veh_accel_fuck,{"Fucked", "Normal"})

	menu_add_player_feature("Fuck vehicle", "action", g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"fucked",nil)
	end)

	menu_add_player_feature("Remove helicopter rotors", "action", g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"remove_rotor",nil)
	end)

	menu_add_player_feature("Remove vehicle weapons", "action", g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"rmv_veh_weap",nil)
	end)

	g.o._veh_kick_from=menu_add_player_feature("Vehicle Kick", "action_value_str", g.o.prnt.veh.id, function(f,pid)
		local t = {"kick_pid_from_veh","kick_all_from_veh"}
		funcs.doo.online_plyr_start(pid,true,3000,t[f.value+1],pid)
	end)
	new_set_str_data(g.o._veh_kick_from,{"Just them", "All occupants"})

	g.o._veh_tire=menu_add_player_feature("Tire health", "action_value_str", g.o.prnt.veh.id, function(f,pid)
		local t = {"pop_tires","unpop_tires"}
		funcs.doo.online_plyr_start(pid,true,1000,t[f.value+1],nil)
	end)
	new_set_str_data(g.o._veh_tire,{"Pop", "Repair"})

	menu_add_player_feature("Vehicle flip upside down", "action", g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"flip_wrong",nil)
	end)

	g.o._veh_visible=menu_add_player_feature("Vehicle visibility", "action_value_str", g.o.prnt.veh.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"visible",f.value==1)
	end)
	new_set_str_data(g.o._veh_visible,{"Invisible", "Visible"})

	g.o._veh_weapons=menu_add_player_feature("Vehicle weapons", "action_value_str", g._VehicleModP.id, function(f,pid)
		local t = {"weapons","weapons_worst"}
		funcs.doo.online_plyr_start(pid,true,1000,t[f.value+1],nil)
	end)
	new_set_str_data(g.o._veh_weapons,{"Best", "Worst"})

	g.o._veh_armor=menu_add_player_feature("Vehicle armor", "action_value_str", g._VehicleModP.id, function(f,pid)
		local t = {"best_armor","worst_armor"}
		funcs.doo.online_plyr_start(pid,true,1000,t[f.value+1],nil)
	end)
	new_set_str_data(g.o._veh_armor,{"Best", "Worst"})

	g.o._countermeasr=menu_add_player_feature("Countermeasures", "action_value_str", g._VehicleModP.id, function(f,pid)
		funcs.doo.online_plyr_start(pid,true,1000,"cntrmsrs",f.value)
	end)
	new_set_str_data(g.o._countermeasr,{"Chaff", "Flare", "None"})

	--mk2 mod6 Countermeasures
	--helo/planes mod1 Countermeasures
	--0 chaff Countermeasures
	--1 flare Countermeasures
	--2 none Countermeasures

	g.o._air_bombs=menu_add_player_feature("Bombs", "action_value_str", g._VehicleModP.id, function(f,pid)
		local t = {0,3,4}
		funcs.doo.online_plyr_start(pid,true,1000,"bombs",t[f.value+1])
	end)
	new_set_str_data(g.o._air_bombs,{"Explosive", "Cluster", "None"})

	--helo/planes mod9 Bombs
	--0 explosive  ---------- Bombs
	--1 incendiary --doesnt work on some vehicles Bombs
	--2 gas --doesnt work on some vehicles Bombs
	--3 cluster  -------------Bombs
	--4 none  ---------------Bombs


g.print_load_info("Player vehicle features",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)--------------------------------------PLAYERS ONLINE END
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------PLAYERS LOCAL BEGIN

g.var.feat_loading_str = "Session player actions"


	-----------------------------------------------------------------------------------------GEE-SKID
	------------------------------------------------------------------------------------------Players
	--------------------------------------------------------------------------------------------Local
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------


	g.tbl.sssn_stf={}
	g.tbl.sssn_stf.old={}
	g.tbl.sssn_stf.func={}
	g.tbl.sssn_stf.ent_thread={}



	g.tbl.sssn_veh_plyr_affect={}
	g.tbl.sssn_pid_plyr_affect={}

	function funcs.doo.sssn_veh_tog_hide(_bool)
		g.tbl.sssn_veh_plyr_affect.pers.hidden=_bool
		g.tbl.sssn_veh_plyr_affect.frnd.hidden=_bool
		g.tbl.sssn_veh_plyr_affect.orgmc.hidden=_bool
		g.tbl.sssn_veh_plyr_affect.mddr.hidden=_bool
		g.tbl.sssn_veh_plyr_affect.others.hidden=_bool
		g.tbl.sssn_veh_plyr_affect.force.hidden=_bool
	end

	function funcs.doo.sssn_plyr_pid_check(_pid)
		if not API.plyr.is.valid(_pid) or _pid == funcs.ME._id() then
			return false
		end
		local friend = API.plyr.is.friend(_pid)
		if friend and not g.tbl.sssn_pid_plyr_affect.frnd.on then
			return false
		end
		local mddr = API.plyr.is.modder(_pid, -1)
		if mddr and not g.tbl.sssn_pid_plyr_affect.mddr.on then
			return false
		end
		local orgmc = funcs.is.same_orgmc(funcs.ME._id(),_pid)
		if orgmc and not g.tbl.sssn_pid_plyr_affect.orgmc.on then
			return false
		end
		if not friend and not mddr and not orgmc and not g.tbl.sssn_pid_plyr_affect.others.on then
			return false
		end
		return true
	end

	function funcs.get.pid_not_dead_or_intrr(_pid,not_dead,not_intrr)
		if not_dead and API.ent.is.dead(API.plyr.get.ped(_pid)) then
			return false
		end
		if not_intrr and g.tbl.PID_INFO.interior[_pid+1] then
			return false
		end
		return true
	end

	function funcs.get.sssn_pid_plyr_table(not_dead,not_intrr,_action)
		local pidtable = {}
		for pid = 0,31 do
			if funcs.doo.sssn_plyr_pid_check(pid) and funcs.get.pid_not_dead_or_intrr(pid,not_dead,not_intrr) then
				pidtable[#pidtable+1]=pid
			end
		end
		return pidtable
	end

	function funcs.get.sssn_pid_plyr_start(_action,_show_notif,not_dead,not_intrr)
		local pid_table = funcs.get.sssn_pid_plyr_table(not_dead,not_intrr,_action)
		if #pid_table > 0 then
			return pid_table
		end
		if _show_notif then
			g.N_P(2,"No available players from selection.",__GV__,4,"Yellow")
		end
		return nil
	end

	function funcs.doo.ent_seek_pid(ent,pid,speed)
		local _ent,_pid,_speed = ent,pid,speed
		if funcs.is.ent(ent) and funcs.is.valid_pid(pid) then
			local stop,trgt_crds_do = false
			local time = TIME_MS() + 3000
			while funcs.is.ent(_ent) and funcs.is.valid_pid(_pid) and not stop and time > TIME_MS() do
				trgt_crds_do = g.tbl.a_b.get_movement(API.plyr.get.coords(_pid),API.ent.get.coords(_ent),_speed)
				if funcs.is.in_grid(API.ent.get.coords(_ent),API.plyr.get.coords(_pid),2) or API.ent.is.dead(API.plyr.get.ped(_pid)) then
					stop=true
				elseif funcs.ntwrk.ask_quick(_ent) then
					API.ent.set.velocity(_ent,trgt_crds_do)
				end
				YIELD(10)
			end
		end
		return (funcs.is.valid_pid(_pid) and API.ent.is.dead(API.plyr.get.ped(_pid)))
	end

	function funcs.doo.sssn_plyr_pid_action_guts(pid,active,action,val,num,blame)
		local _pid,_active,_action,_val,_num,_blame = pid,active,action,val,num,blame
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local __pid,__active,__action,__val,__num,__blame = _pid,_active,_action,_val,_num,_blame
			local bitch_count,drop = 0
			if __action == "burn" or __action == "explode" then
				if __blame then
					__blame=funcs.ME._ped()
				else
					__blame=API.plyr.get.ped(__pid)
				end
				for x=1,__num do
					if API.plyr.is.valid(__pid) and funcs.get.pid_not_dead_or_intrr(__pid,true,true) then
						fire.add_explosion(API.plyr.get.coords(__pid), __val, true, false, 0, __blame)
						YIELD(100)
					end
				end
			elseif __action == "sparrow" then
				local sparrows = {}
				funcs.doo.req_model(1229411063)
				for s=1,__num do
					if API.plyr.is.valid(__pid) and funcs.get.pid_not_dead_or_intrr(__pid,true,true) then
						sparrows[#sparrows+1] = funcs.doo.spawn_veh(API.plyr.get.coords(__pid)+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),30),1229411063,false,nil,true)
						YIELD(0)
						if not funcs.is.ent(sparrows[#sparrows]) then
							break
						else
							API.veh.set.engine_health(sparrows[#sparrows], -4000)
							ntv.set.veh_body_health(sparrows[#sparrows],0)
							API.veh.set.out_of_control(sparrows[#sparrows], false, true)
							if funcs.doo.ent_seek_pid(sparrows[#sparrows],__pid,60) then
								break
							end
						end
					end
				end
				for r=1,#sparrows do
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local veh = sparrows[r]
						funcs.doo.remove_ent(veh,1000)
					end)
				end
			elseif __action == "fat_bitches" then
				local ped_model = API.get_hash_key("a_f_m_fatcult_01")
				local weapon1 = API.get_hash_key("weapon_machinepistol")
				local weapon2 = API.get_hash_key("weapon_gusenberg")
				local veh_hash = nil
				if API.strm.is.valid(API.get_hash_key(__val)) then
					veh_hash = API.get_hash_key(__val)
					funcs.doo.req_model(veh_hash)
				end
				funcs.doo.req_model(ped_model)
				local bitches = {}
				local bitch_veh ={}
				for i=1,__num do
					if API.plyr.is.valid(__pid) and funcs.get.pid_not_dead_or_intrr(__pid,true,true) then
						local _pos = funcs.get.front_of_pos(funcs.get.pid_pos_z_guess(__pid), mth.rndm(-180,180), 7, 0, .5)
						if veh_hash then
							if API.strm.is.valid_helo(veh_hash) then
								_pos = _pos + funcs.vec(0,0,100)
							elseif API.strm.is.valid_plane(veh_hash) then
								_pos = _pos + funcs.vec(0,0,666)
							end
							bitch_veh[i] = funcs.doo.spawn_veh(_pos,veh_hash,true)
							if not funcs.is.ent(bitch_veh[i]) then
								break
							else
								YIELD(0)
							end
						end
						bitches[i] =funcs.doo.spawn_ped_angry(_pos,ped_model,weapon1,weapon2,__pid,bitch_veh[i])
						if not funcs.is.ent(bitches[i]) then
							break
						else
							g.tbl.unaffected_ents[bitches[i]]=true
							bitch_count=bitch_count+1
							YIELD(0)
							funcs.doo.ped_attack_ped_thread(bitches[i],API.plyr.get.ped(__pid),true,true)
						end
					end
				end
			elseif __action == "health" or __action == "armor" then
				drop = funcs.doo.make_drop(__action,funcs.get.pid_vel_pos(__pid,1)+funcs.vec(0,0,1))
			end
			if __action == "health" or __action == "armor" then
				if funcs.is.ent(drop) then
					g.tbl.sssn_pid_count[__active]=g.tbl.sssn_pid_count[__active]+1
				end
			elseif __action == "fat_bitches" then
				if bitch_count == __num then
					g.tbl.sssn_pid_count[__active]=g.tbl.sssn_pid_count[__active]+1
				end
			else
				funcs.doo.yield_while_true((API.plyr.is.valid(__pid) and not API.ent.is.dead(API.plyr.get.ped(__pid))),1000)
				if API.plyr.is.valid(__pid) and API.ent.is.dead(API.plyr.get.ped(__pid)) then
					g.tbl.sssn_pid_count[__active]=g.tbl.sssn_pid_count[__active]+1
				end
			end
			g.tbl.sssn_pid_active[__active][__pid]=false
		end)
	end

	-- function funcs.doo.move_plane_forward(_veh,_time,_speed)
		-- if funcs.is.plane(_veh) then
			-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
				-- local __veh,__time,__speed,rot=_veh,_time,_speed
				-- local time=TIME_MS()+__time
				-- while time>TIME_MS() and funcs.is.ent(__veh) do
					-- if funcs.ntwrk.ask_quick(__veh) then
						-- rot = API.ent.get.rotation(__veh)
						-- API.ent.set.rotation(__veh,v3(0,0,rot.z))
						-- API.veh.set.forward_speed(__veh,__speed)
					-- end
					-- YIELD(0)
				-- end
			-- end)
		-- end
	-- end

	function funcs.doo.ped_attack_ped_thread(_perp,_vctm,_v_dead)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local __perp,__vctm,__v_dead = _perp,_vctm,_v_dead
			local pos,dist,stop,in_veh,aircraft,plane,helo,have_los,los_time
			local function should_tp()
				if (helo and dist > 500) or	(not helo and plane and dist > 2000) or	(not aircraft and in_veh and dist > 200) or	(not in_veh and dist > 100) then
					return true
				elseif not have_los then
					if los_time == nil then
						if in_veh then
							los_time = API.util.t_s()+15
						else
							los_time = API.util.t_s()+5
						end
					elseif los_time < API.util.t_s() then
						return true
					end
				elseif in_veh then
					los_time = API.util.t_s()+15
				else
					los_time = API.util.t_s()+5
				end
				return false
			end
			while funcs.is.ped(__perp) and funcs.is.ped(__vctm) and not stop do
				in_veh = API.Ped.is.in_veh(__perp)
				helo = (in_veh and API.strm.is.valid_helo(API.ent.get.model_hash(API.Ped.get.veh(__perp))))
				plane = (in_veh and API.strm.is.valid_plane(API.ent.get.model_hash(API.Ped.get.veh(__perp))))
				aircraft = (helo or plane)
				dist = funcs.get.dist_pospos_v3(API.ent.get.coords(__perp),API.ent.get.coords(__vctm))
				have_los = funcs.is.peds_have_los(__perp,__vctm)
				if should_tp() then
					if API.Ped.is.plyr(__vctm) then
						pos = funcs.get.pid_pos_z_guess(API.plyr.get.plyr_from_ped(__vctm))
					else
						pos = API.ent.get.coords(__vctm)
					end
					if in_veh and funcs.ntwrk.ask_long(API.Ped.get.veh(__perp),1000) then
						local size = g.tbl.a_b.get_veh_dmnsns2()
						local int = mth.flr(size*2)
						if helo then
							API.ent.set.coords(API.Ped.get.veh(__perp),pos+funcs.vec(mth.rndm(-int,int),mth.rndm(-int,int),100))
						elseif plane then
							API.ent.set.coords(API.Ped.get.veh(__perp),pos+funcs.vec(mth.rndm(-int,int),mth.rndm(-int,int),500))
						else
							API.ent.set.coords(API.Ped.get.veh(__perp),pos+funcs.vec(mth.rndm(-int,int),mth.rndm(-int,int),1))
						end
					elseif funcs.ntwrk.ask_long(__perp,1000) then
						API.ent.set.coords(__perp,pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),1))
					end
				end
				if in_veh then
					if aircraft then
						if helo then
							API.veh.set.helo_blades_full(API.Ped.get.veh(__perp))
						end
						ai.task_combat_ped(__perp, __vctm,0,16)
					elseif have_los then
						ai.task_combat_ped(__perp, __vctm,0,16)
					else
						ai.task_vehicle_drive_to_coord(__perp, API.Ped.get.veh(__perp),API.ent.get.coords(__vctm), 100, 1, API.ent.get.model_hash(API.Ped.get.veh(__perp)), 786956, 15, 1.0)
					end
				else
					if have_los then
						ai.task_combat_ped(__perp, __vctm,0,16)
					else
						ntv.task.go_straight_coords(__perp,API.ent.get.coords(__vctm),2.0,1,0.0,0.5)
					end
				end
				YIELD(1000)
				if not funcs.is.ent(__perp) or API.ent.is.dead(__perp) then
					stop = true
				elseif __v_dead and funcs.is.ent(__vctm) and API.ent.is.dead(__vctm) then
					stop = true
				end
			end
			g.tbl.unaffected_ents[__perp]=false
			funcs.doo.remove_ent(__perp,1000)
		end)
	end


	function funcs.is.peds_have_los(_ped1,_ped2)
		if funcs.is.ped(_ped1) and funcs.is.ped(_ped2) then
			if ntv.is.ents_in_los(_ped1,_ped2,3,true) then
				return true
			end
			local ent1,ent2
			if API.Ped.is.in_veh(_ped1) then
				ent1 = API.Ped.get.veh(_ped1)
			end
			if API.Ped.is.in_veh(_ped2) then
				ent2 = API.Ped.get.veh(_ped2)
			end
			if ent1 and ent2 and ntv.is.ents_in_los(ent1,ent2,3,true) then
				return true
			elseif ent1 and not ent2 and ntv.is.ents_in_los(ent1,_ped2,3,true) then
				return true
			elseif not ent1 and ent2 and ntv.is.ents_in_los(_ped1,ent2,3,true) then
				return true
			end
		end
		return false
	end

	function funcs.doo.sssn_plyr_pid_action(_action,_val,_num,_blame,_no_force,_show_notif,not_dead,not_intrr)
		local pid_table = funcs.get.sssn_pid_plyr_start(_action,_show_notif,not_dead,not_intrr)
		if pid_table then
			local action_str = (g.tbl.sssn_action_str[_action] or "Actions")
			local total = 0
			local count = 0
			g.tbl.sssn_pid_active[#g.tbl.sssn_pid_active+1]={}
			local active = #g.tbl.sssn_pid_active
			g.tbl.sssn_pid_count[active]=0
			g.var.sssn_temp_cnt=0
			local force =  (not _no_force and g.feat.sssn_pid_plyr_affect_force.on)
			local new_pid_table = {}
			local hover_tbl,i_hovered,hover_pos = funcs.get.hover_info(),false,v3()
			for i=1,#pid_table do
				if API.plyr.is.valid(pid_table[i]) and funcs.get.pid_not_dead_or_intrr(pid_table[i],not_dead,not_intrr) then
					if force then
						total=total+1
						new_pid_table[#new_pid_table+1]=pid_table[i]
					elseif API.plyr.get.coords(pid_table[i]).z > -49 then
						total=total+1
						new_pid_table[#new_pid_table+1]=pid_table[i]
					end
				end
			end
			funcs.sort.pid_pos_v3(new_pid_table,funcs.ME._crds(),"ascending")
			for i=1,#new_pid_table do
				local _pid = new_pid_table[i]
				if API.plyr.is.valid(_pid) and funcs.get.pid_not_dead_or_intrr(_pid,not_dead,not_intrr) then
					g.tbl.sssn_pid_active[active][_pid]=true
					if force and (API.plyr.get.coords(_pid).z < 0 or funcs.get.dist_me_pid_3d(_pid) > 750) then
						i_hovered=true
						hover_pos=funcs.doo.hover_above_pid2(_pid,1500,false,true)
						funcs.sort.pid_pos_v3(new_pid_table,funcs.ME._crds(),"ascending")
					end
					funcs.doo.sssn_plyr_pid_action_guts(_pid,active,_action,_val,_num,_blame)
					if i_hovered then
						for ii=1,#new_pid_table do
							local _pid2 = new_pid_table[ii]
							if API.plyr.is.valid(_pid2) and funcs.get.pid_not_dead_or_intrr(_pid2,not_dead,not_intrr) then
								if not g.tbl.sssn_pid_active[active][_pid2] and API.plyr.get.coords(_pid2).z > 0 and funcs.get.dist_me_pid_3d(_pid2) < 750 then
									g.tbl.sssn_pid_active[active][_pid2]=true
									funcs.doo.sssn_plyr_pid_action_guts(_pid2,active,_action,_val,_num,_blame)
								end
							end
						end
					end
				end

				if i_hovered then
					local found = true
					while found do
						found = false
						for k,v in pairs(g.tbl.sssn_pid_active[active]) do
							if v then found = true break end
						end
						if found then
							API.ent.set.coords(funcs.ME._ped(), hover_pos)
						end
						YIELD(10)
					end
				end
			end
			if i_hovered then
				funcs.doo.hover_back(hover_tbl)
			end
			for i=0,31 do
				if g.tbl.sssn_pid_skip[i] then
					count=count+1
					g.tbl.sssn_pid_skip[i]=false
				end
			end
			if _show_notif then
				local found = true
				while found do
					found = false
					for k,v in pairs(g.tbl.sssn_pid_active[active]) do
						if v then found = true break end
					end
					YIELD(10)
				end
				g.N_P(2,action_str.." complete.".."\n"..g.tbl.sssn_pid_count[active].."/"..total.." successful",__GV__,5,"Blue")
			end
		end
	end





		g.tbl.sssn_stf.pid_trgt_prnt = menu_add_feature("Select Targets", "parent", g.prnt.sssn_plyrs.id)

			function funcs.doo.sssn_feat_no_tog(_bool,_table,_feat1,_feat2)
				if _bool then
					for _, feat in pairs(_table) do
						if feat ~= _feat1 and feat.on then
							return
						end
					end
					_feat2.on=true
				end
			end

			g.tbl.sssn_pid_plyr_affect.frnd=menu_add_feature("My Friends","toggle",g.tbl.sssn_stf.pid_trgt_prnt.id,function(f)
				funcs.doo.sssn_feat_no_tog(not f.on,g.tbl.sssn_pid_plyr_affect,g.tbl.sssn_pid_plyr_affect.frnd,g.tbl.sssn_pid_plyr_affect.orgmc)
			end)
			funcs.add_to_S_L(g.tbl.sssn_pid_plyr_affect.frnd,"g.tbl.sssn_pid_plyr_affect.frnd")

			g.tbl.sssn_pid_plyr_affect.orgmc=menu_add_feature("My ORG/MC","toggle",g.tbl.sssn_stf.pid_trgt_prnt.id,function(f)
				funcs.doo.sssn_feat_no_tog(not f.on,g.tbl.sssn_pid_plyr_affect,g.tbl.sssn_pid_plyr_affect.orgmc,g.tbl.sssn_pid_plyr_affect.mddr)
			end)
			funcs.add_to_S_L(g.tbl.sssn_pid_plyr_affect.orgmc,"g.tbl.sssn_pid_plyr_affect.orgmc")

			g.tbl.sssn_pid_plyr_affect.mddr=menu_add_feature("Modders","toggle",g.tbl.sssn_stf.pid_trgt_prnt.id,function(f)
				funcs.doo.sssn_feat_no_tog(not f.on,g.tbl.sssn_pid_plyr_affect,g.tbl.sssn_pid_plyr_affect.mddr,g.tbl.sssn_pid_plyr_affect.others)
			end)
			funcs.add_to_S_L(g.tbl.sssn_pid_plyr_affect.mddr,"g.tbl.sssn_pid_plyr_affect.mddr")

			g.tbl.sssn_pid_plyr_affect.others=menu_add_feature("All other players","toggle",g.tbl.sssn_stf.pid_trgt_prnt.id,function(f)
				funcs.doo.sssn_feat_no_tog(not f.on,g.tbl.sssn_pid_plyr_affect,g.tbl.sssn_pid_plyr_affect.others,g.tbl.sssn_pid_plyr_affect.frnd)
			end)
			funcs.add_to_S_L(g.tbl.sssn_pid_plyr_affect.others,"g.tbl.sssn_pid_plyr_affect.others")

			g.feat.sssn_pid_plyr_affect_force=menu_add_feature("Force check for player position","toggle", g.tbl.sssn_stf.pid_trgt_prnt.id)
			funcs.add_to_S_L(g.feat.sssn_pid_plyr_affect_force,"g.feat.sssn_pid_plyr_affect_force")


			g.tbl.sssn_pid_plyr_affect.others.on=true

		g.tbl.sssn_stf.spwn_prnt = menu_add_feature("Spawn Vehicles", "parent", g.prnt.sssn_plyrs.id)

		g.tbl.sssn_stf.drop_prnt = menu_add_feature("Drops", "parent", g.prnt.sssn_plyrs.id)

		menu_add_feature("Drop health","action",g.tbl.sssn_stf.drop_prnt.id,function(f)
			funcs.doo.sssn_plyr_pid_action("health","once",nil,nil,false,true,true,false)
		end)

		g.tbl.sssn_stf.drop_health=menu_add_feature("Drop health if needed","toggle",g.tbl.sssn_stf.drop_prnt.id,function(f)
			local history={}
			for pid=0,31 do
				history[pid]={}
			end
			while f.on do
				for pid=0,31 do
					if funcs.doo.sssn_plyr_pid_check(pid) and API.plyr.get.coords(pid).z > -49 and funcs.is.should_drop("health",pid) then
						if #history[pid]>=5 then
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								local ENT = history[pid][1]
								funcs.doo.remove_ent(ENT,1000)
							end)
							table.remove(history[pid],1)
						end
						history[pid][#history[pid]+1]=funcs.doo.make_drop("health",funcs.get.pid_vel_pos(pid,1)+funcs.vec(0,0,1))
					end
				end
				funcs.doo.yield_while_true(f.on,1000)
			end
		end)
		funcs.add_to_S_L(g.tbl.sssn_stf.drop_health,"g.tbl.sssn_stf.drop_health")

		menu_add_feature("Drop armor","action",g.tbl.sssn_stf.drop_prnt.id,function(f)
			funcs.doo.sssn_plyr_pid_action("armor","once",nil,nil,false,true,true,false)
		end)

		g.tbl.sssn_stf.drop_armor=menu_add_feature("Drop armor if needed","toggle",g.tbl.sssn_stf.drop_prnt.id,function(f)
			local history={}
			for pid=0,31 do
				history[pid]={}
			end
			while f.on do
				for pid=0,31 do
					if funcs.doo.sssn_plyr_pid_check(pid) and API.plyr.get.coords(pid).z > -49 and funcs.is.should_drop("armor",pid) then
						if #history[pid]>=5 then
							g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
								local ENT = history[pid][1]
								funcs.doo.remove_ent(ENT,1000)
							end)
							table.remove(history[pid],1)
						end
						history[pid][#history[pid]+1]=funcs.doo.make_drop("armor",funcs.get.pid_vel_pos(pid,1)+funcs.vec(0,0,1))
					end
				end
				funcs.doo.yield_while_true(f.on,1000)
			end
		end)
		funcs.add_to_S_L(g.tbl.sssn_stf.drop_armor,"g.tbl.sssn_stf.drop_armor")


		g.print_load_info("Session player actions",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
		g.var.feat_loading_str = "Session vehicle actions"
		g.tbl.sssn_stf.veh_trgt_prnt = menu_add_feature("Select Targets", "parent", g.prnt.sssn_vehs.id)

			g.feat.sssn_veh_affect_npc_street=menu_add_feature("NPC/Street","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on then g.feat.sssn_veh_affect_plyrs.on=true end
			end)
			funcs.add_to_S_L(g.feat.sssn_veh_affect_npc_street,"g.feat.sssn_veh_affect_npc_street")

			g.feat.sssn_veh_affect_plyrs=menu_add_feature("Vehicles players have used","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on then g.feat.sssn_veh_affect_npc_street.on=true end
				funcs.doo.sssn_veh_tog_hide(not f.on)
			end)
			funcs.add_to_S_L(g.feat.sssn_veh_affect_plyrs,"g.feat.sssn_veh_affect_plyrs")

			g.tbl.sssn_veh_plyr_affect.pers=menu_add_feature("Personal vehicles","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.pers,"g.tbl.sssn_veh_plyr_affect.pers")

			g.tbl.sssn_veh_plyr_affect.frnd=menu_add_feature("Vehicles my friends are in/own","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on and not g.tbl.sssn_veh_plyr_affect.orgmc.on and not g.tbl.sssn_veh_plyr_affect.mddr.on and not g.tbl.sssn_veh_plyr_affect.others.on then
					g.tbl.sssn_veh_plyr_affect.others.on=true
				end
			end)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.frnd,"g.tbl.sssn_veh_plyr_affect.frnd")

			g.tbl.sssn_veh_plyr_affect.orgmc=menu_add_feature("Vehicles my ORG/MC are in/own","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on and not g.tbl.sssn_veh_plyr_affect.frnd.on and not g.tbl.sssn_veh_plyr_affect.mddr.on and not g.tbl.sssn_veh_plyr_affect.others.on then
					g.tbl.sssn_veh_plyr_affect.others.on=true
				end
			end)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.orgmc,"g.tbl.sssn_veh_plyr_affect.orgmc")

			g.tbl.sssn_veh_plyr_affect.mddr=menu_add_feature("Vehicles modders are in/own","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on and not g.tbl.sssn_veh_plyr_affect.frnd.on and not g.tbl.sssn_veh_plyr_affect.orgmc.on and not g.tbl.sssn_veh_plyr_affect.others.on then
					g.tbl.sssn_veh_plyr_affect.others.on=true
				end
			end)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.mddr,"g.tbl.sssn_veh_plyr_affect.mddr")

			g.tbl.sssn_veh_plyr_affect.others=menu_add_feature("All other player vehicles","toggle",g.tbl.sssn_stf.veh_trgt_prnt.id,function(f)
				if not f.on and not g.tbl.sssn_veh_plyr_affect.frnd.on and not g.tbl.sssn_veh_plyr_affect.orgmc.on and not g.tbl.sssn_veh_plyr_affect.mddr.on then
					g.tbl.sssn_veh_plyr_affect.frnd.on=true
				end
			end)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.others,"g.tbl.sssn_veh_plyr_affect.others")

			g.tbl.sssn_veh_plyr_affect.force=menu_add_feature("Force check for player vehicle","toggle", g.tbl.sssn_stf.veh_trgt_prnt.id)
			funcs.add_to_S_L(g.tbl.sssn_veh_plyr_affect.force,"g.tbl.sssn_veh_plyr_affect.force")

			g.feat.sssn_veh_affect_plyrs.on=true
			g.feat.sssn_veh_affect_npc_street.on=true
			g.tbl.sssn_veh_plyr_affect.others.on=true
			g.tbl.sssn_veh_plyr_affect.pers.on=true

		g.tbl.sssn_stf.tp_prnt = menu_add_feature("Teleports", "parent", g.prnt.sssn_vehs.id)

		g.tbl.sssn_stf.hrn_bst = menu_add_feature("Horn", "parent", g.prnt.sssn_vehs.id)

		g.tbl.sssn_stf.opex_prnt = menu_add_feature("Hold Key Actions", "parent", g.prnt.sssn_vehs.id)

	g.tbl.sssn_stf.new = {}
	g.tbl.sssn_stf.new.feat_srch_table = {}
	g.tbl.spwn.spwn_plate_check("Session Vehicle Spawn")
	g.tbl.sssn_stf.new.spwn_plate_txt = g.tbl.spwn.spwn_plate_get("Session Vehicle Spawn")
	function g.tbl.sssn_stf.new.apply_upgrades(_veh)
		if funcs.is.ent(_veh) then
			funcs.ntwrk.ask_quick(_veh)
			API.veh.set.kit_type(_veh, 0)
			if g.tbl.sssn_stf.new.spwn_god.on then
				API.ent.set.god(_veh,true)
			end
			if g.tbl.sssn_stf.new.spwn_upg.on then
				if g.tbl.sssn_stf.new.spwn_upg.value == 0 then
					funcs.doo.veh_upgr_basic(_veh)
					funcs.doo.veh_upgr_perf(_veh)
					funcs.doo.veh_upgr_wheels(_veh)
					funcs.doo.veh_upgr_lights(_veh,"random")
					funcs.doo.veh_upgr_neons(_veh,"random")
					funcs.doo.veh_upgr_paint(_veh,"random")
					funcs.doo.veh_upgr_livery(_veh)
					funcs.doo.veh_weap_best(_veh)
					funcs.doo.veh_upgr_bombs(_veh)
					funcs.doo.veh_upgr_cntrmsrs(_veh)
				else
					funcs.doo.veh_upgr_perf(_veh)
				end
			end
			if g.tbl.sssn_stf.new.spwn_f1.on then
				funcs.doo.veh_upgr_wheels(_veh,"f1")
			end
			API.ent.set.max_speed(_veh, 45000)
			API.veh.set.top_speed(_veh, (g.tbl.sssn_stf.new.spwn_spd_tq.value/100 - 1) * 100)
			if g.tbl.sssn_stf.new.paint_list.rand_paint.on then
				if g.tbl.sssn_stf.new.paint_list.rand_paint.value == 0 then
					funcs.doo.veh_upgr_paint(_veh,"random")
				elseif g.tbl.sssn_stf.new.paint_list.rand_paint.value == 1 then
					funcs.doo.veh_upgr_paint(_veh,"random_solid")
				elseif g.tbl.sssn_stf.new.paint_list.rand_paint.value == 2 then
					funcs.doo.veh_upgr_paint(_veh,funcs.get.rand_paint_shade("Dark"))
				else
					funcs.doo.veh_upgr_paint(_veh,funcs.get.rand_paint_shade("Bright"))
				end
			elseif g.tbl.sssn_stf.new.paint_list.cust_paint.on then

				funcs.doo.veh_upgr_paint(_veh,(g.tbl.sssn_stf.new.spwn_cust_paint_r.value * 65536 + g.tbl.sssn_stf.new.spwn_cust_paint_g.value * 256 + g.tbl.sssn_stf.new.spwn_cust_paint_b.value))
			else
				funcs.doo.veh_upgr_paint(_veh,g.tbl.sssn_stf.new.paint_list_slct)
			end
			if g.tbl.sssn_stf.new.neon.choose.value == 0 then
				funcs.doo.veh_upgr_neons(_veh,"random")
			else
				funcs.doo.veh_upgr_neons(_veh,g.tbl.sssn_stf.new.neon_slct)
			end
			if g.tbl.sssn_stf.new.h_light.choose.value == 0 then
				funcs.doo.veh_upgr_lights(_veh,"random")
			else
				funcs.doo.veh_upgr_lights(_veh,g.tbl.sssn_stf.new.h_light_slct)
			end
			if g.tbl.sssn_stf.new.max_tint.on then
				vehicle.set_vehicle_window_tint(_veh,1)
			end
			if g.tbl.sssn_stf.new.invcn_wind.on then
				ntv.set.veh_invncbl_wndws(_veh,1)
			end
			if g.tbl.sssn_stf.new.plate_i.on then
				API.veh.set.plate_index(_veh, g.tbl.sssn_stf.new.plate_i.value)
			end
			if g.tbl.sssn_stf.new.plate.on then
				API.veh.set.plate_text(_veh, g.tbl.sssn_stf.new.spwn_plate_txt)
			end
			YIELD(0)
			g.tbl.spwn.history[#g.tbl.spwn.history+1]=_veh
		end
	end

	g.tbl.sssn_stf.new.optns_prnt=menu_add_feature("Options", "parent", g.tbl.sssn_stf.spwn_prnt.id)


	g.tbl.sssn_stf.new.qck_srch_optns = menu_add_feature("Quick Search Options", "parent", g.tbl.sssn_stf.new.optns_prnt.id)
	menu_add_feature("Display 'quick search' test", "action", g.tbl.sssn_stf.new.qck_srch_optns.id, function()
		local time = TIME_MS() + 10000
		local _table = {}
		for i=1,7 do
			_table[i] = veh_stuff.master[mth.rndm(1,#veh_stuff.master)]
		end
		while time > TIME_MS() do
			YIELD(0)
			g.tbl.spwn.ovrly_srch_show(_table, "Vehicle test - Session "..funcs.get.round_num((time - TIME_MS())/1000),0,g.tbl.sssn_stf.new.quick_x.value/300, g.tbl.sssn_stf.new.quick_y.value/300,false)
		end
	end)
	g.tbl.sssn_stf.new.quick_x = menu_add_feature("Quick search X Pos", "action_slider", g.tbl.sssn_stf.new.qck_srch_optns.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.quick_x,0,300,1,150,"g.tbl.sssn_stf.new.quick_x")

	g.tbl.sssn_stf.new.quick_y = menu_add_feature("Quick search Y Pos", "action_slider", g.tbl.sssn_stf.new.qck_srch_optns.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.quick_y,0,300,1,175,"g.tbl.sssn_stf.new.quick_y")

	g.tbl.sssn_stf.new.mk_mdl_clss_prnt=menu_add_feature("All vehicles by type", "parent", g.tbl.sssn_stf.spwn_prnt.id)
	g.tbl.sssn_stf.action_spwn = {}
	g.tbl.sssn_stf.temp_list_sort = {}
	for i=1,#veh_stuff.class_list do
		g.tbl.sssn_stf.temp_list_sort[i]={}
		for ii=1,#veh_stuff.master do
			if veh_stuff.master[ii][6] == veh_stuff.class_list[i] then
				g.tbl.sssn_stf.temp_list_sort[i][#g.tbl.sssn_stf.temp_list_sort[i]+1]=veh_stuff.master[ii]
			end
			g.load_break()
		end
		table.sort(g.tbl.sssn_stf.temp_list_sort[i], function(a, b) return a[1]:lower() <  b[1]:lower() end)
	end
	for i=1,#veh_stuff.class_list do
		g.tbl.sssn_stf.action_spwn[#g.tbl.sssn_stf.action_spwn+1] = menu_add_feature(veh_stuff.class_list[i], "parent",g.tbl.sssn_stf.new.mk_mdl_clss_prnt.id)
		for ii=1,#g.tbl.sssn_stf.temp_list_sort[i] do
			g.tbl.sssn_stf.temp_list_name = ""
			if g.tbl.sssn_stf.temp_list_sort[i][ii][2] == "" then
				g.tbl.sssn_stf.temp_list_name = g.tbl.sssn_stf.temp_list_sort[i][ii][1]
			else
				g.tbl.sssn_stf.temp_list_name = g.tbl.sssn_stf.temp_list_sort[i][ii][1].." - "..g.tbl.sssn_stf.temp_list_sort[i][ii][2]
			end
			og_menu_add_feature(g.tbl.sssn_stf.temp_list_name, "action", g.tbl.sssn_stf.action_spwn[i].id,function()
				funcs.doo.sssn_spawn_vehs(g.tbl.sssn_stf.temp_list_sort[i][ii][5])
			end)
			g.load_break()
		end
	end

	g.tbl.sssn_stf.new.spwn_upg = menu_add_feature("Upgrades", "value_str", g.tbl.sssn_stf.new.optns_prnt.id)
	new_set_str_data(g.tbl.sssn_stf.new.spwn_upg,{"All","Only performance"})
	funcs.add_to_S_L(g.tbl.sssn_stf.new.spwn_upg,"g.tbl.sssn_stf.new.spwn_upg")
	g.tbl.sssn_stf.new.spwn_upg.on=true

	g.tbl.sssn_stf.new.spwn_f1 = menu_add_feature("Always F1 Wheels", "toggle", g.tbl.sssn_stf.new.optns_prnt.id)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.spwn_f1,"g.tbl.sssn_stf.new.spwn_f1")

	g.tbl.sssn_stf.new.spwn_god = menu_add_feature("God-Mode", "toggle", g.tbl.sssn_stf.new.optns_prnt.id)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.spwn_god,"g.tbl.sssn_stf.new.spwn_god")

	g.tbl.sssn_stf.new.max_tint = menu_add_feature("Max tint", "toggle", g.tbl.sssn_stf.new.optns_prnt.id)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.max_tint,"g.tbl.sssn_stf.new.max_tint")

	g.tbl.sssn_stf.new.invcn_wind = menu_add_feature("Invincible windows", "toggle", g.tbl.sssn_stf.new.optns_prnt.id)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.invcn_wind,"g.tbl.sssn_stf.new.invcn_wind")

	g.tbl.sssn_stf.new.plate_i=menu_add_feature("Plate color", "value_str", g.tbl.sssn_stf.new.optns_prnt.id)
	new_set_str_data(g.tbl.sssn_stf.new.plate_i,{"Blue/White","Yellow/black","Yellow/Blue","Blue/White2","Blue/White3","Yankton"})
	funcs.add_to_S_L(g.tbl.sssn_stf.new.plate_i,"g.tbl.sssn_stf.new.plate_i")
	g.tbl.sssn_stf.new.plate_i.value=1
	g.tbl.sssn_stf.new.plate_i.on=true

	g.tbl.sssn_stf.new.plate = menu_add_feature("Plate text - "..g.tbl.sssn_stf.new.spwn_plate_txt, "toggle", g.tbl.sssn_stf.new.optns_prnt.id,function(f)
		if f.on and g.var.GS_has_loaded then
			local status,str = 1,""
			status,str = funcs.get.text_input("Non alpha-numeric characters act as blank space",g.tbl.spwn.spwn_plate_txt,8,0)
			if status == 0 then
				g.tbl.spwn.spwn_plate_check("Session Vehicle Spawn")
				g.tbl.spwn.spwn_plate_write(str,"Session Vehicle Spawn")
				g.tbl.sssn_stf.new.spwn_plate_txt=str
				f.name="Plate text - "..g.tbl.sssn_stf.new.spwn_plate_txt
			else
				f.on=false
			end
		end
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.plate,"g.tbl.sssn_stf.new.plate")
	g.tbl.sssn_stf.new.plate.on=true

	g.tbl.sssn_stf.new.spwn_spd_tq=menu_add_feature("Vehicle max speed/torque %","action_value_i", g.tbl.sssn_stf.new.optns_prnt.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.spwn_spd_tq,0,700,5,100,"g.tbl.sssn_stf.new.spwn_spd_tq")


	----------------------------------------------------------------------------------------------------------------------------------------------------------aaa
	g.tbl.sssn_stf.new.paint_prnts_new = {}
	g.tbl.sssn_stf.new.paint_prnt = menu_add_feature("Paint", "parent", g.tbl.sssn_stf.new.optns_prnt.id)

	g.tbl.sssn_stf.new.paint_list_slct = nil
	g.tbl.sssn_stf.new.paint_list={}

	g.tbl.sssn_stf.new.paint_list.rand_paint = menu_add_feature("Random paint", "value_str", g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.rand_paint,nil)
	end)
	new_set_str_data(g.tbl.sssn_stf.new.paint_list.rand_paint,{"Non-matching", "Matching","Dark","Bright"})
	funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.rand_paint,"g.tbl.sssn_stf.new.paint_list.rand_paint")
	g.tbl.sssn_stf.new.paint_list.rand_paint.on=true

	g.tbl.sssn_stf.new.paint_list.cust_paint = menu_add_feature("Custom paint", "toggle", g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.cust_paint,nil)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.cust_paint,"g.tbl.sssn_stf.new.paint_list.cust_paint")

	g.tbl.sssn_stf.new.spwn_cust_paint_r=menu_add_feature("Custom Red","autoaction_value_i",g.tbl.sssn_stf.new.paint_prnt.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.spwn_cust_paint_r,0,255,1,0,"g.tbl.sssn_stf.new.spwn_cust_paint_r")

	g.tbl.sssn_stf.new.spwn_cust_paint_g=menu_add_feature("Custom Green","autoaction_value_i",g.tbl.sssn_stf.new.paint_prnt.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.spwn_cust_paint_g,0,255,1,0,"g.tbl.sssn_stf.new.spwn_cust_paint_g")

	g.tbl.sssn_stf.new.spwn_cust_paint_b=menu_add_feature("Custom Blue","autoaction_value_i",g.tbl.sssn_stf.new.paint_prnt.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.new.spwn_cust_paint_b,0,255,1,0,"g.tbl.sssn_stf.new.spwn_cust_paint_b")

	function g.tbl.sssn_stf.new.paint_tog_do(_bool,_feat,_paint)
		if _bool then
			if _paint then
				g.tbl.sssn_stf.new.paint_list_slct=_paint
			end
			for _, feat in pairs(g.tbl.sssn_stf.new.paint_list) do
				if feat ~=_feat then
					feat.on = false
				end
			end
		else
			local is_one_on = false
			for _, feat in pairs(g.tbl.sssn_stf.new.paint_list) do
				if feat.on then
					is_one_on=true
					break
				end
			end
			if not is_one_on then
				g.tbl.sssn_stf.new.paint_list.rand_paint.on=true
			end
		end
	end




	for k,v in ipairs (g.tbl.paints2) do
		local t = paints[v]
		if type(t) == "table" then
			g.tbl.sssn_stf.new.paint_prnts_new[v]=menu_add_feature(v,"parent",g.tbl.sssn_stf.new.paint_prnt.id)
			for kk,vv in ipairs (t) do
				local str = v.."|"..vv.NAME
				g.tbl.sssn_stf.new.paint_list[str]=og_menu_add_feature(vv.NAME_IN_COLOR,"toggle",g.tbl.sssn_stf.new.paint_prnts_new[v].id,function(f)
					g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list[str],vv.INT)
				end)
				funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list[str],"g.tbl.sssn_stf.new.paint_list."..str)
			end
		end
	end

	-- g.tbl.sssn_stf.new.paint_list.pnt_Purewhite=menu_add_feature("Pure white","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Purewhite,16777215)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Purewhite,"g.tbl.sssn_stf.new.paint_list.pnt_Purewhite")

	-- g.tbl.sssn_stf.new.paint_list.pnt_White=menu_add_feature("White","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_White,13487565)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_White,"g.tbl.sssn_stf.new.paint_list.pnt_White")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Cream=menu_add_feature("Cream","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Cream,10197915)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Cream,"g.tbl.sssn_stf.new.paint_list.pnt_Cream")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Grey=menu_add_feature("Grey","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Grey,5066061)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Grey,"g.tbl.sssn_stf.new.paint_list.pnt_Grey")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Black=menu_add_feature("Black","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Black,0)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Black,"g.tbl.sssn_stf.new.paint_list.pnt_Black")

	-- g.tbl.sssn_stf.new.paint_list.pnt_PastelPink=menu_add_feature("Pastel Pink","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_PastelPink,15767961)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_PastelPink,"g.tbl.sssn_stf.new.paint_list.pnt_PastelPink")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Pink=menu_add_feature("Pink","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Pink,13317780)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Pink,"g.tbl.sssn_stf.new.paint_list.pnt_Pink")

	-- g.tbl.sssn_stf.new.paint_list.pnt_PinkRed=menu_add_feature("Pink/Red","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_PinkRed,14692914)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_PinkRed,"g.tbl.sssn_stf.new.paint_list.pnt_PinkRed")

	-- g.tbl.sssn_stf.new.paint_list.pnt_WineRed=menu_add_feature("Wine Red","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_WineRed,3014656)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_WineRed,"g.tbl.sssn_stf.new.paint_list.pnt_WineRed")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Red=menu_add_feature("Red","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Red,7346457)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Red,"g.tbl.sssn_stf.new.paint_list.pnt_Red")

	-- g.tbl.sssn_stf.new.paint_list.pnt_BrightRed=menu_add_feature("Bright Red","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_BrightRed,16711680)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_BrightRed,"g.tbl.sssn_stf.new.paint_list.pnt_BrightRed")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Salmon=menu_add_feature("Salmon","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Salmon,16761514)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Salmon,"g.tbl.sssn_stf.new.paint_list.pnt_Salmon")

	-- g.tbl.sssn_stf.new.paint_list.pnt_BrightBlue=menu_add_feature("Bright Blue","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_BrightBlue,56306)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_BrightBlue,"g.tbl.sssn_stf.new.paint_list.pnt_BrightBlue")

	-- g.tbl.sssn_stf.new.paint_list.pnt_LightBlue=menu_add_feature("Light Blue","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_LightBlue,6141669)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_LightBlue,"g.tbl.sssn_stf.new.paint_list.pnt_LightBlue")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Teal=menu_add_feature("Teal","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Teal,3103859)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Teal,"g.tbl.sssn_stf.new.paint_list.pnt_Teal")

	-- g.tbl.sssn_stf.new.paint_list.pnt_RoyalBlue=menu_add_feature("Royal Blue","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_RoyalBlue,18309)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_RoyalBlue,"g.tbl.sssn_stf.new.paint_list.pnt_RoyalBlue")

	-- g.tbl.sssn_stf.new.paint_list.pnt_CreamYellow=menu_add_feature("Cream Yellow","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_CreamYellow,16706473)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_CreamYellow,"g.tbl.sssn_stf.new.paint_list.pnt_CreamYellow")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Yellow=menu_add_feature("Yellow","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Yellow,15779920)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Yellow,"g.tbl.sssn_stf.new.paint_list.pnt_Yellow")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Mustard=menu_add_feature("Mustard","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Mustard,8284969)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Mustard,"g.tbl.sssn_stf.new.paint_list.pnt_Mustard")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Brightyellow=menu_add_feature("Bright yellow","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Brightyellow,16757504)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Brightyellow,"g.tbl.sssn_stf.new.paint_list.pnt_Brightyellow")

	-- g.tbl.sssn_stf.new.paint_list.pnt_Schoolbus=menu_add_feature("Schoolbus","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_Schoolbus,16750350)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_Schoolbus,"g.tbl.sssn_stf.new.paint_list.pnt_Schoolbus")

	-- g.tbl.sssn_stf.new.paint_list.pnt_DarkOrange=menu_add_feature("Dark Orange","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_DarkOrange,8340010)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_DarkOrange,"g.tbl.sssn_stf.new.paint_list.pnt_DarkOrange")

	-- g.tbl.sssn_stf.new.paint_list.pnt_CreamGreen=menu_add_feature("Cream Green","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_CreamGreen,12183225)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_CreamGreen,"g.tbl.sssn_stf.new.paint_list.pnt_CreamGreen")

	-- g.tbl.sssn_stf.new.paint_list.pnt_LightGreen=menu_add_feature("Light Green","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_LightGreen,7523442)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_LightGreen,"g.tbl.sssn_stf.new.paint_list.pnt_LightGreen")

	-- g.tbl.sssn_stf.new.paint_list.pnt_BrightGreen=menu_add_feature("Bright Green","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_BrightGreen,2803792)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_BrightGreen,"g.tbl.sssn_stf.new.paint_list.pnt_BrightGreen")

	-- g.tbl.sssn_stf.new.paint_list.pnt_DarkGreen=menu_add_feature("Dark Green","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_DarkGreen,3761721)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_DarkGreen,"g.tbl.sssn_stf.new.paint_list.pnt_DarkGreen")

	-- g.tbl.sssn_stf.new.paint_list.pnt_CreamPurple=menu_add_feature("Cream Purple","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_CreamPurple,12628975)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_CreamPurple,"g.tbl.sssn_stf.new.paint_list.pnt_CreamPurple")

	-- g.tbl.sssn_stf.new.paint_list.pnt_BrightPurple=menu_add_feature("Bright Purple","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_BrightPurple,8677090)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_BrightPurple,"g.tbl.sssn_stf.new.paint_list.pnt_BrightPurple")

	-- g.tbl.sssn_stf.new.paint_list.pnt_DarkPurple=menu_add_feature("Dark Purple","toggle",g.tbl.sssn_stf.new.paint_prnt.id,function(f)
		-- g.tbl.sssn_stf.new.paint_tog_do(f.on,g.tbl.sssn_stf.new.paint_list.pnt_DarkPurple,4405615)
	-- end)
	-- funcs.add_to_S_L(g.tbl.sssn_stf.new.paint_list.pnt_DarkPurple,"g.tbl.sssn_stf.new.paint_list.pnt_DarkPurple")

	--g.tbl.sssn_stf.new.paint_list.pnt_DarkGreen.on=true

	g.tbl.sssn_stf.new.neon = {}
	g.tbl.sssn_stf.new.neon.list={}
	g.tbl.sssn_stf.new.neon_slct=nil
	function g.tbl.sssn_stf.new.neon_tog_do(_bool,_feat,_neon)
		if _bool then
			g.tbl.sssn_stf.new.neon_slct=_neon
			for _, feat in pairs(g.tbl.sssn_stf.new.neon.list) do
				if feat ~=_feat then
					feat.on = false
				end
			end
		end
	end

	function g.tbl.sssn_stf.new.hide_neon(_bool)
		YIELD(0)
		if _bool then
			for _, feat in pairs (g.tbl.sssn_stf.new.neon.list) do
				feat.hidden=(g.tbl.sssn_stf.new.neon.choose.value==0)
			end
		end
	end

	g.tbl.sssn_stf.new.neon.prnt = menu_add_feature("Neon lights", "parent", g.tbl.sssn_stf.new.optns_prnt.id, function (f)
		g.tbl.sssn_stf.new.hide_neon(g.tbl.sssn_stf.new.neon.choose.value==0)
	end)


	g.tbl.sssn_stf.new.neon.choose=menu_add_feature("Neon color","autoaction_value_str",g.tbl.sssn_stf.new.neon.prnt.id,function(f)
		g.tbl.sssn_stf.new.hide_neon(true)
	end)
	new_set_str_data(g.tbl.sssn_stf.new.neon.choose,{"Random","List"})
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.choose,"g.tbl.sssn_stf.new.neon.choose")

	g.tbl.sssn_stf.new.neon.list.White=menu_add_feature("White", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.White,4292796159)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.White,"g.tbl.sssn_stf.new.neon.list.White")

	g.tbl.sssn_stf.new.neon.list.Blue=menu_add_feature("Blue", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.Blue,4278326783)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.Blue,"g.tbl.sssn_stf.new.neon.list.Blue")

	g.tbl.sssn_stf.new.neon.list.ElectricBlue=menu_add_feature("Electric Blue", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.ElectricBlue,4278408191)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.ElectricBlue,"g.tbl.sssn_stf.new.neon.list.ElectricBlue")

	g.tbl.sssn_stf.new.neon.list.MintGreen=menu_add_feature("Mint Green", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.MintGreen,4278255500)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.MintGreen,"g.tbl.sssn_stf.new.neon.list.MintGreen")

	g.tbl.sssn_stf.new.neon.list.LimeGreen=menu_add_feature("Lime Green", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.LimeGreen,4284415745)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.LimeGreen,"g.tbl.sssn_stf.new.neon.list.LimeGreen")

	g.tbl.sssn_stf.new.neon.list.Yellow=menu_add_feature("Yellow", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.Yellow,4294967040)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.Yellow,"g.tbl.sssn_stf.new.neon.list.Yellow")

	g.tbl.sssn_stf.new.neon.list.GoldenShower=menu_add_feature("Golden Shower", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.GoldenShower,4294940165)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.GoldenShower,"g.tbl.sssn_stf.new.neon.list.GoldenShower")

	g.tbl.sssn_stf.new.neon.list.Orange=menu_add_feature("Orange", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.Orange,4294917632)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.Orange,"g.tbl.sssn_stf.new.neon.list.Orange")

	g.tbl.sssn_stf.new.neon.list.Red=menu_add_feature("Red", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.Red,4294902017)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.Red,"g.tbl.sssn_stf.new.neon.list.Red")

	g.tbl.sssn_stf.new.neon.list.PonyPink=menu_add_feature("Pony Pink", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.PonyPink,4294914660)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.PonyPink,"g.tbl.sssn_stf.new.neon.list.PonyPink")

	g.tbl.sssn_stf.new.neon.list.HotPink=menu_add_feature("Hot Pink", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.HotPink,4294903230)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.HotPink,"g.tbl.sssn_stf.new.neon.list.HotPink")

	g.tbl.sssn_stf.new.neon.list.Purple=menu_add_feature("Purple", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.Purple,4280484351)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.Purple,"g.tbl.sssn_stf.new.neon.list.Purple")

	g.tbl.sssn_stf.new.neon.list.BlackLight=menu_add_feature("Black Light", "toggle", g.tbl.sssn_stf.new.neon.prnt.id, function (f)
		g.tbl.sssn_stf.new.neon_tog_do(f.on,g.tbl.sssn_stf.new.neon.list.BlackLight,4279174143)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.neon.list.BlackLight,"g.tbl.sssn_stf.new.neon.list.BlackLight")

	g.tbl.sssn_stf.new.neon.list.MintGreen.on=true

	g.tbl.sssn_stf.new.h_light={}
	g.tbl.sssn_stf.new.h_light.list={}
	g.tbl.sssn_stf.new.h_light_slct=nil

	function g.tbl.sssn_stf.new.h_light_tog_do(_bool,_feat,_h_light)
		if _bool then
			g.tbl.sssn_stf.new.h_light_slct=_h_light
			for _, feat in pairs(g.tbl.sssn_stf.new.h_light.list) do
				if feat ~=_feat then
					feat.on = false
				end
			end
		end
	end

	function g.tbl.sssn_stf.new.hide_h_light(_bool)
		YIELD(0)
		if _bool then
			for _, feat in pairs (g.tbl.sssn_stf.new.h_light.list) do
				feat.hidden=(g.tbl.sssn_stf.new.h_light.choose.value==0)
			end
		end
	end

	g.tbl.sssn_stf.new.h_light.prnt = menu_add_feature("Headlights", "parent", g.tbl.sssn_stf.new.optns_prnt.id, function (f)
		g.tbl.sssn_stf.new.hide_h_light(g.tbl.sssn_stf.new.h_light.choose.value==0)
	end)


	g.tbl.sssn_stf.new.h_light.choose=menu_add_feature("Headlight color","autoaction_value_str",g.tbl.sssn_stf.new.h_light.prnt.id,function(f)
		g.tbl.sssn_stf.new.hide_h_light(true)
	end)
	new_set_str_data(g.tbl.sssn_stf.new.h_light.choose,{"Random","List"})
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.choose,"g.tbl.sssn_stf.new.h_light.choose")

	g.tbl.sssn_stf.new.h_light.list.White=menu_add_feature("White", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.White,0)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.White,"g.tbl.sssn_stf.new.h_light.list.White")

	g.tbl.sssn_stf.new.h_light.list.Blue=menu_add_feature("Blue", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.Blue,1)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.Blue,"g.tbl.sssn_stf.new.h_light.list.Blue")

	g.tbl.sssn_stf.new.h_light.list.ElectricBlue=menu_add_feature("Electric Blue", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.ElectricBlue,2)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.ElectricBlue,"g.tbl.sssn_stf.new.h_light.list.ElectricBlue")

	g.tbl.sssn_stf.new.h_light.list.MintGreen=menu_add_feature("Mint Green", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.MintGreen,3)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.MintGreen,"g.tbl.sssn_stf.new.h_light.list.MintGreen")

	g.tbl.sssn_stf.new.h_light.list.LimeGreen=menu_add_feature("Lime Green", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.LimeGreen,4)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.LimeGreen,"g.tbl.sssn_stf.new.h_light.list.LimeGreen")

	g.tbl.sssn_stf.new.h_light.list.Yellow=menu_add_feature("Yellow", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.Yellow,5)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.Yellow,"g.tbl.sssn_stf.new.h_light.list.Yellow")

	g.tbl.sssn_stf.new.h_light.list.GoldenShower=menu_add_feature("Golden Shower", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.GoldenShower,6)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.GoldenShower,"g.tbl.sssn_stf.new.h_light.list.GoldenShower")

	g.tbl.sssn_stf.new.h_light.list.Orange=menu_add_feature("Orange", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.Orange,7)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.Orange,"g.tbl.sssn_stf.new.h_light.list.Orange")

	g.tbl.sssn_stf.new.h_light.list.Red=menu_add_feature("Red", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.Red,8)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.Red,"g.tbl.sssn_stf.new.h_light.list.Red")

	g.tbl.sssn_stf.new.h_light.list.PonyPink=menu_add_feature("Pony Pink", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.PonyPink,9)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.PonyPink,"g.tbl.sssn_stf.new.h_light.list.PonyPink")

	g.tbl.sssn_stf.new.h_light.list.HotPink=menu_add_feature("Hot Pink", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.HotPink,10)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.HotPink,"g.tbl.sssn_stf.new.h_light.list.HotPink")

	g.tbl.sssn_stf.new.h_light.list.Purple=menu_add_feature("Purple", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.Purple,11)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.Purple,"g.tbl.sssn_stf.new.h_light.list.Purple")

	g.tbl.sssn_stf.new.h_light.list.BlackLight=menu_add_feature("Black Light", "toggle", g.tbl.sssn_stf.new.h_light.prnt.id, function (f)
		g.tbl.sssn_stf.new.h_light_tog_do(f.on,g.tbl.sssn_stf.new.h_light.list.BlackLight,12)
	end)
	funcs.add_to_S_L(g.tbl.sssn_stf.new.h_light.list.BlackLight,"g.tbl.sssn_stf.new.h_light.list.BlackLight")

	g.tbl.sssn_stf.new.h_light.list.MintGreen.on=true

	g.tbl.sssn_stf.spwn_srch_prnt=menu_add_feature("Make/Model search list", "parent", g.tbl.sssn_stf.spwn_prnt.id)

	g.tbl.sssn_stf.list_spwn = {}
	g.tbl.sssn_stf.list_spwn_temp = {}
	g.tbl.sssn_stf.list_spwn_feat=menu_add_feature("Search for vehicles", "action_value_str", g.tbl.sssn_stf.spwn_srch_prnt.id, function(f)
		local status,str,veh = 1
		status,str = funcs.get.text_input("Vehicle Make/Model","",25,0)
		if status == 0 then
			g.tbl.sssn_stf.list_spwn_temp = {}
			g.tbl.spwn.ovrly_srch_do(str,f.value,g.tbl.sssn_stf.list_spwn_temp)
			if #g.tbl.sssn_stf.list_spwn_temp > 0 then
				for i=1,#g.tbl.sssn_stf.list_spwn do
					YIELD(0)
					if g.tbl.sssn_stf.list_spwn[i] ~= nil then menu.delete_feature(g.tbl.sssn_stf.list_spwn[i].id) end
				end
				g.tbl.sssn_stf.list_spwn = {}
				for i=1,#g.tbl.sssn_stf.list_spwn_temp do
					if f.value == 0 then
						g.tbl.sssn_stf.list_spwn[#g.tbl.sssn_stf.list_spwn+1]=menu_add_feature(g.tbl.sssn_stf.list_spwn_temp[i][1], "action", g.tbl.sssn_stf.spwn_srch_prnt.id,function(f,pid)
							funcs.doo.sssn_spawn_vehs(g.tbl.sssn_stf.list_spwn_temp[i][5])
						end)
					else
						g.tbl.sssn_stf.list_spwn[#g.tbl.sssn_stf.list_spwn+1]=menu_add_feature(g.tbl.sssn_stf.list_spwn_temp[i][3], "action", g.tbl.sssn_stf.spwn_srch_prnt.id,function(f,pid)
							funcs.doo.sssn_spawn_vehs(g.tbl.sssn_stf.list_spwn_temp[i][5])
						end)
					end
				end
			end
		end
	end)
	new_set_str_data(g.tbl.sssn_stf.list_spwn_feat,{"Model", "Make","Make or Model"})

	g.tbl.sssn_stf.quick_spwn_prnt=menu_add_feature("Quick spawn list", "parent", g.tbl.sssn_stf.spwn_prnt.id)
	g.tbl.sssn_stf.quick_spawn_feats = {}
	for i=1, #g.tbl.spwn.quick_spawn_list do
		if veh_stuff.info[API.get_hash_key(g.tbl.spwn.quick_spawn_list[i])]~= nil then
			g.tbl.sssn_stf.quick_spawn_feats[i]=og_menu_add_feature(veh_stuff.info[API.get_hash_key(g.tbl.spwn.quick_spawn_list[i])].MODEL, "action", g.tbl.sssn_stf.quick_spwn_prnt.id,function()
				funcs.doo.req_model(API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]))
				funcs.doo.sssn_spawn_vehs(API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]))
			end)
			g.tbl.spawn_veh_feature_p.quick.feats[i]=og_menu_add_player_feature(veh_stuff.info[API.get_hash_key(g.tbl.spwn.quick_spawn_list[i])].MODEL, "action", g.tbl.spawn_veh_feature_p.quick.prnt.id,function(f,pid)
				if intrr.is_pid_intrr(pid) then
					g.N_P(2,funcs.get.pid_name(pid) .. "\nIn interior.",__GV__,4,"Blue")
				else
					funcs.doo.req_model(API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]))
					local veh = funcs.doo.spawn_veh_at_pid(pid,API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]),true)
				end
			end)
			g.tbl.spwn.quick_spawn_feats[i]=og_menu_add_feature(veh_stuff.info[API.get_hash_key(g.tbl.spwn.quick_spawn_list[i])].MODEL, "action", g.tbl.spwn.quick_spwn_prnt.id,function()
				if g.tbl.spwn.remove_old.on and funcs.ntwrk.ask_long(g.tbl.spwn.old_veh,250) then
					API.ent.set.no_need(g.tbl.spwn.old_veh)
					API.ent.delete(g.tbl.spwn.old_veh)
				end
				funcs.doo.req_model(API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]))
				local veh = funcs.doo.spawn_veh_at_pid(API.plyr.my_id(),API.get_hash_key(g.tbl.spwn.quick_spawn_list[i]),false,g.tbl.spwn.spwn_front.value==0)
				g.tbl.spwn.apply_upgrades(veh)
			end)
		end
	end
	g.tbl.sssn_stf.quick_spwn = {}
	menu_add_feature("Quick search on-screen", "action", g.tbl.sssn_stf.spwn_prnt.id, function(f)
		g.tbl.spwn.quick_start(g.tbl.sssn_stf.quick_spwn,"Vehicle Spawn - Session",true)
	end)

	function funcs.doo.sssn_spawn_vehs(_hash)
		local pid_table = funcs.get.sssn_pid_plyr_table(true,true)
		if #pid_table == 0 then
			g.N_P(2,"No available players from selection.",__GV__,4,"Yellow")
		else
			local count = 0
			funcs.doo.req_model(_hash)
			for i=1,#pid_table do
				local veh = funcs.doo.spawn_veh_at_pid(pid_table[i],_hash,true)
				if not funcs.is.ent(veh) then
					break
				else
					count=count+1
				end
			end
			g.N_P(2,count.."/"..#pid_table.." vehicles spawned.",__GV__,4,"Blue")
		end
	end

	g.tbl.sssn_stf.hold = {}

	g.tbl.sssn_stf.hold.show_rpr=false
	g.tbl.sssn_stf.hold.show_rpr_time=5000
	g.tbl.sssn_stf.hold.rpr=menu_add_feature("Hold (R) repair nearby veh", "value_i", g.tbl.sssn_stf.opex_prnt.id, function(f)
		local f_value,key = f.value
		while f.on do
			YIELD(25)
			key = inputs.vk_list[g.tbl.sssn_stf.hold.rpr_key.value+1]
			f.name = "Hold ("..key..") repair nearby veh"
			if f_value ~= f.value then
				g.tbl.sssn_stf.hold.show_rpr_time=5000
				g.tbl.sssn_stf.hold.show_rpr=true
				g.tbl.sssn_stf.hold.show_debug.on=true
				f_value = f.value
			end
			if g.tbl.sssn_stf.hold.chk(key) and g.tbl.sssn_stf.hold._do("repair",f.value) and g.tbl.sssn_stf.hold.show_in_use.on then
				g.tbl.sssn_stf.hold.show_rpr_time=3000
				g.tbl.sssn_stf.hold.show_rpr=true
				g.tbl.sssn_stf.hold.show_debug.on=true
			end
			while funcs.is.vk_key_down(key) do
				YIELD(0)
			end
		end
	end)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hold.rpr,5,100,5,15,"g.tbl.sssn_stf.hold.rpr")

	g.tbl.sssn_stf.hold.show_upgrd=false
	g.tbl.sssn_stf.hold.show_upgrd_time=5000
	g.tbl.sssn_stf.hold.upgrd=menu_add_feature("Hold (U) upgrade nearby veh", "value_i", g.tbl.sssn_stf.opex_prnt.id, function(f)
		local f_value,key = f.value
		while f.on do
			YIELD(25)
			key = inputs.vk_list[g.tbl.sssn_stf.hold.upgrd_key.value+1]
			f.name = "Hold ("..key..") upgrade nearby veh"
			if f_value ~= f.value then
				g.tbl.sssn_stf.hold.show_upgrd_time=5000
				g.tbl.sssn_stf.hold.show_upgrd=true
				g.tbl.sssn_stf.hold.show_debug.on=true
				f_value = f.value
			end
			if g.tbl.sssn_stf.hold.chk(key) and g.tbl.sssn_stf.hold._do("upgrades",f.value) and g.tbl.sssn_stf.hold.show_in_use.on then
				g.tbl.sssn_stf.hold.show_upgrd_time=3000
				g.tbl.sssn_stf.hold.show_upgrd=true
				g.tbl.sssn_stf.hold.show_debug.on=true
			end
			while funcs.is.vk_key_down(key) do
				YIELD(0)
			end
		end
	end)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hold.upgrd,5,100,5,15,"g.tbl.sssn_stf.hold.upgrd")

	g.tbl.sssn_stf.hold.show_dstry=false
	g.tbl.sssn_stf.hold.show_dstry_time=5000
	g.tbl.sssn_stf.hold.dstry=menu_add_feature("Hold (~) destroy nearby veh", "value_i", g.tbl.sssn_stf.opex_prnt.id, function(f)
		local f_value,key = f.value
		while f.on do
			YIELD(25)
			key = inputs.vk_list[g.tbl.sssn_stf.hold.dstry_key.value+1]
			f.name = "Hold ("..key..") destroy nearby veh"
			if f_value ~= f.value then
				g.tbl.sssn_stf.hold.show_dstry_time=5000
				g.tbl.sssn_stf.hold.show_dstry=true
				g.tbl.sssn_stf.hold.show_debug.on=true
				f_value = f.value
			end
			if g.tbl.sssn_stf.hold.chk(key) and g.tbl.sssn_stf.hold._do("destroy",f.value) and g.tbl.sssn_stf.hold.show_in_use.on then
				g.tbl.sssn_stf.hold.show_dstry_time=3000
				g.tbl.sssn_stf.hold.show_dstry=true
				g.tbl.sssn_stf.hold.show_debug.on=true
			end
			while funcs.is.vk_key_down(key) do
				YIELD(0)
			end
		end
	end)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hold.dstry,5,100,5,15,"g.tbl.sssn_stf.hold.dstry")

	g.tbl.sssn_stf.hold.time=menu_add_feature("Hold delay (ms)", "action_value_i", g.tbl.sssn_stf.opex_prnt.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hold.time,250,1500,25,750,"g.tbl.sssn_stf.hold.time")

	g.tbl.sssn_stf.hold.show_in_use=menu_add_feature("Show range when in use", "toggle", g.tbl.sssn_stf.opex_prnt.id)
	funcs.add_to_S_L(g.tbl.sssn_stf.hold.show_in_use,"g.tbl.sssn_stf.hold.show_in_use")

	g.tbl.sssn_stf.hold.rpr_key=og_menu_add_feature("Key1 for Hold Repair HIDDEN","autoaction_value_str",g.tbl.sssn_stf.opex_prnt.id)
	g.tbl.sssn_stf.hold.rpr_key:set_str_data(inputs.vk_list)
	funcs.add_to_S_L(g.tbl.sssn_stf.hold.rpr_key,"g.tbl.sssn_stf.hold.rpr_key")
	g.tbl.sssn_stf.hold.rpr_key.hidden=true
	g.tbl.sssn_stf.hold.rpr_key.value=17

	menu_add_feature("Set key for repair","action",g.tbl.sssn_stf.opex_prnt.id,function()
		funcs.doo.set_keybinds(1,"Repair hold",g.tbl.sssn_stf.hold.rpr_key)
	end)

	g.tbl.sssn_stf.hold.upgrd_key=og_menu_add_feature("Key1 for Hold Upgrade HIDDEN","autoaction_value_str",g.tbl.sssn_stf.opex_prnt.id)
	g.tbl.sssn_stf.hold.upgrd_key:set_str_data(inputs.vk_list)
	funcs.add_to_S_L(g.tbl.sssn_stf.hold.upgrd_key,"g.tbl.sssn_stf.hold.upgrd_key")
	g.tbl.sssn_stf.hold.upgrd_key.hidden=true
	g.tbl.sssn_stf.hold.upgrd_key.value=20

	menu_add_feature("Set key for upgrade","action",g.tbl.sssn_stf.opex_prnt.id,function()
		funcs.doo.set_keybinds(1,"Upgrade hold",g.tbl.sssn_stf.hold.upgrd_key)
	end)

	g.tbl.sssn_stf.hold.dstry_key=og_menu_add_feature("Key1 for Hold Destroy HIDDEN","autoaction_value_str",g.tbl.sssn_stf.opex_prnt.id)
	g.tbl.sssn_stf.hold.dstry_key:set_str_data(inputs.vk_list)
	funcs.add_to_S_L(g.tbl.sssn_stf.hold.dstry_key,"g.tbl.sssn_stf.hold.dstry_key")
	g.tbl.sssn_stf.hold.dstry_key.hidden=true
	g.tbl.sssn_stf.hold.dstry_key.value=63

	menu_add_feature("Set key for destroy","action",g.tbl.sssn_stf.opex_prnt.id,function()
		funcs.doo.set_keybinds(1,"Destroy hold",g.tbl.sssn_stf.hold.dstry_key)
	end)

	g.tbl.sssn_stf.hold.show_debug=og_menu_add_feature("Show  debugs HIDDEN", "toggle", g.tbl.sssn_stf.opex_prnt.id,function(f)
		local time,red_time,green_time,blue_time = TIME_MS() + 5000,TIME_MS(),TIME_MS(),TIME_MS()
		while time > TIME_MS() do
			YIELD(5)
			if g.tbl.sssn_stf.hold.show_rpr then
				green_time = TIME_MS()+g.tbl.sssn_stf.hold.show_rpr_time
				time = TIME_MS() + 5000
				g.tbl.sssn_stf.hold.show_rpr=false
			end
			if green_time > TIME_MS() then
				graphics.draw_marker(28, API.plyr.get.coords(API.plyr.my_id()), funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), funcs.vec(g.tbl.sssn_stf.hold.rpr.value, g.tbl.sssn_stf.hold.rpr.value, g.tbl.sssn_stf.hold.rpr.value), 0, 255, 0, mth.flr((green_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
			end
			if g.tbl.sssn_stf.hold.show_upgrd then
				blue_time = TIME_MS()+g.tbl.sssn_stf.hold.show_upgrd_time
				time = TIME_MS() + 5000
				g.tbl.sssn_stf.hold.show_upgrd=false
			end
			if blue_time > TIME_MS() then
				graphics.draw_marker(28, API.plyr.get.coords(API.plyr.my_id()), funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), funcs.vec(g.tbl.sssn_stf.hold.upgrd.value, g.tbl.sssn_stf.hold.upgrd.value, g.tbl.sssn_stf.hold.upgrd.value), 0, 0, 255, mth.flr((blue_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
			end
			if g.tbl.sssn_stf.hold.show_dstry then
				red_time = TIME_MS()+g.tbl.sssn_stf.hold.show_dstry_time
				time = TIME_MS() + 5000
				g.tbl.sssn_stf.hold.show_dstry=false
			end
			if red_time > TIME_MS() then
				graphics.draw_marker(28, API.plyr.get.coords(API.plyr.my_id()), funcs.vec(0, 90, 0), funcs.vec(0, 90, 0), funcs.vec(g.tbl.sssn_stf.hold.dstry.value, g.tbl.sssn_stf.hold.dstry.value, g.tbl.sssn_stf.hold.dstry.value), 255, 0, 0, mth.flr((red_time-TIME_MS()) /1000/5*100), false, false, 2, false, nil, "MarkerTypeDebugSphere", false)
			end
		end
		f.on=false
	end)g.tbl.sssn_stf.hold.show_debug.hidden=true

	function g.tbl.sssn_stf.hold.chk(_key_name)
		local time = TIME_MS() + g.tbl.sssn_stf.hold.time.value
		while funcs.is.vk_key_down(_key_name) do
			YIELD(0)
			if time < TIME_MS() then
				return true
			end
		end
		return false
	end

	function g.tbl.sssn_stf.hold._do(_action,_dist)
		local all_veh,found=funcs.get.closest_vehs()
		for i=1,#all_veh do
			continue=false
			if funcs.get.dist_me_ent_3d(all_veh[i]) > _dist then
				break
			elseif funcs.is.sssn_veh_check(all_veh[i],true) then
				found=true
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local __veh,__action=all_veh[i],_action
					funcs.doo.veh_action_list(__veh,1000,__action,nil)
				end)
			end
		end
		return found
	end

	g.tbl.sssn_action_str={
	["god"] = "God",
	["collision"] = "Collision",
	["repair"] = "Repair",
	["damage"] = "Damage",
	["destroy"] = "Destroy",
	["health"] = "Health drop",
	["armor"] = "Armor drop",
	["anti_lock"] = "Anti-lock",
	["speed_torque"] = "Speed/torque",
	["fucked"] = "Fucks",
	["upgrades"] = "Upgrades",
	["perf"] = "Performance upgrade",
	["wheels"] = "Wheels/Tires upgrade",
	["f1"] = "F1 Wheels upgrade",
	["headlights"] = "Headlights upgrade",
	["neons"] = "Neon lights upgrade",
	["paint"] = "Paintjob upgrade",
	["livery"] = "Livery upgrade",
	["weapons"] = "Weapons upgrade",
	["upgrade_single"] = "Upgrade",
	["veh_kick"] = "Kicks",
	["remove_rotor"] = "Helicopter fuck",
	["rmv_veh_weap"] = "Weapon removal",
	["pop_tires"] = "Tire pops",
	["unpop_tires"] = "Tire repairs",
	["visible"] = "Visibilty",
	["tp"] = "Teleport",
	["tp_up"] = "Teleport",
	["tp_2_me"] = "Teleport",
	["random"] = "Teleport",
	["plyr_explodes"] = "Explosion",
	["plyr_burns"] = "Burns",
	["sparrow"] = "Sparrow drops",
	["repair_auto"] = "Auto-Repair",
	["repair_auto"] = "Auto-Repair",
	["horn_stop"] = "Horn stop",
	["horn_honk"] = "Horn honk",
	["horn_boost"] = "Horn boost",
	["flip_wrong"] = "Flip",
	["burn"] = "Burn with fire",
	["explode"] = "Explode",
	["fat_bitches"] = "Fat bitch spawns",
	["freeze"] = "Freeze/Unfreeze",
	["kick_pid_from_veh"] = "Kick player from vehicle",
	["kick_all_from_veh"] = "Kick all from vehicle",
	["best_armor"] = "Best armor",
	["worst_armor"] = "Worst armor",
	["weapons_worst"] = "Worst weapons",
	["cntrmsrs"] = "Countermeasures",
	["bombs"] = "Bombs",
	}


	function funcs.get.sssn_pid_veh_table()
		local pidtable = {}
		for pid = 0,31 do
			if funcs.doo.sssn_veh_pid_check(pid) then
				pidtable[#pidtable+1]=pid
			end
		end
		return pidtable
	end

	function funcs.get.sssn_pid_veh_start(_show_notif)
		if not g.feat.sssn_veh_affect_plyrs.on or
			(not g.tbl.sssn_veh_plyr_affect.frnd.on and not
			g.tbl.sssn_veh_plyr_affect.orgmc.on and not
			g.tbl.sssn_veh_plyr_affect.mddr.on and not
			g.tbl.sssn_veh_plyr_affect.others.on) then
			return nil
		end
		local pid_table = funcs.get.sssn_pid_veh_table()
		if #pid_table > 0 then
			return pid_table
		end
		if _show_notif then
			g.N_P(2,"No available players from selection.",__GV__,4,"Yellow")
		end
		return nil
	end

	g.tbl.sssn_pid_skip={}
	g.tbl.sssn_pid_active={}
	g.tbl.sssn_pid_count={}
	g.tbl.sssn_veh_skip={}
	g.tbl.sssn_veh_temp={}
	g.tbl.sssn_veh_count={}
	g.tbl.sssn_veh_active={}
	g.tbl.sssn_my_pos_front={}
	g.tbl.sssn_veh_bst_dly={}
	g.var.sssn_temp_cnt=0
	g.tbl.sssn_veh_not_if_dead={
	["horn_honk"] = true,
	["anti_lock"] = true,
	["horn_boost"] = true,
	["repair_auto"] = true,
	["damage"] = true,
	["destroy"] = true,
	["upgrades"] = true,
	["perf"] = true,
	["wheels"] = true,
	["f1"] = true,
	["headlights"] = true,
	["neons"] = true,
	["paint"] = true,
	["livery"] = true,
	["weapons"] = true,
	["speed_torque"] = true,
	["remove_rotor"] = true,
	["rmv_veh_weap"] = true,
	["pop_tires"] = true,
	["unpop_tires"] = true,
	}
	g.tbl.sssn_veh_should_yield = {
	["upgrades"] = true,
	["perf"] = true,
	["wheels"] = true,
	["f1"] = true,
	["headlights"] = true,
	["neons"] = true,
	["paint"] = true,
	["livery"] = true,
	["weapons"] = true,
	}


	function funcs.doo.sssn_plyr_veh_action_thread(_actn,_val,_veh,_v_actv,_cnt)
		g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
			local __actn,__val = _actn,_val
			local __veh = _veh
			local __v_actv = _v_actv
			local __cnt = _cnt
			if funcs.doo.veh_action_list(__veh,2000,__actn,__val) then
				g.tbl.sssn_veh_count[__cnt]=g.tbl.sssn_veh_count[__cnt]+1
			end
			g.tbl.sssn_veh_active[__v_actv][__veh]=false
		end)
	end

	function funcs.doo.sssn_plyr_veh_action_guts(f)
		local pause = false
		for i=1,#f.TBL do
			if API.plyr.is.valid(f.TBL[i]) and API.plyr.is.in_veh(f.TBL[i]) and not g.tbl.sssn_veh_temp[f.T_ACTV][API.plyr.get.veh(f.TBL[i])] then
				local veh = API.plyr.get.veh(f.TBL[i])
				if funcs.is.sssn_veh_action_chk(veh,f.ACTN,f.VAL) and funcs.is.sssn_veh_check(veh,true) then
					pause=true
					g.tbl.sssn_veh_temp[f.T_ACTV][veh]=true
					g.tbl.sssn_veh_active[f.V_ACTV][veh]=true
					funcs.doo.sssn_plyr_veh_action_thread(f.ACTN,f.VAL,veh,f.V_ACTV,f.CNT)
				end
			end
		end
		if pause then
			if f.POS then
				funcs.doo.hover_at_pos(f.POS,500)--stay at their pos to allow npc vehs to load
				funcs.doo.all_veh_action_thread_start(1000,f.ACTN,f.VAL)--affect npc vehs at their pos
				funcs.doo.hover_at_pos(f.POS,250)--give npc a little time to complete
			end
			local found = true
			while found do
				found = false
				for k,v in pairs(g.tbl.sssn_veh_active[f.V_ACTV]) do
					if v then found = true break end
				end
				if f.POS then
					API.ent.set.coords(funcs.ME._ped(), f.POS)
				end
				YIELD(10)
			end
		end
	end



	function funcs.doo.sssn_plyr_veh_action(_action,_val,_no_force,_show_notif)
		local pid_table = funcs.get.sssn_pid_veh_start(_show_notif)
		if pid_table then
			local action_str = (g.tbl.sssn_action_str[_action] or "Actions")
			local total = #pid_table
			g.tbl.sssn_veh_count[#g.tbl.sssn_veh_count+1]=0
			local count=#g.tbl.sssn_veh_count
			g.tbl.sssn_veh_active[#g.tbl.sssn_veh_active+1]={}
			local v_active = #g.tbl.sssn_veh_active
			if _no_force or not g.tbl.sssn_veh_plyr_affect.force.on then
				for i=1,#pid_table do
					if API.plyr.is.valid(pid_table[i]) and API.plyr.is.in_veh(pid_table[i]) then
						local _veh = API.plyr.get.veh(pid_table[i])
						if funcs.is.sssn_veh_action_chk(_veh,_action,_val) and funcs.is.sssn_veh_check(_veh,true) then
							g.tbl.sssn_veh_active[v_active][_veh]=true
							if _action == "kick_pid_from_veh" then
								funcs.doo.sssn_plyr_veh_action_thread(_action,pid_table[i],_veh,v_active,count)
							else
								funcs.doo.sssn_plyr_veh_action_thread(_action,_val,_veh,v_active,count)
							end
						end
					end
				end
			else
				g.tbl.sssn_veh_temp[#g.tbl.sssn_veh_temp+1]={}
				local t_active = #g.tbl.sssn_veh_temp
				funcs.doo.sssn_plyr_veh_action_guts({TBL = pid_table, ACTN = _action, VAL = _val, V_ACTV = v_active, T_ACTV = t_active, CNT = count}) -- do what i can without hovering
				local hover_tbl,i_hovered,pos = funcs.get.hover_info(),false,v3()
				for i=1,#pid_table do
					if API.plyr.is.valid(pid_table[i]) and funcs.get.dist_me_pid_3d(pid_table[i]) > 250 then
						i_hovered=true
						pos = funcs.doo.hover_above_pid2(pid_table[i],1500,true,false)
						funcs.doo.sssn_plyr_veh_action_guts({TBL = pid_table, ACTN = _action, VAL = _val, V_ACTV = v_active, T_ACTV = t_active, CNT = count, POS = pos})
					end
				end
				if i_hovered then
					funcs.doo.hover_back(hover_tbl)
				end
			end
			if _show_notif then
				local found = true
				while found do
					found = false
					for k,v in pairs(g.tbl.sssn_veh_active[v_active]) do
						if v then found = true break end
					end
					YIELD(10)
				end
				g.N_P(2,"Player vehicles\n"..action_str.." complete.".."\n"..g.tbl.sssn_veh_count[count].."/"..total.." successful",__GV__,5,"Blue")
			end
		end
	end




	function funcs.is.sssn_veh_check(_veh,_plyr_check)
		if funcs.is.veh(_veh) then
			local owner = decorator.decor_get_int(_veh, "Player_Vehicle")
			local has_plyr = false
			if (funcs.ME._net_hash() == owner) or (funcs.ME._veh() == _veh) then --check if its mine
				return false
			elseif API.veh.get.been_owned(_veh) and (not g.feat.sssn_veh_affect_plyrs.on or not _plyr_check) then --check for street/npc
				return false
			end
			if not _plyr_check then
				return true
			end
			if owner > 0 then --street vehicles have 0, spawned vehicles can have 1024 or similar. Real net hashes are maybe 7-8 digits
				for i=1,32 do
					if g.tbl.PID_INFO.net_hash[i]==owner then --look for owner of the vehicle
						if not g.tbl.sssn_veh_plyr_affect.pers.on or not funcs.doo.sssn_veh_pid_check(i-1) then --check for affect personal and if owner should be affected
							return false
						end
						has_plyr = true
						break
					end
				end
			end
			for i = 1,funcs.get.veh_seats(_veh) do
				if API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, i-2)) then
					if not funcs.doo.sssn_veh_pid_check(API.plyr.get.plyr_from_ped(API.veh.get.ped_in_seat(_veh, i-2))) then --check each pid in the vehicle
						return false
					end
					has_plyr = true
				end
			end
			if not API.veh.get.been_owned(_veh) and not has_plyr then --been_owned and has_plyr should always match but whatever
				return  g.feat.sssn_veh_affect_npc_street.on --check if i want to affect street vehicles
			end
			return true
		end
		return false
	end

	function funcs.doo.sssn_veh_pid_check(_pid)
		if not API.plyr.is.valid(_pid) or _pid == funcs.ME._id() then
			return false
		end
		local friend = API.plyr.is.friend(_pid)
		if friend and not g.tbl.sssn_veh_plyr_affect.frnd.on then
			return false
		end
		local mddr = API.plyr.is.modder(_pid, -1)
		if mddr and not g.tbl.sssn_veh_plyr_affect.mddr.on then
			return false
		end
		local orgmc = funcs.is.same_orgmc(funcs.ME._id(),_pid)
		if orgmc and not g.tbl.sssn_veh_plyr_affect.orgmc.on then
			return false
		end
		if not friend and not mddr and not orgmc and not g.tbl.sssn_veh_plyr_affect.others.on then
			return false
		end
		return true
	end

	g.print_load_info("Session vehicle actions",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
	g.var.feat_loading_str = "Local session features"
	-----------------------------------------------------------------------------------------GEE-SKID
	--------------------------------------------------------------------------------------PlayersPeds
	--------------------------------------------------------------------------------------------Local
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	g.tbl.pid_stf = {}

	g.tbl.pid_stf.set_wanted = menu_add_feature("Set wanted level", "value_i",g.prnt.sssn_plyrs.id, function(f)
		while f.on do
			for i=0,31 do
				if funcs.doo.sssn_plyr_pid_check(i) and API.plyr.get.wanted(i) ~= f.value then
					funcs.doo.wntd(i,f.value)
				end
			end
			YIELD(250)
		end
	end)
	funcs.set_feat_i_f(g.tbl.pid_stf.set_wanted,0,5,1,0,"g.tbl.pid_stf.set_wanted")

	--patched in 1.67
	-- menu_add_feature("Send to biker jail","toggle", g.prnt.sssn_plyrs.id, function(f)
		-- if f.on then
			-- local jail,plyrs={},{}
			-- local size = 69.280387878418-2
			-- local pos = funcs.vec(274,-1830,-69)
			-- local hash = API.get_hash_key("stt_prop_stunt_landing_zone_01")
			-- local posrot={
			-- {POS=funcs.vec(0,0,0),				ROT=funcs.vec(0,0,0)},
			-- {POS=funcs.vec(size,	0,	size), 	ROT=funcs.vec(0, -90, 0)},
			-- {POS=funcs.vec(-size,	0,	size), 	ROT=funcs.vec(0, 90, 0)},
			-- {POS=funcs.vec(0,	0,	2*size), 	ROT=funcs.vec(0, 0, 0)},
			-- {POS=funcs.vec(0,	size,	size), 	ROT=funcs.vec(90, 0, 0)},
			-- {POS=funcs.vec(0,	-size,	size), 	ROT=funcs.vec(-90, 0, 0)},
			-- }
			-- while f.on do
				-- for i=1,6 do
					-- if not funcs.is.ent(jail[i]) then
						-- funcs.doo.req_model(hash)
						-- jail[i] =  funcs.doo.spawn_obj(hash, pos + posrot[i].POS, 	posrot[i].ROT,	true,false,0,true)
					-- end
				-- end
				-- for i=0,31 do
					-- if funcs.doo.sssn_plyr_pid_check(i) then
						-- if plyrs[i] then
							-- if plyrs[i] < TIME_MS() then
								-- plyrs[i] = funcs.is.in_grid_xy(pos,API.plyr.get.coords(i),size) and TIME_MS() + 15000 or nil
							-- end
						-- elseif not funcs.is.in_grid_xy(pos,API.plyr.get.coords(i),size) then
							-- plyrs[i]=TIME_MS() + 15000
							-- glbls.force_into_veh(i)
						-- end
					-- end
					-- YIELD(0)
				-- end
				-- YIELD(100)
			-- end
			-- for i=1,#jail do
				-- g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					-- funcs.doo.remove_ent(jail[i],5000)
				-- end)
			-- end
		-- end
	-- end)


	g.tbl.pid_stf.explode=menu_add_feature("Explode players","action_value_str",g.prnt.sssn_plyrs.id,function(f)
		funcs.doo.sssn_plyr_pid_action("explode",81,10,f.value==0,false,true,true,true)
	end)
	new_set_str_data(g.tbl.pid_stf.explode,{"Blame me","Blame them"})
	funcs.add_to_S_L(g.tbl.pid_stf.explode,"g.tbl.pid_stf.explode")

	g.tbl.pid_stf.burn=menu_add_feature("Burn players","action_value_str",g.prnt.sssn_plyrs.id,function(f)
		funcs.doo.sssn_plyr_pid_action("burn",3,10,f.value==0,false,true,true,true)
	end)
	new_set_str_data(g.tbl.pid_stf.burn,{"Blame me","Blame them"})
	funcs.add_to_S_L(g.tbl.pid_stf.burn,"g.tbl.pid_stf.burn")

	g.tbl.pid_stf.sparrow=menu_add_feature("Drop sparrows","action_value_str",g.prnt.sssn_plyrs.id,function(f)
		funcs.doo.sssn_plyr_pid_action("sparrow",nil,(f.value*9)+1,nil,false,true,true,true)
	end)
	new_set_str_data(g.tbl.pid_stf.sparrow,{"One", "Many"})
	funcs.add_to_S_L(g.tbl.pid_stf.sparrow,"g.tbl.pid_stf.sparrow")

	g.tbl.pid_stf.fat_bitches=menu_add_feature("Spawn angry fat bitch", "action_value_str", g.prnt.sssn_plyrs.id, function(f)
		local t = {"bmx","deathbike2","toreador","rhino","phantom2","strikeforce","buzzard","foot"}
		funcs.doo.sssn_plyr_pid_action("fat_bitches",t[f.value+1],1,nil,false,true,true,true)
	end)
	new_set_str_data(g.tbl.pid_stf.fat_bitches,{"On bicycle","On motorcycle","In Toreador","In Rhino","In Phantom Wedge","In B-11 Strikeforce","In Buzzard","On foot"})
	funcs.add_to_S_L(g.tbl.pid_stf.fat_bitches,"g.tbl.pid_stf.fat_bitches")

	g._all_plyr_ammo_weap=menu_add_feature("All weapons","action_value_str",g.prnt.sssn_plyrs.id,function(f)
		local pid_table = funcs.get.sssn_pid_plyr_table(false,false)
		if #pid_table == 0 then
			g.N_P(2,"No available players from selection.",__GV__,4,"Yellow")
		else
			g.tbl.sssn_pid_active[#g.tbl.sssn_pid_active+1]={}
			local active = #g.tbl.sssn_pid_active
			g.tbl.sssn_pid_count[active]=0
			local f_value = f.value
			for i=1,#pid_table do
				if API.plyr.is.valid(pid_table[i]) then
					local pid = pid_table[i]
					g.tbl.sssn_pid_active[active][pid]=true
					g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
						local _active = active
						local _pid = pid
						local _f_value = f_value
						local success=false
						if _f_value == 1 then
							menu.get_feature_by_hierarchy_key("online.online_players.player_".._pid..".weapons.remove_all_weapons"):toggle()
							success=true
						else
							for i=1,#weap_info.all_hash do
								if funcs.doo.give_ped_weap2(API.plyr.get.ped(_pid),weap_info.all_hash[i]) then
									success=true
								end
							end
						end
						if success then
							g.tbl.sssn_pid_count[_active]=g.tbl.sssn_pid_count[_active]+1
						end
						g.tbl.sssn_pid_active[_active][_pid]=false
					end)
					YIELD(69)
				end
			end
			local found,a_count = true,0
			while found do
				found = false
				a_count=0
				for k,v in pairs(g.tbl.sssn_pid_active[active]) do
					if v then
						found = true
						a_count=a_count+1
					end
				end
				YIELD(5)
				if f.value == 0 then
					funcs.doo.overlay((#pid_table-g.tbl.sssn_pid_count[active]).." players remaining...",255,255,255,255,0.25,0,0.5,0.97)
				end
			end
			g.N_P(2,"Weapons complete.".."\n"..g.tbl.sssn_pid_count[active].."/"..#pid_table.." successful",__GV__,5,"Blue")
		end
	end)
	new_set_str_data(g._all_plyr_ammo_weap,{"Give","Remove"})

	-----------------------------------------------------------------------------------------GEE-SKID
	---------------------------------------------------------------------------------------PlayersVeh
	--------------------------------------------------------------------------------------------Local
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------

function funcs.doo.all_veh_action_thread_start(time,action,val,notif)
	if g.feat.sssn_veh_affect_npc_street.on then
		local all_veh=API.veh.get.all()
		local action_str = (g.tbl.sssn_action_str[action] or "Actions")
		g.tbl.sssn_veh_count[#g.tbl.sssn_veh_count+1]=0
		local count=#g.tbl.sssn_veh_count
		g.tbl.sssn_veh_active[#g.tbl.sssn_veh_active+1]={}
		local active = #g.tbl.sssn_veh_active
		local total=0
		for i=1,#all_veh do
			if not g.tbl.sssn_veh_skip[all_veh[i]] and funcs.is.sssn_veh_check(all_veh[i],false) and funcs.is.sssn_veh_action_chk(all_veh[i],action,val) then
				local veh = all_veh[i]
				g.tbl.sssn_veh_skip[veh]=true
				g.tbl.sssn_veh_active[active][veh]=true
				total=total+1
				g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
					local _veh,_time,_action,_val,_count,_active = veh,time,action,val,count,active
					if funcs.doo.veh_action_list(_veh,_time,_action,_val) then
						g.tbl.sssn_veh_count[_count]=g.tbl.sssn_veh_count[_count]+1
					end
					g.tbl.sssn_veh_skip[_veh]=false
					g.tbl.sssn_veh_active[_active][_veh]=false
				end)
				if g.tbl.sssn_veh_should_yield[action] then --upgrades like to crash
					YIELD(0)
				elseif i % 50 == 0 then
					YIELD(10)
				end
			end
		end
		if notif then
			local found = true
			while found do
				found = false
				for k,v in pairs(g.tbl.sssn_veh_active[active]) do
					if v then found = true break end
				end
				YIELD(10)
			end
			g.N_P(2,"Ped/Empty vehicles\n"..action_str.." complete.".."\n"..g.tbl.sssn_veh_count[count].."/"..total.." successful",__GV__,5,"Blue")
		end
		return true
	end
	return false
end

function funcs.doo.spawn_veh(_pos,_hash,_upgrade,_heading,_keep,_ntwrk,_cllsn)
	_ntwrk = _ntwrk or true
	_upgrade = _upgrade or false
	_heading = _heading or mth.rndm(0,359)
	local _veh = vehicle.create_vehicle(_hash, _pos+funcs.vec(0,0,100), 0.0, _ntwrk, false)
	if not funcs.is.veh(_veh) then
		funcs.N_P(2,"Failed to create "..tostring(veh_stuff.hash_is_name[_hash]).."\nPossibly at max spawn limit.",funcs.ver_text,4,"Red")
	else
		if _keep then
			funcs.doo.id_migrate(_veh,0)
		end
		if _cllsn then
			API.ent.set.collision(_veh,false)
		end
		API.ent.set.heading(_veh,_heading)
		API.ent.set.coords(_veh, _pos)
		API.veh.set.on_ground(_veh)
		if _upgrade then
			funcs.doo.veh_action_list(_veh,1000,"upgrades",nil)
		end
		decorator.decor_set_int(_veh, "MPBitset", 1 << 10)
		API.veh.set.fixed(_veh)
		ntv.set.veh_dirt_level(_veh,0.0)
		API.veh.set.engine_on(_veh, true, true, false)
		g.tbl.spwn.history[#g.tbl.spwn.history+1]=_veh
		return _veh
	end
	return nil
end


function funcs.doo.spawn_ped_angry(_pos,_model_hash,_weapon_hash1,_weapon_hash2,_pid,_veh,_hlth)
	_hlth = _hlth or 2500
	local _ped
	local _seat = funcs.get.veh_1st_free_seat(_veh)
	if _seat then
		_ped=ntv.doo.create_ped_in_veh(_veh,6,_model_hash,_seat,1,0)
		menu.notify("_seat ".._seat)
	elseif _pos then
		_ped=API.Ped.create(6, _model_hash,_pos, mth.rndm(0,359), true, false)
	end
	if funcs.is.ent(_ped) then
		funcs.doo.id_migrate(_ped,0)
		ntv.set.ped_no_high_fall_damage(_ped,1)
		if _weapon_hash1 then
			funcs.doo.give_ped_weap(_ped,_weapon_hash1)
		end
		if _weapon_hash2 then
			funcs.doo.give_ped_weap(_ped,_weapon_hash2)
		end
		funcs.doo.ped_combat_attrib(_ped,true)
		funcs.doo.set_ped_health(_ped,_hlth,50)
		ntv.set.ped_critical_dmg(_ped,0)
		if _pid ~= nil then
			gameplay.shoot_single_bullet_between_coords(_pos, _pos + funcs.vec(0,0,.25), 0, API.get_hash_key("weapon_pistol"), API.plyr.get.ped(_pid), false, true, 100)
			ai.task_combat_ped(_ped, API.plyr.get.ped(_pid), 0, 16)
		end
		funcs.doo.ped_ragdoll(_ped,false,50)
		g.tbl.entities[#g.tbl.entities+1]=_ped
	end
	return _ped
end

function funcs.doo.spawn_veh_at_pid(_pid,_hash,_upgrade,_cam,_keep)
	_upgrade = _upgrade or false
	_cam = _cam or false
	if funcs.is.valid_pid(_pid) then
		local _veh = vehicle.create_vehicle(_hash, funcs.get.pid_pos_z_guess(_pid)+funcs.vec(0,0,100), 0.0, true, false)
		if not funcs.is.veh(_veh) then
			funcs.N_P(2,"Failed to create "..tostring(veh_stuff.hash_is_name[_hash]).."\nPossibly at max spawn limit.",funcs.ver_text,4,"Red")
		else
			if _cam then
				API.ent.set.heading(_veh,API.cam.get.rot().z)
				API.ent.set.coords(_veh, funcs.get.front_of_pos(funcs.get.pid_pos_z_guess(_pid), API.cam.get.rot().z, funcs.get.spawn_front_dist(_pid,_veh), 184, 1.5))
			else
				API.ent.set.heading(_veh,API.plyr.get.heading(_pid))
				API.ent.set.coords(_veh, funcs.get.front_of_pos(funcs.get.pid_pos_z_guess(_pid), API.plyr.get.heading(_pid), funcs.get.spawn_front_dist(_pid,_veh), 184, 1.5))
			end
			API.veh.set.on_ground(_veh)
			if _upgrade then
				funcs.doo.veh_action_list(_veh,1000,"upgrades",nil)
			end
			if _keep then
				funcs.doo.id_migrate(_veh,0)
			end
			decorator.decor_set_int(_veh, "MPBitset", 1 << 10)
			API.veh.set.fixed(_veh)
			ntv.set.veh_dirt_level(_veh,0.0)
			API.veh.set.engine_on(_veh, true, true, false)
			g.tbl.spwn.history[#g.tbl.spwn.history+1]=_veh
			return _veh
		end
	end
	return nil
end


	function funcs.is.should_horn_boost(_veh)
		if not ntv.is.veh_alarm_on(_veh) and ntv.is.veh_horn_on(_veh) then
			if g.tbl.sssn_veh_bst_dly[_veh] == nil then
				return true
			elseif g.tbl.sssn_veh_bst_dly[_veh] < TIME_MS() then
				return true
			end
		end
		return false
	end

	g.tbl.sssn_veh_action_chk = {
		["horn_honk"] = function(_veh,_val)
			return not ntv.is.veh_horn_on(_veh)
		end,
		["horn_stop"] = function(_veh,_val)
			return ntv.is.veh_horn_on(_veh)
		end,
		["air_down"] = function(_veh,_val)
			return API.ent.is.in_air(_veh)
		end,
		["ground_up"] = function(_veh,_val)
			return not API.ent.is.in_air(_veh)
		end,
		["god"] = function(_veh,_val)
			return API.ent.get.god(_veh) ~= _val
		end,
		["remove_rotor"] = function(_veh,_val)
			return funcs.is.helo(_veh)
		end,
		["rmv_veh_weap"] = function(_veh,_val)
			return ntv.is.veh_have_weap(_veh)
		end,
		["weapons"] = function(_veh,_val)
			return ntv.is.veh_have_weap(_veh)
		end,
		["weapons_worst"] = function(_veh,_val)
			return ntv.is.veh_have_weap(_veh)
		end,
		["visible"] = function(_veh,_val)
			return API.ent.is.visible(_veh) ~= _val
		end,
		["repair_auto"] = function(_veh,_val)
			return funcs.get.veh_cmbnd_health_prcnt(_veh,true) < _val
		end,
		["horn_boost"] = function(_veh,_val)
			return funcs.is.should_horn_boost(_veh)
		end,
		["livery"] = function(_veh,_val)
			return API.veh.get.num_mods(_veh, 48) ~= 0
		end,
		["cntrmsrs"] = function(_veh,_val)
			return veh_stuff.has_cntrmsrs[API.ent.get.model_hash(_veh)]
		end,
		["bombs"] = function(_veh,_val)
			return veh_stuff.has_bombs[API.ent.get.model_hash(_veh)]
		end,
		["window_smash"] = function(_veh,_val)
			return ntv.get.num_windows_good(_veh) ~= 0
			end,
		["window_repair"] = function(_veh,_val)
			return not ntv.is.windows_good(_veh)
		end

	}

	function funcs.is.sssn_veh_action_chk(_veh,_action,_val)
		if g.tbl.unaffected_ents[_veh] or (g.tbl.sssn_veh_not_if_dead[_action] and API.ent.is.dead(_veh)) then
			return false
		end
		local temp = g.tbl.sssn_veh_action_chk[_action]
		if temp then
			return temp(_veh,_val)
		end
		return true
	end

	g.tbl.veh_action_list = {
	["window_smash"] = function(_veh,_time,_action,_val,_num)
		if ntv.get.num_windows_good(_veh) > 0 and funcs.ntwrk.ask_long(_veh,_time) then
			ntv.set.veh_invncbl_wndws(_veh, 0)
			ntv.doo.brk_veh_wndws(_veh)
			return true
		end
	end,
	["window_repair"] = function(_veh,_time,_action,_val,_num)
		if not ntv.is.windows_good(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			ntv.doo.fix_veh_wndws(_veh)
			return true
		end
	end,
	["window_invncbl"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			if not ntv.is.windows_good(_veh) then
				ntv.doo.fix_veh_wndws(_veh)
			end
			API.veh.set.kit_type(_veh, 0)
			ntv.set.veh_invncbl_wndws(_veh, _val)
			return true
		end
	end,
	["random_force"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			local _25 = math.tointeger(math.floor(_val/2.5))
			local _5 = math.tointeger(math.floor(_val/5))
			if API.ent.is.in_air(_veh) then
				entity.apply_force_to_entity(_veh, 1,mth.rndm(-_val*_val,_val*_val), mth.rndm(-_val*_val,_val*_val),mth.rndm(-_25,-_5) , 0,0,0, false, true)
				--API.ent.set.velocity(_veh,v3(mth.rndm(-_val,_val),mth.rndm(-_val,_val),mth.rndm(-(_val/2.5),-(_val/5))))
			else
				entity.apply_force_to_entity(_veh, 1,mth.rndm(-_val*_val,_val*_val), mth.rndm(-_val*_val,_val*_val),mth.rndm(_5,_25), 0,0,0, false, true)
				--API.ent.set.velocity(_veh,v3(mth.rndm(-_val,_val),mth.rndm(-_val,_val),mth.rndm((_val/5),(_val/2.5))))
			end
			return true
		end
	end,
	["horn_honk"] = function(_veh,_time,_action,_val,_num)
		if not ntv.is.veh_horn_on(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			ntv.set.veh_horn_on(_veh,5000,API.get_hash_key("HELDDOWN"),1)
			return true
		end
	end,
	["anti_lock"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.be_locked_on(_veh, _val, true)
			return true
		end
	end,
	["horn_stop"] = function(_veh,_time,_action,_val,_num)
		if ntv.is.veh_horn_on(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			ntv.set.veh_horn_on(_veh,0,0,0)
			return true
		end
	end,
	["horn_boost"] = function(_veh,_time,_action,_val,_num)
		if funcs.is.should_horn_boost(_veh) then
			g.tbl.sssn_veh_bst_dly[_veh]=TIME_MS()+g.tbl.sssn_stf.hrn_bst_delay.value
			if funcs.ntwrk.ask_long(_veh,_time) then
				API.ent.set.max_speed(_veh,45000)
				local initial = g.tbl.sssn_stf.hrn_bst_initial.value
				local speed = API.ent.get.speed(_veh)
				speed = speed + (initial*3+(initial*40*_val)-(initial*0.02*speed))
				speed = speed * (1.01+_val)
				API.veh.set.forward_speed(_veh,speed)
				return true
			end
		end
	end,
	["repair"] = function(_veh,_time,_action,_val,_num)
		if funcs.doo.veh_repair_most(_veh,_time,funcs.plate_t_or_nil(),funcs.plate_i_or_nil()) then
			local veh_peds = funcs.get.all_peds_in_veh(_veh,false,nil)
			for i=1, #veh_peds do
				fire.stop_entity_fire(veh_peds[i])
			end
			return true
		end
	end,
	["repair_auto"] = function(_veh,_time,_action,_val,_num)
		return funcs.get.veh_cmbnd_health_prcnt(_veh,true) < _val and funcs.doo.veh_repair_most(_veh,_time,funcs.plate_t_or_nil(),funcs.plate_i_or_nil())
	end,
	["damage"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_damage_guts(_veh)
			return true
		end
	end,
	["destroy"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_destroy_guts(_veh, funcs.get.veh_ped_for_blame(_veh))
			return true
		end
	end,
	["fucked"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			funcs.doo.veh_superfuck(_veh)
			return true
		end
	end,
	["upgrades"] = function(_veh,_time,_action,_val,_num)
		local _1_basics,_2_perf,_3_wheels,_4_lights,_5_paint,_6_livery,_7_weap,upgraded = false,false,false,false,false,false,false,false
		local speed = API.ent.get.velocity(_veh)
		local time = TIME_MS() + (_time*0.85)
		while funcs.is.veh(_veh) and (TIME_MS() < time) and not upgraded do
			YIELD(0)
			if not _1_basics and funcs.ntwrk.ask_quick(_veh) then
				API.veh.set.kit_type(_veh, 0)
				funcs.doo.veh_upgr_basic(_veh)
				_1_basics=true
			elseif _1_basics and not _2_perf and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_upgr_perf(_veh)
				_2_perf=true
			elseif _2_perf and not _3_wheels and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_upgr_wheels(_veh)
				_3_wheels=true
			elseif _3_wheels and not _4_lights and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_upgr_lights(_veh,"random")
				funcs.doo.veh_upgr_neons(_veh,"random")
				_4_lights=true
			elseif _4_lights and not _5_paint and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_upgr_paint(_veh,"random")
				_5_paint=true
			elseif _5_paint and not _6_livery and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_upgr_livery(_veh)
				_6_livery=true
			elseif _6_livery and not _7_weap and funcs.ntwrk.ask_quick(_veh) then
				funcs.doo.veh_weap_best(_veh)
				funcs.doo.veh_upgr_bombs(_veh)
				funcs.doo.veh_upgr_cntrmsrs(_veh)
				YIELD(50)
				_7_weap=true
			elseif _7_weap and not upgraded and funcs.ntwrk.ask_quick(_veh) then
				if g.tbl.plate_rpr_upgr.style_tog.on then
					API.veh.set.plate_index(_veh, g.tbl.plate_rpr_upgr.style_tog.value)
				end
				if g.tbl.plate_rpr_upgr.tog.on then
					API.veh.set.plate_text(_veh,g.tbl.plate_rpr_upgr.text)
				end
				API.ent.set.velocity(_veh,speed)
				upgraded=true
			end
		end
		return upgraded
	end,
	["perf"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_perf(_veh)
			return true
		end
	end,
	["wheels"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_wheels(_veh,_action)
			return true
		end
	end,
	["f1"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_wheels(_veh,_action)
			return true
		end
	end,
	["headlights"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_lights(_veh,_val)
			return true
		end
	end,
	["neons"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_neons(_veh,_val)
			return true
		end
	end,
	["paint"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_paint(_veh,_val)
			return true
		end
	end,
	["paint_primary"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			API.veh.set.primary_color_custom(_veh, _val)
			return true
		end
	end,
	["paint_secondary"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			API.veh.set.secondary_color_custom(_veh, _val)
			return true
		end
	end,
	["paint_pearl"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			API.veh.set.pearl_color_custom(_veh, _val)
			return true
		end
	end,
	["paint_extras"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			API.veh.set.extra_colors(_veh, _val, _val)
			return true
		end
	end,
	["livery"] = function(_veh,_time,_action,_val,_num)
		if API.veh.get.num_mods(_veh, 48) == 0 and funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_upgr_livery(_veh)
			return true
		end
	end,
	["weapons"] = function(_veh,_time,_action,_val,_num)
		if ntv.is.veh_have_weap(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.kit_type(_veh, 0)
			funcs.doo.veh_weap_best(_veh)
			funcs.doo.veh_upgr_bombs(_veh)
			funcs.doo.veh_upgr_cntrmsrs(_veh)
			return true
		end
	end,
	["weapons_worst"] = function(_veh,_time,_action,_val,_num)
		if ntv.is.veh_have_weap(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_weap_worst(_veh)
			return true
		end
	end,
	["best_armor"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_armor_best(_veh)
			return true
		end
	end,
	["worst_armor"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_armor_worst(_veh)
			return true
		end
	end,
	["veh_kick"] = function(_veh,_time,_action,_val,_num)
		return funcs.doo.kick_all_from_veh(_veh)
	end,
	["flip_wrong"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			local speed = API.ent.get.velocity(_veh)
			API.ent.set.rotation(_veh,funcs.vec(API.ent.get.rotation(_veh).x,180,API.ent.get.rotation(_veh).z))
			API.ent.set.velocity(_veh,speed)
			return true
		end
	end,
	["flip_right"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			local speed = API.ent.get.velocity(_veh)
			API.veh.set.on_ground(_veh)
			API.ent.set.velocity(_veh,speed)
			return true
		end
	end,
	["stop"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.velocity(_veh,funcs.vec(0,0,0))
			return true
		end
	end,
	["zoom_zoom"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			API.veh.set.forward_speed(_veh,_val)
			return true
		end
	end,
	["float"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			API.ent.set.velocity(_veh,funcs.vec(0,0,_val))
			return true
		end
	end,
	["air_down"] = function(_veh,_time,_action,_val,_num)
		if API.ent.is.in_air(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			API.ent.set.velocity(_veh,funcs.vec(0,0,_val))
			return true
		end
	end,
	["ground_up"] = function(_veh,_time,_action,_val,_num)
		if not API.ent.is.in_air(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,45000)
			API.ent.set.velocity(_veh,funcs.vec(0,0,_val))
			return true
		end
	end,
	["gravity"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.gravity(_veh, _val)
			return true
		end
	end,
	["collision"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.collision(_veh, _val,false)
			return true
		end
	end,
	["god"] = function(_veh,_time,_action,_val,_num)
		if API.ent.get.god(_veh) ~= _val and funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.god(_veh, _val)
			return true
		end
	end,
	["speed_torque"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,_val <1 and _val*125 or 45000)
			API.veh.set.top_speed(_veh, (_val - 1) * 100)
			return true
		end
	end,
	["freeze"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.max_speed(_veh,_val)
			return true
		end
	end,
	["remove_rotor"] = function(_veh,_time,_action,_val,_num)
		if funcs.is.helo(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.extra(_veh, 1, 0)
			API.veh.set.extra(_veh, 2, 0)
			API.veh.set.extra(_veh, 7, 0)
			return true
		end
	end,
	["rmv_veh_weap"] = function(_veh,_time,_action,_val,_num)
		if ntv.is.veh_have_weap(_veh) and funcs.ntwrk.ask_long(_veh,_time) then
			ntv.doo.rmv_veh_weap(_veh)
			return true
		end
	end,
	["pop_tires"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_tire_pop_guts(_veh,true)
			return true
		end
	end,
	["unpop_tires"] = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			funcs.doo.veh_tire_pop_guts(_veh,false)
			return true
		end
	end,
	["visible"] = function(_veh,_time,_action,_val,_num)
		if API.ent.is.visible(_veh) ~= _val and funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.visible(_veh,_val)
			return true
		end
	end,
	["tp"]  = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			local speed = API.ent.get.velocity(_veh)
			API.ent.set.coords(_veh,funcs.get.rand_tp_pos(_val) or _val)
			YIELD(50)
			if funcs.ntwrk.ask_long(_veh,100) then
				API.ent.set.velocity(_veh,speed)
			end
			return true
		end
	end,

	["tp_up"]  = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			local speed = API.ent.get.velocity(_veh)
			local pos =  API.ent.get.coords(_veh)
			pos.z=pos.z+_val
			API.ent.set.coords(_veh,pos)
			YIELD(50)
			if funcs.ntwrk.ask_long(_veh,100) then
				API.ent.set.velocity(_veh,speed)
			end
			return true
		end
	end,

	["tp_2_me"]  = function(_veh,_time,_action,_val,_num)
		if funcs.ntwrk.ask_long(_veh,_time) then
			API.ent.set.coords(_veh,g.tbl.sssn_my_pos_front[_val][mth.rndm(1,200)])
			YIELD(50)
			if funcs.ntwrk.ask_long(_veh,100) then
				API.ent.set.velocity(_veh,funcs.vec(0,0,0))
			end
			return true
		end
	end,
	["kick_pid_from_veh"] = function(_veh,_time,_action,_val,_num)
		return funcs.doo.pid_veh_kick2(_veh, _val)
	end,
	["kick_all_from_veh"] = function(_veh,_time,_action,_val,_num)
		return funcs.doo.kick_all_from_veh(_veh,false)
	end,
	["kick_all_npc_from_veh"] = function(_veh,_time,_action,_val,_num)
		local empty_veh = true
		for i=1,funcs.get.veh_seats(_veh) do
			if funcs.is.ent(API.veh.get.ped_in_seat(_veh, i-2)) and not API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, i-2)) then
				API.Ped.clear_tasks(API.veh.get.ped_in_seat(_veh, i-2))
				empty_veh=false
			end
		end
		if empty_veh then
			return true
		end
		local found_npc = false
		YIELD(500)
		for i=1,funcs.get.veh_seats(_veh) do
			if funcs.is.ent(API.veh.get.ped_in_seat(_veh, i-2)) and not API.Ped.is.plyr(API.veh.get.ped_in_seat(_veh, i-2)) then
				found_npc = true
			end
		end
		return (not found_npc)
	end,
	["cntrmsrs"] = function(_veh,_time,_action,_val,_num)
		if veh_stuff.has_cntrmsrs[API.ent.get.model_hash(_veh)] and funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.mod(_veh, funcs.is.this_veh(_veh,"oppressor2") and 6 or 1, _val)
			return true
		end
	end,
	["bombs"] = function(_veh,_time,_action,_val,_num)
		if veh_stuff.has_bombs[API.ent.get.model_hash(_veh)] and funcs.ntwrk.ask_long(_veh,_time) then
			API.veh.set.mod(_veh, 9, _val)
			return true
		end
	end,
	["clone"] = function(_veh,_time,_action,_val,_num)
		return funcs.doo.clone_veh_for_me(_veh,_val,_num)
	end,

}

function funcs.doo.veh_action_list(_veh,_time,_action,_val,_num)
	local temp = g.tbl.veh_action_list[_action]
	if not temp then
		funcs.N_P(2,"Oh noes! I fucked up.",funcs.ver_text,4,"Red")
		return false
	end
	return temp(_veh,_time,_action,_val,_num)
end

function funcs.doo.veh_superfuck(_veh)
	funcs.doo.veh_fuck_guts(_veh)
	local trgt_crds_do
	local time = TIME_MS() + 10000
	while funcs.is.ent(_veh) and time > TIME_MS() do
		trgt_crds_do = g.tbl.a_b.get_movement(API.ent.get.coords(_veh)+funcs.vec(mth.rndm(-100,100),mth.rndm(-100,100),-100),API.ent.get.coords(_veh),69)
		if API.ent.is.dead(_veh) then
			time = TIME_MS()
		elseif funcs.ntwrk.ask_quick(_veh) then
			API.ent.set.god(_veh, false)
			API.ent.set.velocity(_veh,trgt_crds_do)
		end
		YIELD(10)
	end
end

function funcs.get.rand_ocean_pos()
	local ocean = mth.rndm(0,3)
	if ocean == 0 then
		return funcs.vec(mth.rndm(1230, 1250), mth.rndm(10200, 10220), 2200) -- ocean north
	elseif ocean == 1 then
		return funcs.vec(mth.rndm(410, 430), mth.rndm(-7820, -7800), 2200) -- ocean south
	elseif ocean == 2 then
		return funcs.vec(mth.rndm(7930, 7950), mth.rndm(2180, 2200), 2200) -- ocean east
	end
	return funcs.vec(mth.rndm(-7980, -7960), mth.rndm(1880, 1900), 2200) -- ocean west
end

function funcs.get.rand_tp_pos(_type)
	if _type == "ocean_high" then
		return funcs.get.rand_ocean_pos()
	elseif _type == "chiliad_high" then
		return funcs.vec(mth.rndm(487, 497), mth.rndm(5582, 5592), 2200)
	elseif _type == "city_high" then
		return funcs.vec(mth.rndm(-1000, 850), mth.rndm(-1600, 130), 2200)
	elseif _type == "maze_glitch" then
		return funcs.vec(mth.rndm(-82, -67), mth.rndm(-825, -812), mth.rndm(312, 317))
	elseif _type == "fib_top" then
		return funcs.vec(mth.rndm(129,142),mth.rndm(-754,-743),mth.rndm(259,261))
	elseif _type == "apt_glitch" then
		return funcs.vec(mth.rndm(-799, -757),mth.rndm(318, 338),mth.rndm(107, 127))
	end
	return funcs.get.spawn_points(funcs.vec(mth.rndm(-3500,4200),mth.rndm(-3600,7600),0),1)[1]
end

function funcs.get.vehicle_player(_veh)
	local seats =  vehicle.get_vehicle_model_number_of_seats(entity.get_entity_model_hash(_veh))
	for s=-1,(seats-2) do
		local PED = vehicle.get_ped_in_vehicle_seat(_veh, s)
		if ped.is_ped_a_player(PED) then
			return player.get_player_from_ped(PED)
		end
	end
	for s=-1,(seats-2) do
		local PED = ntv.get.last_ped_in_seat(_veh,s)
		if ped.is_ped_a_player(PED) then
			return player.get_player_from_ped(PED)
		end
	end
	return -1
end


	g.feat.fuck_mors=menu_add_feature("Fuck Mors Mutual","value_str",g.prnt.sssn_vehs.id,function(f)
		local hash_is_pid,pos
		local dmgd = {}
		while f.on do
			hash_is_pid={}
			for pid=0,31 do
				if funcs.doo.sssn_veh_pid_check(pid) then
					hash_is_pid[network.network_hash_from_player(pid)]=pid
				end
			end
			for k,v in pairs(API.veh.get.all()) do
				if not API.ent.is.dead(v) and (f.value == 1 or not dmgd[v]) then
					if hash_is_pid[decorator.decor_get_int(v, "Player_Vehicle")] and funcs.get.vehicle_player(v) == -1 then --if its their personal veh and no one's been in yet
						if funcs.is.v2_in_range(API.ent.get.coords(v),-250,-4,-1220,-1137) then -- if its in the mors depot area
							if funcs.ntwrk.ask_long(v,1000) then
								funcs.doo.veh_damage_guts(v)
								if f.value==0 then
									dmgd[v]=true
								else
									fire.add_explosion(API.ent.get.coords(v), 0, true, false, 0, v)
								end
							end
						end
					end
				end
			end


			YIELD(500)
		end
	end,"Any personal vehicle (friend/org/modder selected) that is claimed through Mors Mutual and is sitting at the depot will be destroyed.") --.hint
	new_set_str_data(g.feat.fuck_mors,{"Damage","Destroy"})


	g.tbl.veh_near = {}
	g.tbl.veh_near.stop_zoom=menu_add_feature("Nearby Vehicles stop/zoom","value_str",g.prnt.sssn_vehs.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"zoom_zoom",f.value*200)
			funcs.doo.sssn_plyr_veh_action("zoom_zoom",f.value*200,true)
			YIELD(25)
		end
	end)
	new_set_str_data(g.tbl.veh_near.stop_zoom,{"Stop","Zoom Zoom"})

-------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.float=menu_add_feature("Nearby Vehicles float","value_str",g.prnt.sssn_vehs.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"float",f.value+25+(f.value*174))
			funcs.doo.sssn_plyr_veh_action("float",f.value+25+(f.value*174),true)
			YIELD(250)
		end
	end)
	new_set_str_data(g.tbl.veh_near.float,{"Gently","YEET"})

-------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.go_down=menu_add_feature("Nearby Vehicles in air go down","value_str",g.prnt.sssn_vehs.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"air_down",(f.value+25+(f.value*174))*-1)
			funcs.doo.sssn_plyr_veh_action("air_down",(f.value+25+(f.value*174))*-1,true)
			YIELD(250)
		end
	end)
	new_set_str_data(g.tbl.veh_near.go_down,{"Gently","YEET"})

-------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.go_up=menu_add_feature("Nearby Vehicles on ground go up","value_str",g.prnt.sssn_vehs.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"ground_up",f.value+25+(f.value*174))
			funcs.doo.sssn_plyr_veh_action("ground_up",f.value+25+(f.value*174),true)
			YIELD(250)
		end
	end)
	new_set_str_data(g.tbl.veh_near.go_up,{"Gently","YEET"})

-------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.gravity=menu_add_feature("Gravity","value_str",g.prnt.sssn_vehs.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"gravity",f.value==0)
			funcs.doo.sssn_plyr_veh_action("gravity",f.value==0,true)
			YIELD(250)
		end
	end)
	new_set_str_data(g.tbl.veh_near.gravity,{"Give","Remove"})

-------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.auto_repair=menu_add_feature("Auto-repair if less than %","value_i",g.prnt.sssn_vehs.id,function(f, pid)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"repair_auto",f.value)
			funcs.doo.sssn_plyr_veh_action("repair_auto",f.value,true)
			YIELD(250)
		end
	end)
	funcs.set_feat_i_f(g.tbl.veh_near.auto_repair,50,100,5,75)

	--------------------------------------------------------------------------------------------------------------------------------------------
	g.tbl.sssn_stf.hrn_bst_feat=menu_add_feature("Horn-boost","slider",g.tbl.sssn_stf.hrn_bst.id,function(f)
		while f.on do
			funcs.doo.all_veh_action_thread_start(1000,"horn_boost",f.value)
			funcs.doo.sssn_plyr_veh_action("horn_boost",f.value,true)
			YIELD(25)
		end
	end)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hrn_bst_feat,0,.1,.01,.01)

	g.tbl.sssn_stf.hrn_bst_delay=menu_add_feature("Boost delay","action_value_i",g.tbl.sssn_stf.hrn_bst.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hrn_bst_delay,25,1000,25,75)

	g.tbl.sssn_stf.hrn_bst_initial=menu_add_feature("Initial boost","action_value_f",g.tbl.sssn_stf.hrn_bst.id)
	funcs.set_feat_i_f(g.tbl.sssn_stf.hrn_bst_initial,.5,3,.1,1)

	g.tbl.sssn_stf.hrn_hnk=menu_add_feature("Honk horn","action_value_str",g.tbl.sssn_stf.hrn_bst.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,"horn_"..string.lower(f.str_data[f.value+1]),f.value,true)
		funcs.doo.sssn_plyr_veh_action("horn_"..string.lower(f.str_data[f.value+1]),f.value,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.hrn_hnk,{"Honk","Stop"})

----------------------------------------------------------------------------------------------------------------------------------
	g.tbl.veh_near.health=menu_add_feature("Vehicle health","action_value_str",g.prnt.sssn_vehs.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,f.str_data[f.value+1]:lower(),nil,true)
		funcs.doo.sssn_plyr_veh_action(f.str_data[f.value+1]:lower(),nil,false,true)
	end)
	new_set_str_data(g.tbl.veh_near.health,{"Repair","Damage","Destroy"})

	g.tbl.veh_near.collision=menu_add_feature("Vehicle Collision","action_value_str",g.prnt.sssn_vehs.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"collision",f.value==0,true)
		funcs.doo.sssn_plyr_veh_action("collision",f.value==0,false,true)
	end)
	new_set_str_data(g.tbl.veh_near.collision,{"Give","Remove"})

	g.tbl.sssn_stf.veh_god2=menu_add_feature("Vehicle God","action_value_str",g.prnt.sssn_vehs.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,"god",f.value==0,true)
		funcs.doo.sssn_plyr_veh_action("god",f.value==0,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_god2,{"Give","Remove"})

	g.tbl.sssn_stf.veh_no_lock2=menu_add_feature("Missile anti-lock","action_value_str",g.prnt.sssn_vehs.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,"anti_lock",f.value==1,true)
		funcs.doo.sssn_plyr_veh_action("anti_lock",f.value==1,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_no_lock2,{"Give","Remove"})

	g.tbl.sssn_stf.veh_force2=menu_add_feature("Vehicle max speed/torque %","action_value_f",g.prnt.sssn_vehs.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,"speed_torque",f.value,true)
		funcs.doo.sssn_plyr_veh_action("speed_torque",f.value,false,true)
	end)
	funcs.set_feat_i_f(g.tbl.sssn_stf.veh_force2,0,700,5,100,"g.tbl.sssn_stf.veh_force2")

	g.tbl.sssn_stf.veh_fuck2=menu_add_feature("Fuck vehicles","action",g.prnt.sssn_vehs.id,function(f)
		funcs.doo.all_veh_action_thread_start(1000,"fucked",nil,true)
		funcs.doo.sssn_plyr_veh_action("fucked",nil,false,true)
	end)

	g.tbl.sssn_stf.veh_upgr2=menu_add_feature("Vehicle Upgrades","action_value_str",g.prnt.sssn_vehs.id,function(f)
		local _table = {[0] = "upgrades",[1] = "perf",[2] = "wheels",[3] = "f1",[4] = "headlights",[5] = "neons",[6] = "paint",[7] = "livery",[8] = "weapons"}
		funcs.doo.all_veh_action_thread_start(1000,_table[f.value],nil,true)
		funcs.doo.sssn_plyr_veh_action(_table[f.value],nil,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_upgr2,{"Everything", "Performance mods","Wheels/Tires","Give F1 Wheels","Headlights","Neon lights","Paintjob","Livery","Weapons"})

	g.tbl.sssn_stf.veh_kick2=menu_add_feature("Vehicle kick","action",g.prnt.sssn_vehs.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"kick_all_npc_from_veh",nil,true)
		funcs.doo.sssn_plyr_veh_action("kick_pid_from_veh",nil,false,true)
	end)

	g.tbl.sssn_stf.helo_fuck2=menu_add_feature("Remove helicopter rotors","action",g.prnt.sssn_vehs.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"remove_rotor",nil,true)
		funcs.doo.sssn_plyr_veh_action("remove_rotor",nil,false,true)
	end)

	g.tbl.sssn_stf.veh_rmv_weap=menu_add_feature("Remove vehicle weapons","action",g.prnt.sssn_vehs.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"rmv_veh_weap",nil,true)
		funcs.doo.sssn_plyr_veh_action("rmv_veh_weap",nil,false,true)
	end)

	g.tbl.sssn_stf.veh_tire_pop2=menu_add_feature("Tire health","action_value_str",g.prnt.sssn_vehs.id,function(f, pid)
		local _table = {[0]="pop_tires",[1]="unpop_tires"}
		funcs.doo.all_veh_action_thread_start(1000,_table[f.value],nil,true)
		funcs.doo.sssn_plyr_veh_action(_table[f.value],nil,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_tire_pop2,{"Pop", "Repair"})

	g.tbl.sssn_stf.veh_flip_wrong=menu_add_feature("Flip vehicle upside down","action",g.prnt.sssn_vehs.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"flip_wrong",nil,true)
		funcs.doo.sssn_plyr_veh_action("flip_wrong",nil,false,true)
	end)

	g.tbl.sssn_stf.veh_visible=menu_add_feature("Vehicle visibility", "action_value_str", g.prnt.sssn_vehs.id, function(f,pid)
		funcs.doo.all_veh_action_thread_start(1000,"visible",f.value==1,true)
		funcs.doo.sssn_plyr_veh_action("visible",f.value==1,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_visible,{"Invisible", "Visible"})


	g.tbl.sssn_stf.veh_tp_mean_in2=menu_add_feature("Interior","action_value_str",g.tbl.sssn_stf.tp_prnt.id,function(f, pid)
		local _table = {[0] = "maze_glitch",[1] = "fib_top",[2] = "apt_glitch"}
		funcs.doo.all_veh_action_thread_start(1000,"tp",_table[f.value],true)
		funcs.doo.sssn_plyr_veh_action("tp",_table[f.value],false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_tp_mean_in2,{"Maze bank glitch", "FIB building top","Apartment glitch"})

	g.tbl.sssn_stf.veh_tp_mean_out2=menu_add_feature("High above","action_value_str",g.tbl.sssn_stf.tp_prnt.id,function(f, pid)
		local _table = {[0] = "ocean_high",[1] = "chiliad_high",[2] = "city_high"}
		funcs.doo.all_veh_action_thread_start(1000,"tp",_table[f.value],true)
		funcs.doo.sssn_plyr_veh_action("tp",_table[f.value],false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_tp_mean_out2,{"The Ocean","Mt. Chiliad","The City"})

	g.tbl.sssn_stf.veh_tp_into_air2=menu_add_feature("Above their position","action_value_str",g.tbl.sssn_stf.tp_prnt.id,function(f, pid)
		local _table = {[0]=50,[1]=250,[2]=1000}
		funcs.doo.all_veh_action_thread_start(1000,"tp_up",_table[f.value],true)
		funcs.doo.sssn_plyr_veh_action("tp_up",_table[f.value],false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_tp_into_air2,{"50m up","250m up","1000m up"})

	g.tbl.sssn_stf.veh_tp_to_me2=menu_add_feature("To me","action_value_str",g.tbl.sssn_stf.tp_prnt.id,function(f)
		g.tbl.sssn_my_pos_front[#g.tbl.sssn_my_pos_front+1]={}
		local _int=#g.tbl.sssn_my_pos_front
		local my_pos = funcs.get.front_of_pos(funcs.ME._crds(), funcs.ME._head(), 10, 180, 1)
		for i=1,200 do
			if f.value == 0 then
				g.tbl.sssn_my_pos_front[_int][i]=(my_pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),mth.rndm(1,5)))
			elseif f.value==1 then
				g.tbl.sssn_my_pos_front[_int][i]=(my_pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),mth.rndm(240,260)))
			else
				g.tbl.sssn_my_pos_front[_int][i]=(my_pos+funcs.vec(mth.rndm(-5,5),mth.rndm(-5,5),mth.rndm(990,1010)))
			end
		end
		funcs.doo.all_veh_action_thread_start(1000,"tp_2_me",_int,true)
		funcs.doo.sssn_plyr_veh_action("tp_2_me",_int,false,true)
	end)
	new_set_str_data(g.tbl.sssn_stf.veh_tp_to_me2,{"In front of me","250m up","1000m up"})

	g.tbl.sssn_stf.veh_tp_to_random=menu_add_feature("TP to random location","action",g.tbl.sssn_stf.tp_prnt.id,function(f, pid)
		funcs.doo.all_veh_action_thread_start(1000,"tp","anywhere",true)
		funcs.doo.sssn_plyr_veh_action("tp","anywhere",false,true)
	end)


g.print_load_info("Local session features",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)---------------------------------------PLAYERS LOCAL END
g.var.feat_loading_str = "Config file or defaults"


g.feat.plyr_leave = event.add_event_listener("player_leave", function(listener)
	if listener.player == API.plyr.my_id() and g.feat.auto_re_kick.value == 0 then
		g.tbl.pid_kicked_mem={}
		if g.feat.auto_re_kick.on then
			g.N_P(2,"You have left the session.\nPlayers kicked memory reset",__GV__,10,"Yellow")
		end
	end
	funcs.doo.wipe_tbl(g.tbl.online_veh_grief[listener.player])
end)

local function apply_translation(current_language)
	if selected_lang==current_language then
		return true
	end
	local count = 0
	local is_english = current_language == "English"
	local lang_tbl=lang[current_language]
	if lang_tbl then
		for k,v in pairs(dynamic_translation) do
			local OG_FEAT = v.FEAT
			if OG_FEAT then
				local this_feat = lang_tbl[k]
				local OG_NAME = v.NAME
				if OG_NAME then
					local FEAT_NAME = this_feat and this_feat.FEAT_NAME
					FEAT_NAME = FEAT_NAME and FEAT_NAME[OG_NAME]
					if OG_FEAT.name then
						OG_FEAT.name = FEAT_NAME or OG_NAME
					else
						local FEATS = OG_FEAT.feats
						if FEATS and FEATS[0] and FEATS[0].name then
							for i=0,31 do
								FEATS[i].name = FEAT_NAME or OG_NAME
							end
						end
					end
				end
				local OG_HINT = v.HINT
				local FEAT_HINT = this_feat and this_feat.FEAT_HINT
				if OG_HINT or FEAT_HINT then
					if (OG_HINT and FEAT_HINT) or is_english then
						OG_FEAT.hint = FEAT_HINT and FEAT_HINT[OG_HINT] or OG_HINT
					elseif FEAT_HINT then
						for kk,vv in pairs(FEAT_HINT) do
							OG_FEAT.hint = vv
						end
					end
				end
				local TBL = v.TBL
				if TBL then
					local temp2={}
					local FEAT_TBL = this_feat and this_feat.FEAT_TBL
					for kk,vv in ipairs(TBL) do
						temp2[#temp2+1] = FEAT_TBL and FEAT_TBL[vv] or vv
					end
					OG_FEAT:set_str_data(temp2)
				end
				count=count+1
				if count%50==0 then
					YIELD(0)
				end
			end
		end
		selected_lang=current_language
		funcs.doo.apply_gee_watch_feat_name_translation()
		return true
	end
end

og_menu_add_feature("Language","action_value_str",g.prnt.optns.id,function(f)
	local str=f.str_data[f.value+1]
	local count = 0
	if apply_translation(str) then
		g.prnt.optns:toggle()
		funcs.doo.check_create_dir(g.paths._user)
		local file = io.open(g.paths._user.."Selected Translation.txt", "w")
		if file then
			file:write(str)
			file:close()
			g.N_P(3,"Language set to "..str.."\nSetting is saved here:\n"..g.paths._user.."Selected Translation.txt",__GV__,7,"Blue")
		else
			g.N_P(3,"Could not save language setting. Do you have 'Selected Translation.txt' open??",__GV__,7,"Red")
		end
	end

end):set_str_data(lang_str_tbl)

menu_add_feature("Copy Gee-Skid Discord link to clipboard","action",g.prnt.optns.id,function(f)
	local str= "https://discord.gg/gee-skid"
	utils.to_clipboard(str)
	g.N_P(2,"Copied link to clipboard\n"..str,__GV__,7,"Green")
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------SAVE START



g._save_stuff = {}


g._old_save_list ={}

g._save_stuff.type_bool={}
g._save_stuff.type_bool[1]=true 	-- toggle

g._save_stuff.type_val = {}
g._save_stuff.type_val[518]=true	--action_slider
g._save_stuff.type_val[522]=true	--action_value_i
g._save_stuff.type_val[546]=true	--action_value_str
g._save_stuff.type_val[642]=true	--action_value_f
g._save_stuff.type_val[1030]=true	--autoaction_slider
g._save_stuff.type_val[1034]=true	--autoaction_value_i
g._save_stuff.type_val[1058]=true	--autoaction_value_str
g._save_stuff.type_val[1154]=true	--autoaction_value_f

g._save_stuff.type_both = {}
g._save_stuff.type_both[7]=true	 	--slider 	toggle
g._save_stuff.type_both[11]=true 	--value_i 	toggle
g._save_stuff.type_both[35]=true 	--value_str toggle
g._save_stuff.type_both[131]=true	--value_f 	toggle


function g._save_stuff.get_feat_bool(_feat)
    return tostring(_feat.on)
end

function g._save_stuff.should_count(_feat,_state)
	if g.tbl.S_L_FEAT[_feat] ~= nil then
		if (tostring(_state)=="true" or tostring(_state)=="false") then
			return true
		elseif g.tbl.S_L_FEAT[_feat].value ~= nil then
			return true
		end
    end
	return false
end


function g._save_stuff.load_sett(_feat,_state)
	if g.tbl.S_L_FEAT[_feat] == nil then
		g._save_stuff.found_bad=true
	elseif tostring(_state)=="true" then
        g.tbl.S_L_FEAT[_feat].on=true
	elseif tostring(_state)=="false" then
        g.tbl.S_L_FEAT[_feat].on=false
    elseif g.tbl.S_L_FEAT[_feat].value == nil then
		g._save_stuff.found_bad=true
	else
		g.tbl.S_L_FEAT[_feat].value=tonumber(_state)
    end
end

g._save_stuff.found_bad=false
g._save_stuff.save_it=menu_add_feature("Save Settings", "action", g.prnt.optns.id, function()
	local save_file_text=""
	local file=io.open(g.paths._user.."GeeSkid_Saved_Settings.cfg","w")
	local _type,_bool,_name
	local count = 0
	table.sort(g.tbl.S_L_NAME, function(a, b) return a:lower() <  b:lower() end)
	for i=1,#g.tbl.S_L_NAME do
		if g.tbl.S_L_FEAT[g.tbl.S_L_NAME[i]] == nil or g.tbl.S_L_FEAT[g.tbl.S_L_NAME[i]].type == nil then
			g.N_P(2,"Invalid entry in save table:\n"..tostring(g.tbl.S_L_NAME[i]).."\nContact dev." ,__GV__,7,"Red")
		else
			_type = g.tbl.S_L_FEAT[g.tbl.S_L_NAME[i]].type
			_bool = g._save_stuff.get_feat_bool(g.tbl.S_L_FEAT[g.tbl.S_L_NAME[i]])
			_name = g.tbl.S_L_NAME[i]
			_value = g.tbl.S_L_FEAT[_name].value
			if g._save_stuff.type_both[_type] then
				if save_file_text~="" then save_file_text=save_file_text.."\n" end
				save_file_text=save_file_text.._name.."=".._bool.."\n".._name.."=".._value
				count = count + 1
			elseif g._save_stuff.type_val[_type] then
				if save_file_text~="" then save_file_text=save_file_text.."\n" end
				save_file_text=save_file_text.._name.."=".._value
				count = count + 1
			elseif g._save_stuff.type_bool[_type] then
				if save_file_text~="" then save_file_text=save_file_text.."\n" end
				save_file_text=save_file_text.._name.."=".._bool
				count = count + 1
			else
				g.N_P(2,"Invalid entry in save table\n".."type: "..tostring(_type).." bool: "..tostring(_bool).." name: "..tostring(_name).." value: "..tostring(_value).."\nContact dev.",__GV__,7,"Red")
			end
		end
		if i % 50 == 0 then
			YIELD(0)
		end
	end
	file:write(save_file_text)
	file:close()
	g.N_P(2,count.." settings saved to:\nGeeSkid_Saved_Settings.cfg",__GV__,7,"Green")
end)

-- og_menu_add_feature("weap", "toggle", 0, function(f)

-- while f.on do
	-- local all_obj=object.get_all_objects()
		-- for i=1,#all_obj do
			-- if API.ent.get.coords(all_obj[i]):magnitude(API.plyr.get.coords(0)) < 25 then
				-- g.N_P(2,ntv.get.ped_veh_weap(player.player_ped()) .."|"..API.ent.get.model_hash(all_obj[i]),__GV__,9,"Yellow")
				-- YIELD(500)
			-- end
		-- end
-- YIELD(0)
-- end
-- end)

g.var.notify_feat_count = false -- all 8000+ wont notify because they load in threads
g._save_stuff.load_it=menu_add_feature("Load Settings", "action", g.prnt.optns.id, function()
	local temp,load_count,old_save = nil,0,false
	if utils.file_exists(g.paths._user.."GeeSkid_Saved_Settings.cfg") then
		local file=io.open(g.paths._user.."GeeSkid_Saved_Settings.cfg","r")
		for i in file:lines() do
			local fields = {}
			i:gsub(string.format("([^%s]+)", "="), function(c) fields[#fields+1] = c end)
			g._save_stuff.load_sett(fields[1],fields[2])
			if g._save_stuff.should_count(fields[1],fields[2]) then
				if temp ~= fields[1] then
					temp = fields[1]
					load_count=load_count+1
				else
					--menu.notify(fields[1].." = "..fields[2])
				end
			end
		end
		file:close()
		if g._save_stuff.found_bad then
			g.N_P(2,"Gee-Skid has been updated. Some saved settings will be skipped until re-save.",__GV__,9,"Yellow")
		end
		g.N_P(2,(g.var.notify_feat_count and total_feat_count.." Features loaded\n" or "")..load_count.."/"..#g.tbl.S_L_NAME.." Settings loaded",__GV__,9,"Green")
	else
		g.N_P(2,(g.var.notify_feat_count and total_feat_count.." Features loaded\n" or "").."Default settings loaded.\nSave your settings here:\nOptions > Save Settings",__GV__,9,"Blue")
	end
	g.tbl.veh_esp.math_do()
	YIELD(0)
	if g.feat.kick_type2 and g.feat.kick_type2.str_data and g.feat.kick_type2.str_data[g.feat.kick_type2.value] and g.feat.kick_type2.str_data[g.feat.kick_type2.value+1] then -- idk why some ppl got errors but hopefully this fixes it
		local selection = tostring(g.feat.kick_type2.str_data[g.feat.kick_type2.value+1])
		if string.find(selection:lower(),"script") then
			g.N_P(2,"Current kick type selected is:\n"..selection.."\n#FF0000FF#Are you sure thats what you want?#DEFAULT#\nYou can change the setting here:\nGee-Skid > Options",__GV__,15,"Yellow")
		else
			g.N_P(2,"Current kick type selected is:\n"..selection.."\nYou can change the setting here:\nGee-Skid > Options",__GV__,10,"Blue")
		end
	end
	g.var.GS_has_loaded=true
	g.var.notify_feat_count=false
end)
g._save_stuff.load_it.on=true
g.print_load_info("Config file or defaults",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)
g.var.feat_loading_str = "Vehicle ESP Images"
----------------------------------------------------------SAVE END
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------Start Screen
-------------------------------------------------------------------------------------------------Below

if debug_translation_record and g.paths._lang then
	g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
		local trans_time = TIME_MS()
		local function get_cunt(str)
			return str:gsub("%w+", "Cunt"):gsub("%d+", " ")
		end
		local function get_tbl(tbl,cunt)
			local str = '{'
			for i=1, #tbl do
				local v = tbl[i]
				str=str..'["'..v..'"] = "'..(cunt and get_cunt(v) or v)..'", '
			end
			return str..'},'
		end
		local templist2={}
		local timer = TIME_MS() + 10
		for k,v in pairs (dynamic_translation) do
			templist2[#templist2+1]=k
			if TIME_MS() > timer then
				YIELD(0)
				timer = TIME_MS() + 10
			end
		end
		table.sort(templist2, function(a, b) return tostring(a):lower() <  tostring(b):lower() end)
		local English='local language = { --this file is auto generated and overwritten (and not actually used for translation)\nNAME = "English",\nLIST= {'
		local Cunt='local language = { --this file is auto generated and overwritten\nNAME = "Australian",\nLIST= {'
		for i=1, #templist2 do
			local v = templist2[i]
			local temp = dynamic_translation[v]
			if temp then
				English=English..'\n["'..v..'"] = {'
				Cunt=Cunt..'\n["'..v..'"] = {'
				local NAME = temp.NAME
				if NAME then
					English=English..'\n    FEAT_NAME = {["'..NAME..'"] = "'..NAME..'"},'
					Cunt=Cunt..'\n    FEAT_NAME = {["'..NAME..'"] = "'..get_cunt(NAME)..'"},'
				end
				local TBL = temp.TBL
				if TBL then
					English=English..'\n    FEAT_TBL = '..get_tbl(TBL,false)
					Cunt=Cunt..'\n    FEAT_TBL = '..get_tbl(TBL,true)
				end
				local HINT = temp.HINT
				if HINT then
					English=English..'\n    FEAT_HINT = {["'..HINT..'"] = "'..HINT..'"},'
					Cunt=Cunt..'\n    FEAT_HINT = {["'..HINT..'"] = "'..get_cunt(HINT)..'"},'
				end

				local FEAT_EXTRAS = temp.FEAT_EXTRAS
				if FEAT_EXTRAS then
					English=English..'\n    FEAT_EXTRAS = '..get_tbl(FEAT_EXTRAS,false)
					Cunt=Cunt..'\n    FEAT_EXTRAS = '..get_tbl(FEAT_EXTRAS,true)
				end
				English=English..'\n},'
				Cunt=Cunt..'\n},'
				if TIME_MS() > timer then
					YIELD(0)
					timer = TIME_MS() + 10
				end
			end
		end
		English=English..'\n}\n}\nreturn language'
		Cunt=Cunt..'\n}\n}\nreturn language'
		local file=io.open(g.paths._lang.."English.lua","w")
		file:write(English)
		file:close()
		YIELD(0)
		file=io.open(g.paths._lang.."Australian.lua","w")
		file:write(Cunt)
		file:close()
		--g.print_load_info("Translations generated",(TIME_MS()-trans_time),debug.getinfo(1).currentline,true,true)
	end)
end

apply_translation(selected_lang)

g.print_load_info(selected_lang.. " Translation applied",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)

g.var.feat_loading_str = "Radar/Map/ESP Images"
YIELD(0)
YIELD(0)

--local break_time=TIME_MS()
local sprite_files, _start,_end,hash_string,sprite = {}
for p=1,4 do
	sprite_files = utils.get_all_files_in_directory(g.paths._2t1..g.tbl.veh_esp.file_paths[p],"png")
	for i=1,#sprite_files do
		sprite = scriptdraw.register_sprite(g.paths._2t1..g.tbl.veh_esp.file_paths[p].."\\"..sprite_files[i])
		if sprite ~= nil then
			_start,_end = string.find(sprite_files[i], "png")
			hash_string = string.sub(sprite_files[i],1,_end-4)
			if p == 1 then
				g.tbl.veh_esp.png_true[API.get_hash_key(hash_string)] = true
				g.tbl.veh_esp.png_int[API.get_hash_key(hash_string)] = sprite
				g.tbl.veh_esp.png_rot_true[API.get_hash_key(hash_string)] = true
			elseif p == 2 then
				g.tbl.veh_esp.png_true[hash_string] = true
				g.tbl.veh_esp.png_int[hash_string] = sprite
				g.tbl.veh_esp.png_rot_true[hash_string] = true
			elseif p == 3 then
				g.tbl.veh_esp.png_true[API.get_hash_key(hash_string)] = true
				g.tbl.veh_esp.png_int[API.get_hash_key(hash_string)] = sprite
				g.tbl.veh_esp.png_rot_true[API.get_hash_key(hash_string)] = false
			else
				g.tbl.veh_esp.png_true[hash_string] = true
				g.tbl.veh_esp.png_int[hash_string] = sprite
				g.tbl.veh_esp.png_rot_true[hash_string] = false
			end
		end
		-- if TIME_MS() > break_time then
			-- YIELD(0)
			-- break_time=TIME_MS()+250
		-- end
	end
	YIELD(0)
end

g.tbl.veh_esp.loaded=true


--g.tbl.threads[#g.tbl.threads+1]=menu.create_thread(function()
	g.var.map_color_combo = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\color_combo.png")
	--YIELD(0)
	g.var.map_dark_combo = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\dark_combo.png")
	--YIELD(0)
	g.var.map_color_cayo = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\cayo_color.png")
	--YIELD(0)
	g.var.map_dark_cayo = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\cayo_dark.png")
	YIELD(0)
	g.var.map_cursor = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\cursor.png")
	--YIELD(0)
	g.var.map_bounty = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bounty.png")
	--YIELD(0)
	g.var.map_passive = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\passive.png")
	--YIELD(0)
	g.var.map_paused = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\usingmenu.png")
	--YIELD(0)
	g.var.map_semicircle = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\semicircle.png")
	--YIELD(0)
	g.var.map_dead = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\dead.png")
	--YIELD(0)
	g.var.map_dead_w = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\dead_w.png")
	--YIELD(0)
	g.var.map_player_heli = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\player_heli.png")--422
	--YIELD(0)
	g.var.map_ai = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\ai.png")--270
	--YIELD(0)
	g.var.map_sub2 = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\sub2.png")--760
	--YIELD(0)
	g.var.map_police_plane_move=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\police_plane_move.png")--16 jet
	--YIELD(0)

	g.var.map_police_heli=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\police_heli.png")--64
	--YIELD(0)
	g.var.map_player_jet = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\player_jet.png")--424
	--YIELD(0)
	g.tbl.plyr_blips = {}
	g.tbl.plyr_blips_w = {}
	for i=1,12 do
		g.tbl.plyr_blips[i-2] = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\player_dots\\"..i..".png")
	--YIELD(0)
		g.tbl.plyr_blips_w[i-2] = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\player_dots_w\\"..i..".png")
		--YIELD(0)
	end
	g.tbl.map_blips={}
	g.tbl.map_blips[826]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\agency.png")
	--YIELD(0)
	g.tbl.map_blips[788]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\securoserve.png")
	--YIELD(0)
	g.tbl.map_blips[784]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\car_robbery_prep.png")
	--YIELD(0)
	g.tbl.map_blips[780]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\docks_export.png")
	--YIELD(0)
	g.tbl.map_blips[779]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\auto_shop_property.png")
	--YIELD(0)
	g.tbl.map_blips[777]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\car_meet.png")
	--YIELD(0)
	g.tbl.map_blips[768]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\underwater_gate.png")
	--YIELD(0)
	g.tbl.map_blips[765]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\island_heist_prep.png")
	--YIELD(0)
	g.tbl.map_blips[740]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\arcade.png")
	--YIELD(0)
	g.tbl.map_blips[679]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\casino.png")
	--YIELD(0)
	g.tbl.map_blips[627]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_drone.png")
	--YIELD(0)
	g.tbl.map_blips[614]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_club_property.png")
	--YIELD(0)
	g.tbl.map_blips[590]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\nhp_base.png")
	--YIELD(0)
	g.tbl.map_blips[569]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\sm_hangar.png")
	--YIELD(0)
	g.tbl.map_blips[557]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\property_bunker.png")
	--YIELD(0)
	g.tbl.map_blips[499]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\production_meth.png")
	--YIELD(0)
	g.tbl.map_blips[500]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\production_money.png")
	--YIELD(0)
	g.tbl.map_blips[498]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\production_fake_id.png")
	--YIELD(0)
	g.tbl.map_blips[497]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\production_crack.png")
	--YIELD(0)
	g.tbl.map_blips[492]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\biker_clubhouse.png")
	--YIELD(0)
	g.tbl.map_blips[475]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\office.png")
	--YIELD(0)
	g.tbl.map_blips[473]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\warehouse.png")
	--YIELD(0)
	g.tbl.map_blips[496]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\production_weed.png")
	--YIELD(0)
	g.tbl.map_blips[40]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\safehouse.png")
	--YIELD(0)
	g.tbl.map_blips[455]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\yacht.png")
	--YIELD(0)
	g.tbl.map_blips[524]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\warehouse_vehicle.png")
	--YIELD(0)
	g.tbl.map_blips[418]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bounty_hit_inside.png")
	--YIELD(0)
	g.tbl.map_blips[417]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\level_inside.png")
	--YIELD(0)
	g.tbl.map_blips[556]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\supplies.png")---------------
	--YIELD(0)
	g.tbl.map_blips[615]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_cargo.png")
	--YIELD(0)
	g.tbl.map_blips[478]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\contraband.png")
	--YIELD(0)
	g.tbl.map_blips[501]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\package.png")
	--YIELD(0)
	g.tbl.map_blips[84]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\rampage.png")
	--YIELD(0)
	g.tbl.map_blips[429]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\temp_1.png")--skull
	--YIELD(0)
	g.tbl.map_blips[630]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_assassinate.png")
	--YIELD(0)
	g.tbl.map_blips[436]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\hot_property.png")
	--YIELD(0)
	g.tbl.map_blips[442]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\beast.png")
	--YIELD(0)
	g.tbl.map_blips[307]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\plane_drop.png")
	--YIELD(0)
	g.tbl.map_blips[523]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\sports_car.png")
	--YIELD(0)
	g.tbl.map_blips[568]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\sm_cargo.png")
	--YIELD(0)
	g.tbl.map_blips[643]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\arena_workshop.png")
	--YIELD(0)
	g.tbl.map_blips[432]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\temp_4.png")
	--YIELD(0)
	g.tbl.map_blips[433]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\temp_5.png")
	--YIELD(0)
	g.tbl.map_blips[586]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\nhp_bag.png")
	--YIELD(0)
	g.tbl.map_blips[272]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\cash_pickup.png")
	--YIELD(0)
	g.tbl.map_blips[469]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\pickup_weed.png")
	--YIELD(0)
	g.tbl.map_blips[514]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\drugs_package.png")
	--YIELD(0)
	g.tbl.map_blips[618]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_hack_gold.png")
	--YIELD(0)
	g.tbl.map_blips[794]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\export_vehicle.png")
	--YIELD(0)
	g.tbl.map_blips[51]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\crim_drugs.png")
	--YIELD(0)
	g.tbl.map_blips[616]=scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Map\\bat_truck.png")
	--YIELD(0)

	 g.var.map_images_loaded=true
--end)

--YIELD(0)
g.tbl.RADAR.waypoint = scriptdraw.register_sprite(g.paths._radar.."waypoint.png")
--YIELD(0)
g.tbl.RADAR.objective = scriptdraw.register_sprite(g.paths._radar.."objective.png")
--YIELD(0)
g.tbl.RADAR.circle1 = scriptdraw.register_sprite(g.paths._radar.."radar_circle1.png")
--YIELD(0)
g.tbl.RADAR.circle2 = scriptdraw.register_sprite(g.paths._radar.."radar_circle2.png")
--YIELD(0)
g.tbl.RADAR.dead_x = scriptdraw.register_sprite(g.paths._radar.."dead_x.png")
--YIELD(0)
g.tbl.RADAR.ring1 = scriptdraw.register_sprite(g.paths._radar.."ring_white1.png")
--YIELD(0)
g.tbl.RADAR.ring2 = scriptdraw.register_sprite(g.paths._radar.."ring_white2.png")
--YIELD(0)
g.tbl.RADAR.ring3 = scriptdraw.register_sprite(g.paths._radar.."ring_white3.png")
--YIELD(0)
g.tbl.RADAR.ring4 = scriptdraw.register_sprite(g.paths._radar.."ring_white4.png")
--YIELD(0)
g.tbl.RADAR.arrow3 = scriptdraw.register_sprite(g.paths._radar.."radar_arrow3.png")
--YIELD(0)
g.tbl.RADAR.boom = scriptdraw.register_sprite(g.paths._radar.."boom.png")
--YIELD(0)

g.print_load_info("Radar/Map/ESP Images",(TIME_MS()-g.script_load_time_temp),debug.getinfo(1).currentline)

g.var.feat_loading_str = "Loaded in "..(TIME_MS()-g.script_load_time).."ms"

g.tbl.RADAR.loaded=true


print("--- "..__GV__.." - Loaded in "..(TIME_MS()-g.script_load_time).."ms ---")
ui.notify_above_map("Welcome to ~g~"..__GV__.."\n~w~"..(os.getenv("USERNAME") or "Weird Username") .."", "", 2)
if g._show_voidkot.on then
	local int = 1
	local splash_table = {}
	for i=1,90 do
		splash_table[i] = scriptdraw.register_sprite(g.paths._2t1.."\\scripts\\GeeSkid_v2\\Images\\Voidkot\\"..i..".png")
		if i%2==0 then
			YIELD(0)
		end
	end
	while mth.flr(int) <= 90 do
		YIELD(5)
		API.SD.draw_sprt(splash_table[mth.flr(int)],funcs.vec(0,0),API.gfx.get_h()/1080,0, funcs.get.rgba_to_int(255,255,255,255))
		int=int+0.25
	end
end



local record_new_vehicles = false
if record_new_vehicles then
	local all_vehs = vehicle.get_all_vehicle_model_hashes()
	local msg = ""
	for  i=1,#all_vehs do
		if not veh_stuff.info[all_vehs[i]] then
			if streaming.does_vehicle_model_have_parachute(all_vehs[i]) then
				menu.notify("Chute: "..all_vehs[i])
			end
			streaming.request_model(all_vehs[i])
			local time = TIME_MS() + 1000
			while not streaming.has_model_loaded(all_vehs[i]) and time > TIME_MS() do
				YIELD(10)
			end
			local _veh = vehicle.create_vehicle(all_vehs[i], player.get_player_coords(-1)+v3(math.random(5,10),math.random(5,10),0.5), 0.0, false, false)
			YIELD(0)
			if not funcs.is.ent(_veh) then
				menu.notify("Failed: "..all_vehs[i])
			else

				if gameplay.get_hash_key("speedo4")==all_vehs[i] or gameplay.get_hash_key("apc")==all_vehs[i] then
					vehicle.set_vehicle_mod(_veh, 10, 2)
				else
					if vehicle.get_num_vehicle_mods(_veh, 10) == 1 then
						vehicle.set_vehicle_mod(_veh, 10, 0)
					else
						vehicle.set_vehicle_mod(_veh, 10, 1)
					end
				end
				if gameplay.get_hash_key("khanjali")==all_vehs[i] then
					vehicle.set_vehicle_mod(_veh, 5, vehicle.get_num_vehicle_mods(_veh, 5) - 1)
				end
				vehicle.set_vehicle_mod(_veh, 45, vehicle.get_num_vehicle_mods(_veh, 45) - 1)
				if gameplay.get_hash_key("tampa3")==all_vehs[i] then
					vehicle.set_vehicle_mod(_veh, 1, vehicle.get_num_vehicle_mods(_veh, 1) - 1)
					vehicle.set_vehicle_mod(_veh, 2, vehicle.get_num_vehicle_mods(_veh, 2) - 1)
				end
				vehicle.set_vehicle_mod(_veh, 9, vehicle.get_num_vehicle_mods(_veh, 9) - 1)

				local time=TIME_MS()+3000
				while not vehicle.set_vehicle_on_ground_properly(_veh) and time>TIME_MS() do
					YIELD(250)
				end
				local _min,_max = API.ent.get.dimensions(_veh)
				local spwn = math.max(math.abs(_min.x),math.abs(_max.x))+math.max(math.abs(_min.y),math.abs(_max.y))
				msg=msg.."\n    ["..all_vehs[i].."] = {"
				msg=msg.."\n        MODEL = "..'"'..((vehicle.get_vehicle_model(_veh) and vehicle.get_vehicle_model(_veh)) or  "Unknown Model")..'"'..","
				msg=msg.."\n        BRAND = "..'"'..((vehicle.get_vehicle_brand(_veh) and vehicle.get_vehicle_brand(_veh)) or "")..'"'..","
				msg=msg.."\n        CLASS_I = "..vehicle.get_vehicle_class(_veh)..","
				msg=msg.."\n        CLASS_STR = "..'"'..vehicle.get_vehicle_class_name(_veh)..'"'..","
				msg=msg.."\n        Z_HEIGHT = "..(native.call(0x1DD55701034110E5, _veh):__tonumber())..","
				msg=msg.."\n        X_MIN = ".._min.x..","
				msg=msg.."\n        X_MAX = ".._max.x..","
				msg=msg.."\n        Y_MIN = ".._min.y..","
				msg=msg.."\n        Y_MAX = ".._max.y..","
				msg=msg.."\n        Z_MIN = ".._min.z..","
				msg=msg.."\n        Z_MAX = ".._max.z..","
				msg=msg.."\n        SPWN = "..spwn..","
				msg=msg.."\n        SEATS = "..vehicle.get_vehicle_model_number_of_seats(all_vehs[i])..","
				msg=msg.."\n        WEAP = "..tostring(native.call(0x25ECB9F8017D98E0,_veh):__tointeger(true)==1)..","
				msg=msg.."\n    },"
				entity.set_entity_as_no_longer_needed(_veh)
				entity.delete_entity(_veh)
				streaming.set_model_as_no_longer_needed(all_vehs[i])
			end
		end
	end
	local file=io.open(utils.get_appdata_path("PopstarDevs", "").."\\2Take1Menu\\VEH_DUMP.txt","w")
	file:write(msg)
	file:close()
end
-- menu_add_feature("Globals","action",0, function(f)
-- local globalCount = 0
-- for k,v in pairs(_G) do
    -- globalCount = globalCount + 1
	-- print(k)
-- end
-- menu.notify(globalCount)
-- end)


-------------------------------------------------------------------------------------------------------------------------------------------------
end)
